import * as Yoga from 'yoga-layout';
import { alignFlexProps } from './alignFlexProps';
// prettier-ignore
/**
 * This map provides the prop setters as well as the types for the props. The
 * first input of a setter is used as the prop value. The second input is the
 * node to apply the prop to. The value of a prop needs to be a primitive type,
 * so that it can be trivially compared to the previous value. This is used to
 * prevent unnecessary reflows.
 */
export const propSetter = {
    alignItems: (align, node) => node.setAlignItems(Yoga.Align[align]),
    alignSelf: (align, node) => node.setAlignSelf(Yoga.Align[align]),
    alignContent: (align, node) => node.setAlignContent(Yoga.Align[align]),
    justifyContent: (justify, node) => node.setJustifyContent(Yoga.Justify[justify]),
    flexDirection: (dir, node) => node.setFlexDirection(Yoga.FlexDirection[dir]),
    flexWrap: (wrap, node) => node.setFlexWrap(Yoga.Wrap[wrap]),
    flex: (flex, node) => node.setFlex(flex),
    flexBasis: (basis, node) => node.setFlexBasis(basis),
    flexGrow: (grow, node) => node.setFlexGrow(grow),
    flexShrink: (shrink, node) => node.setFlexShrink(shrink),
    height: (height, node) => node.setHeight(height),
    width: (width, node) => node.setWidth(width),
    maxHeight: (maxHeight, node) => node.setMaxHeight(maxHeight),
    maxWidth: (maxWidth, node) => node.setMaxWidth(maxWidth),
    minHeight: (minHeight, node) => node.setMinHeight(minHeight),
    minWidth: (minWidth, node) => node.setMinWidth(minWidth),
    /** As of now, this won't work since the bounding box is still computed by nodes marked as absolutely positioned  */
    // position: (positionType: keyof typeof PositionType, node: Node) => node.setPositionType(Yoga.PositionType[positionType]),
    top: (top, node) => node.setPosition(Yoga.Edge.Top, top),
    right: (right, node) => node.setPosition(Yoga.Edge.Right, right),
    bottom: (bottom, node) => node.setPosition(Yoga.Edge.Bottom, bottom),
    left: (left, node) => node.setPosition(Yoga.Edge.Left, left),
    padding: (padding, node) => node.setPadding(Yoga.Edge.All, padding),
    paddingTop: (paddingTop, node) => node.setPadding(Yoga.Edge.Top, paddingTop),
    paddingRight: (paddingRight, node) => node.setPadding(Yoga.Edge.Right, paddingRight),
    paddingBottom: (paddingBottom, node) => node.setPadding(Yoga.Edge.Bottom, paddingBottom),
    paddingLeft: (paddingLeft, node) => node.setPadding(Yoga.Edge.Left, paddingLeft),
    margin: (margin, node) => node.setMargin(Yoga.Edge.All, margin),
    marginTop: (marginTop, node) => node.setMargin(Yoga.Edge.Top, marginTop),
    marginRight: (marginRight, node) => node.setMargin(Yoga.Edge.Right, marginRight),
    marginBottom: (marginBottom, node) => node.setMargin(Yoga.Edge.Bottom, marginBottom),
    marginLeft: (marginLeft, node) => node.setMargin(Yoga.Edge.Left, marginLeft),
    gap: (gap, node) => node.setGap(Yoga.Gutter.All, gap),
    gapColumn: (gapColumn, node) => node.setGap(Yoga.Gutter.Column, gapColumn),
    gapRow: (gapRow, node) => node.setGap(Yoga.Gutter.Row, gapRow),
    aspectRatio: (aspectRatio, node) => node.setAspectRatio(aspectRatio),
};
/**
 * Applies scale factor to props that are numbers. This is used to scale the
 * props to the current scale factor of the root node because yoga-layout
 * is made to work with integer values.
 */
const applyScaleFactor = (prop, scaleFactor) => {
    if (typeof prop === 'number') {
        return prop * scaleFactor;
    }
    return prop;
};
export const applyNodeProps = (node, props, scaleFactor) => {
    return Object.entries(alignFlexProps(props)).forEach(([key, value]) => {
        const scaledValue = applyScaleFactor(value, scaleFactor);
        propSetter[key]?.(scaledValue, node);
    });
};
