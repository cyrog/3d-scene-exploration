import {
  T,
  asyncWritable,
  createCacheContext,
  createCameraContext,
  createDOMContext,
  createParentContext,
  createParentObject3DContext,
  createSceneContext,
  createUserContext,
  currentWritable,
  injectPlugin,
  isInstanceOf,
  observe,
  revision,
  useCache,
  useDOM,
  useLoader,
  useParent,
  useParentObject3D,
  useStage,
  useTask,
  useThrelte,
  useThrelteUserContext,
  watch
} from "./chunk-6OBJMPZB.js";
import {
  fromStore
} from "./chunk-BLTWZSTJ.js";
import "./chunk-AO2GJA7O.js";
import {
  AdditiveBlending,
  AlwaysStencilFunc,
  AnimationClip,
  AnimationMixer,
  Audio,
  AudioListener,
  AudioLoader,
  BackSide,
  Bone,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  CanvasTexture,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorManagement,
  CompressedArrayTexture,
  CompressedCubeTexture,
  CompressedTexture,
  Controls,
  CubeCamera,
  CubeTexture,
  CubeTextureLoader,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DefaultLoadingManager,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DynamicDrawUsage,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  Euler,
  ExtrudeGeometry,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  ImageBitmapLoader,
  ImageLoader,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  KeepStencilOp,
  LOD,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoColorSpace,
  NoToneMapping,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PositionalAudio,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGFormat,
  RGIntegerFormat,
  Ray,
  Raycaster,
  RedFormat,
  RedIntegerFormat,
  RepeatWrapping,
  ReplaceStencilOp,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  Shape,
  ShapePath,
  ShortType,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  Sprite,
  SpriteMaterial,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedIntType,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry
} from "./chunk-M6G45IOH.js";
import {
  action,
  add_locations,
  assign,
  bind_this,
  check_target,
  clsx,
  component,
  derived as derived2,
  element,
  get as get2,
  hmr,
  if_block,
  init,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  readable,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  setup_stores,
  slot,
  snippet,
  spread_props,
  store_get,
  store_set,
  transition,
  validate_dynamic_element_tag,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet,
  writable
} from "./chunk-EMMROBY2.js";
import {
  append,
  comment,
  template
} from "./chunk-V64IDCGO.js";
import {
  ADD_OWNER,
  FILENAME,
  HMR,
  add_owner,
  add_owner_effect,
  child,
  deep_read_state,
  derived,
  equals,
  first_child,
  get,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  template_effect,
  tick,
  untrack,
  user_effect,
  user_pre_effect
} from "./chunk-GBOUYSEE.js";
import "./chunk-X4XZK27Q.js";
import "./chunk-KUDUHDHN.js";
import "./chunk-RIXFT5AQ.js";
import "./chunk-RVAV4ZRS.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __publicField,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/tweakpane/dist/tweakpane.js
var require_tweakpane = __commonJS({
  "node_modules/tweakpane/dist/tweakpane.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Tweakpane = {}));
    })(exports, function(exports2) {
      "use strict";
      class Semver {
        /**
         * @hidden
         */
        constructor(text) {
          const [core, prerelease] = text.split("-");
          const coreComps = core.split(".");
          this.major = parseInt(coreComps[0], 10);
          this.minor = parseInt(coreComps[1], 10);
          this.patch = parseInt(coreComps[2], 10);
          this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }
        toString() {
          const core = [this.major, this.minor, this.patch].join(".");
          return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
        }
      }
      class BladeApi {
        constructor(controller) {
          this.controller_ = controller;
        }
        get element() {
          return this.controller_.view.element;
        }
        get disabled() {
          return this.controller_.viewProps.get("disabled");
        }
        set disabled(disabled) {
          this.controller_.viewProps.set("disabled", disabled);
        }
        get hidden() {
          return this.controller_.viewProps.get("hidden");
        }
        set hidden(hidden) {
          this.controller_.viewProps.set("hidden", hidden);
        }
        dispose() {
          this.controller_.viewProps.set("disposed", true);
        }
      }
      class TpEvent {
        constructor(target) {
          this.target = target;
        }
      }
      class TpChangeEvent extends TpEvent {
        constructor(target, value, presetKey, last) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
          this.last = last !== null && last !== void 0 ? last : true;
        }
      }
      class TpUpdateEvent extends TpEvent {
        constructor(target, value, presetKey) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
        }
      }
      class TpFoldEvent extends TpEvent {
        constructor(target, expanded) {
          super(target);
          this.expanded = expanded;
        }
      }
      class TpTabSelectEvent extends TpEvent {
        constructor(target, index) {
          super(target);
          this.index = index;
        }
      }
      function forceCast(v4) {
        return v4;
      }
      function isEmpty(value) {
        return value === null || value === void 0;
      }
      function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
          return false;
        }
        for (let i = 0; i < a1.length; i++) {
          if (a1[i] !== a2[i]) {
            return false;
          }
        }
        return true;
      }
      function isPropertyWritable(obj, key2) {
        let target = obj;
        do {
          const d = Object.getOwnPropertyDescriptor(target, key2);
          if (d && (d.set !== void 0 || d.writable === true)) {
            return true;
          }
          target = Object.getPrototypeOf(target);
        } while (target !== null);
        return false;
      }
      const CREATE_MESSAGE_MAP = {
        alreadydisposed: () => "View has been already disposed",
        invalidparams: (context) => `Invalid parameters for '${context.name}'`,
        nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
        nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
        notbindable: () => `Value is not bindable`,
        propertynotfound: (context) => `Property '${context.name}' not found`,
        shouldneverhappen: () => "This error should never happen"
      };
      class TpError {
        static alreadyDisposed() {
          return new TpError({ type: "alreadydisposed" });
        }
        static notBindable() {
          return new TpError({
            type: "notbindable"
          });
        }
        static propertyNotFound(name) {
          return new TpError({
            type: "propertynotfound",
            context: {
              name
            }
          });
        }
        static shouldNeverHappen() {
          return new TpError({ type: "shouldneverhappen" });
        }
        constructor(config) {
          var _a2;
          this.message = (_a2 = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a2 !== void 0 ? _a2 : "Unexpected error";
          this.name = this.constructor.name;
          this.stack = new Error(this.message).stack;
          this.type = config.type;
        }
      }
      class BindingTarget {
        constructor(obj, key2, opt_id) {
          this.obj_ = obj;
          this.key_ = key2;
          this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key2;
        }
        static isBindable(obj) {
          if (obj === null) {
            return false;
          }
          if (typeof obj !== "object" && typeof obj !== "function") {
            return false;
          }
          return true;
        }
        get key() {
          return this.key_;
        }
        get presetKey() {
          return this.presetKey_;
        }
        read() {
          return this.obj_[this.key_];
        }
        write(value) {
          this.obj_[this.key_] = value;
        }
        writeProperty(name, value) {
          const valueObj = this.read();
          if (!BindingTarget.isBindable(valueObj)) {
            throw TpError.notBindable();
          }
          if (!(name in valueObj)) {
            throw TpError.propertyNotFound(name);
          }
          valueObj[name] = value;
        }
      }
      class ButtonApi extends BladeApi {
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get title() {
          var _a2;
          return (_a2 = this.controller_.valueController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
        }
        set title(title) {
          this.controller_.valueController.props.set("title", title);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          const emitter = this.controller_.valueController.emitter;
          emitter.on(eventName, () => {
            bh(new TpEvent(this));
          });
          return this;
        }
      }
      class Emitter {
        constructor() {
          this.observers_ = {};
        }
        on(eventName, handler) {
          let observers = this.observers_[eventName];
          if (!observers) {
            observers = this.observers_[eventName] = [];
          }
          observers.push({
            handler
          });
          return this;
        }
        off(eventName, handler) {
          const observers = this.observers_[eventName];
          if (observers) {
            this.observers_[eventName] = observers.filter((observer) => {
              return observer.handler !== handler;
            });
          }
          return this;
        }
        emit(eventName, event) {
          const observers = this.observers_[eventName];
          if (!observers) {
            return;
          }
          observers.forEach((observer) => {
            observer.handler(event);
          });
        }
      }
      const PREFIX = "tp";
      function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
          return [
            PREFIX,
            "-",
            viewName,
            "v",
            opt_elementName ? `_${opt_elementName}` : "",
            opt_modifier ? `-${opt_modifier}` : ""
          ].join("");
        };
        return fn;
      }
      function compose(h1, h2) {
        return (input) => h2(h1(input));
      }
      function extractValue(ev) {
        return ev.rawValue;
      }
      function bindValue(value, applyValue) {
        value.emitter.on("change", compose(extractValue, applyValue));
        applyValue(value.rawValue);
      }
      function bindValueMap(valueMap, key2, applyValue) {
        bindValue(valueMap.value(key2), applyValue);
      }
      function applyClass(elem, className2, active) {
        if (active) {
          elem.classList.add(className2);
        } else {
          elem.classList.remove(className2);
        }
      }
      function valueToClassName(elem, className2) {
        return (value) => {
          applyClass(elem, className2, value);
        };
      }
      function bindValueToTextContent(value, elem) {
        bindValue(value, (text) => {
          elem.textContent = text !== null && text !== void 0 ? text : "";
        });
      }
      const className$q = ClassName("btn");
      class ButtonView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$q());
          config.viewProps.bindClassModifiers(this.element);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$q("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$q("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
        }
      }
      class ButtonController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new ButtonView(doc, {
            props: this.props,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class BoundValue {
        constructor(initialValue, config) {
          var _a2;
          this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
          this.equals_ = (_a2 = config === null || config === void 0 ? void 0 : config.equals) !== null && _a2 !== void 0 ? _a2 : (v12, v22) => v12 === v22;
          this.emitter = new Emitter();
          this.rawValue_ = initialValue;
        }
        get constraint() {
          return this.constraint_;
        }
        get rawValue() {
          return this.rawValue_;
        }
        set rawValue(rawValue) {
          this.setRawValue(rawValue, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(rawValue, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
          const prevValue = this.rawValue_;
          const changed = !this.equals_(prevValue, constrainedValue);
          if (!changed && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.rawValue_ = constrainedValue;
          this.emitter.emit("change", {
            options: opts,
            previousRawValue: prevValue,
            rawValue: constrainedValue,
            sender: this
          });
        }
      }
      class PrimitiveValue {
        constructor(initialValue) {
          this.emitter = new Emitter();
          this.value_ = initialValue;
        }
        get rawValue() {
          return this.value_;
        }
        set rawValue(value) {
          this.setRawValue(value, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(value, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          const prevValue = this.value_;
          if (prevValue === value && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.value_ = value;
          this.emitter.emit("change", {
            options: opts,
            previousRawValue: prevValue,
            rawValue: this.value_,
            sender: this
          });
        }
      }
      function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals2 = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals2) {
          return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
      }
      class ValueMap {
        constructor(valueMap) {
          this.emitter = new Emitter();
          this.valMap_ = valueMap;
          for (const key2 in this.valMap_) {
            const v4 = this.valMap_[key2];
            v4.emitter.on("change", () => {
              this.emitter.emit("change", {
                key: key2,
                sender: this
              });
            });
          }
        }
        static createCore(initialValue) {
          const keys = Object.keys(initialValue);
          return keys.reduce((o, key2) => {
            return Object.assign(o, {
              [key2]: createValue(initialValue[key2])
            });
          }, {});
        }
        static fromObject(initialValue) {
          const core = this.createCore(initialValue);
          return new ValueMap(core);
        }
        get(key2) {
          return this.valMap_[key2].rawValue;
        }
        set(key2, value) {
          this.valMap_[key2].rawValue = value;
        }
        value(key2) {
          return this.valMap_[key2];
        }
      }
      function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key2) => {
          if (tmp === void 0) {
            return void 0;
          }
          const parser = keyToParserMap[key2];
          const result2 = parser(value[key2]);
          return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key2]: result2.value }) : void 0;
        }, {});
        return forceCast(result);
      }
      function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
          if (tmp === void 0) {
            return void 0;
          }
          const result = parseItem(item);
          if (!result.succeeded || result.value === void 0) {
            return void 0;
          }
          return [...tmp, result.value];
        }, []);
      }
      function isObject(value) {
        if (value === null) {
          return false;
        }
        return typeof value === "object";
      }
      function createParamsParserBuilder(parse) {
        return (optional) => (v4) => {
          if (!optional && v4 === void 0) {
            return {
              succeeded: false,
              value: void 0
            };
          }
          if (optional && v4 === void 0) {
            return {
              succeeded: true,
              value: void 0
            };
          }
          const result = parse(v4);
          return result !== void 0 ? {
            succeeded: true,
            value: result
          } : {
            succeeded: false,
            value: void 0
          };
        };
      }
      function createParamsParserBuilders(optional) {
        return {
          custom: (parse) => createParamsParserBuilder(parse)(optional),
          boolean: createParamsParserBuilder((v4) => typeof v4 === "boolean" ? v4 : void 0)(optional),
          number: createParamsParserBuilder((v4) => typeof v4 === "number" ? v4 : void 0)(optional),
          string: createParamsParserBuilder((v4) => typeof v4 === "string" ? v4 : void 0)(optional),
          function: createParamsParserBuilder((v4) => typeof v4 === "function" ? v4 : void 0)(optional),
          constant: (value) => createParamsParserBuilder((v4) => v4 === value ? value : void 0)(optional),
          raw: createParamsParserBuilder((v4) => v4)(optional),
          object: (keyToParserMap) => createParamsParserBuilder((v4) => {
            if (!isObject(v4)) {
              return void 0;
            }
            return parseObject(v4, keyToParserMap);
          })(optional),
          array: (itemParser) => createParamsParserBuilder((v4) => {
            if (!Array.isArray(v4)) {
              return void 0;
            }
            return parseArray(v4, itemParser);
          })(optional)
        };
      }
      const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };
      function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : void 0;
      }
      function warnMissing(info) {
        console.warn([
          `Missing '${info.key}' of ${info.target} in ${info.place}.`,
          "Please rebuild plugins with the latest core package."
        ].join(" "));
      }
      function disposeElement(elem) {
        if (elem && elem.parentElement) {
          elem.parentElement.removeChild(elem);
        }
        return null;
      }
      class ReadonlyValue {
        constructor(value) {
          this.value_ = value;
        }
        static create(value) {
          return [
            new ReadonlyValue(value),
            (rawValue, options) => {
              value.setRawValue(rawValue, options);
            }
          ];
        }
        get emitter() {
          return this.value_.emitter;
        }
        get rawValue() {
          return this.value_.rawValue;
        }
      }
      const className$p = ClassName("");
      function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$p(void 0, modifier));
      }
      class ViewProps extends ValueMap {
        constructor(valueMap) {
          var _a2;
          super(valueMap);
          this.onDisabledChange_ = this.onDisabledChange_.bind(this);
          this.onParentChange_ = this.onParentChange_.bind(this);
          this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this);
          [this.globalDisabled_, this.setGlobalDisabled_] = ReadonlyValue.create(createValue(this.getGlobalDisabled_()));
          this.value("disabled").emitter.on("change", this.onDisabledChange_);
          this.value("parent").emitter.on("change", this.onParentChange_);
          (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
        }
        static create(opt_initialValue) {
          var _a2, _b2, _c;
          const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
          return new ViewProps(ValueMap.createCore({
            disabled: (_a2 = initialValue.disabled) !== null && _a2 !== void 0 ? _a2 : false,
            disposed: false,
            hidden: (_b2 = initialValue.hidden) !== null && _b2 !== void 0 ? _b2 : false,
            parent: (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null
          }));
        }
        get globalDisabled() {
          return this.globalDisabled_;
        }
        bindClassModifiers(elem) {
          bindValue(this.globalDisabled_, valueToModifier(elem, "disabled"));
          bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
        }
        bindDisabled(target) {
          bindValue(this.globalDisabled_, (disabled) => {
            target.disabled = disabled;
          });
        }
        bindTabIndex(elem) {
          bindValue(this.globalDisabled_, (disabled) => {
            elem.tabIndex = disabled ? -1 : 0;
          });
        }
        handleDispose(callback) {
          this.value("disposed").emitter.on("change", (disposed) => {
            if (disposed) {
              callback();
            }
          });
        }
        getGlobalDisabled_() {
          const parent = this.get("parent");
          const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
          return parentDisabled || this.get("disabled");
        }
        updateGlobalDisabled_() {
          this.setGlobalDisabled_(this.getGlobalDisabled_());
        }
        onDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentGlobalDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentChange_(ev) {
          var _a2;
          const prevParent = ev.previousRawValue;
          prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_);
          (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
          this.updateGlobalDisabled_();
        }
      }
      function getAllBladePositions() {
        return ["veryfirst", "first", "last", "verylast"];
      }
      const className$o = ClassName("");
      const POS_TO_CLASS_NAME_MAP = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
      };
      class BladeController {
        constructor(config) {
          this.parent_ = null;
          this.blade = config.blade;
          this.view = config.view;
          this.viewProps = config.viewProps;
          const elem = this.view.element;
          this.blade.value("positions").emitter.on("change", () => {
            getAllBladePositions().forEach((pos) => {
              elem.classList.remove(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
            this.blade.get("positions").forEach((pos) => {
              elem.classList.add(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
          });
          this.viewProps.handleDispose(() => {
            disposeElement(elem);
          });
        }
        get parent() {
          return this.parent_;
        }
        set parent(parent) {
          this.parent_ = parent;
          if (!("parent" in this.viewProps.valMap_)) {
            warnMissing({
              key: "parent",
              target: ViewProps.name,
              place: "BladeController.parent"
            });
            return;
          }
          this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
        }
      }
      const SVG_NS = "http://www.w3.org/2000/svg";
      function forceReflow(element2) {
        element2.offsetHeight;
      }
      function disableTransitionTemporarily(element2, callback) {
        const t2 = element2.style.transition;
        element2.style.transition = "none";
        callback();
        element2.style.transition = t2;
      }
      function supportsTouch(doc) {
        return doc.ontouchstart !== void 0;
      }
      function getGlobalObject() {
        return globalThis;
      }
      function getWindowDocument() {
        const globalObj = forceCast(getGlobalObject());
        return globalObj.document;
      }
      function getCanvasContext(canvasElement) {
        const win = canvasElement.ownerDocument.defaultView;
        if (!win) {
          return null;
        }
        const isBrowser = "document" in win;
        return isBrowser ? canvasElement.getContext("2d", {
          willReadFrequently: true
        }) : null;
      }
      const ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };
      function createSvgIconElement(document2, iconId) {
        const elem = document2.createElementNS(SVG_NS, "svg");
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
      }
      function insertElementAt(parentElement, element2, index) {
        parentElement.insertBefore(element2, parentElement.children[index]);
      }
      function removeElement(element2) {
        if (element2.parentElement) {
          element2.parentElement.removeChild(element2);
        }
      }
      function removeChildElements(element2) {
        while (element2.children.length > 0) {
          element2.removeChild(element2.children[0]);
        }
      }
      function removeChildNodes(element2) {
        while (element2.childNodes.length > 0) {
          element2.removeChild(element2.childNodes[0]);
        }
      }
      function findNextTarget(ev) {
        if (ev.relatedTarget) {
          return forceCast(ev.relatedTarget);
        }
        if ("explicitOriginalTarget" in ev) {
          return ev.explicitOriginalTarget;
        }
        return null;
      }
      const className$n = ClassName("lbl");
      function createLabelNode(doc, label) {
        const frag = doc.createDocumentFragment();
        const lineNodes = label.split("\n").map((line) => {
          return doc.createTextNode(line);
        });
        lineNodes.forEach((lineNode, index) => {
          if (index > 0) {
            frag.appendChild(doc.createElement("br"));
          }
          frag.appendChild(lineNode);
        });
        return frag;
      }
      class LabelView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$n());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("div");
          labelElem.classList.add(className$n("l"));
          bindValueMap(config.props, "label", (value) => {
            if (isEmpty(value)) {
              this.element.classList.add(className$n(void 0, "nol"));
            } else {
              this.element.classList.remove(className$n(void 0, "nol"));
              removeChildNodes(labelElem);
              labelElem.appendChild(createLabelNode(doc, value));
            }
          });
          this.element.appendChild(labelElem);
          this.labelElement = labelElem;
          const valueElem = doc.createElement("div");
          valueElem.classList.add(className$n("v"));
          this.element.appendChild(valueElem);
          this.valueElement = valueElem;
        }
      }
      class LabelController extends BladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      const ButtonBladePlugin = {
        id: "button",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant("button"),
            label: p.optional.string
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new ButtonController(args.document, {
              props: ValueMap.fromObject({
                title: args.params.title
              }),
              viewProps: args.viewProps
            })
          });
        },
        api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof ButtonController)) {
            return null;
          }
          return new ButtonApi(args.controller);
        }
      };
      class ValueBladeController extends BladeController {
        constructor(config) {
          super(config);
          this.value = config.value;
        }
      }
      function createBlade() {
        return new ValueMap({
          positions: createValue([], {
            equals: deepEqualsArray
          })
        });
      }
      class Foldable extends ValueMap {
        constructor(valueMap) {
          super(valueMap);
        }
        static create(expanded) {
          const coreObj = {
            completed: true,
            expanded,
            expandedHeight: null,
            shouldFixHeight: false,
            temporaryExpanded: null
          };
          const core = ValueMap.createCore(coreObj);
          return new Foldable(core);
        }
        get styleExpanded() {
          var _a2;
          return (_a2 = this.get("temporaryExpanded")) !== null && _a2 !== void 0 ? _a2 : this.get("expanded");
        }
        get styleHeight() {
          if (!this.styleExpanded) {
            return "0";
          }
          const exHeight = this.get("expandedHeight");
          if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
            return `${exHeight}px`;
          }
          return "auto";
        }
        bindExpandedClass(elem, expandedClassName) {
          const onExpand = () => {
            const expanded = this.styleExpanded;
            if (expanded) {
              elem.classList.add(expandedClassName);
            } else {
              elem.classList.remove(expandedClassName);
            }
          };
          bindValueMap(this, "expanded", onExpand);
          bindValueMap(this, "temporaryExpanded", onExpand);
        }
        cleanUpTransition() {
          this.set("shouldFixHeight", false);
          this.set("expandedHeight", null);
          this.set("completed", true);
        }
      }
      function computeExpandedFolderHeight(folder, containerElement) {
        let height = 0;
        disableTransitionTemporarily(containerElement, () => {
          folder.set("expandedHeight", null);
          folder.set("temporaryExpanded", true);
          forceReflow(containerElement);
          height = containerElement.clientHeight;
          folder.set("temporaryExpanded", null);
          forceReflow(containerElement);
        });
        return height;
      }
      function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
      }
      function bindFoldable(foldable, elem) {
        foldable.value("expanded").emitter.on("beforechange", () => {
          foldable.set("completed", false);
          if (isEmpty(foldable.get("expandedHeight"))) {
            const h = computeExpandedFolderHeight(foldable, elem);
            if (h > 0) {
              foldable.set("expandedHeight", h);
            }
          }
          foldable.set("shouldFixHeight", true);
          forceReflow(elem);
        });
        foldable.emitter.on("change", () => {
          applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener("transitionend", (ev) => {
          if (ev.propertyName !== "height") {
            return;
          }
          foldable.cleanUpTransition();
        });
      }
      class RackLikeApi extends BladeApi {
        constructor(controller, rackApi) {
          super(controller);
          this.rackApi_ = rackApi;
        }
      }
      function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
      }
      function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
      }
      function addSeparatorAsBlade(api, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
      }
      function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
      }
      class NestedOrderedSet {
        constructor(extract) {
          this.emitter = new Emitter();
          this.items_ = [];
          this.cache_ = /* @__PURE__ */ new Set();
          this.onSubListAdd_ = this.onSubListAdd_.bind(this);
          this.onSubListRemove_ = this.onSubListRemove_.bind(this);
          this.extract_ = extract;
        }
        get items() {
          return this.items_;
        }
        allItems() {
          return Array.from(this.cache_);
        }
        find(callback) {
          for (const item of this.allItems()) {
            if (callback(item)) {
              return item;
            }
          }
          return null;
        }
        includes(item) {
          return this.cache_.has(item);
        }
        add(item, opt_index) {
          if (this.includes(item)) {
            throw TpError.shouldNeverHappen();
          }
          const index = opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index, 0, item);
          this.cache_.add(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.on("add", this.onSubListAdd_);
            subList.emitter.on("remove", this.onSubListRemove_);
            subList.allItems().forEach((item2) => {
              this.cache_.add(item2);
            });
          }
          this.emitter.emit("add", {
            index,
            item,
            root: this,
            target: this
          });
        }
        remove(item) {
          const index = this.items_.indexOf(item);
          if (index < 0) {
            return;
          }
          this.items_.splice(index, 1);
          this.cache_.delete(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.off("add", this.onSubListAdd_);
            subList.emitter.off("remove", this.onSubListRemove_);
          }
          this.emitter.emit("remove", {
            index,
            item,
            root: this,
            target: this
          });
        }
        onSubListAdd_(ev) {
          this.cache_.add(ev.item);
          this.emitter.emit("add", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
        onSubListRemove_(ev) {
          this.cache_.delete(ev.item);
          this.emitter.emit("remove", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
      }
      class InputBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingChange_ = this.onBindingChange_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("change", this.onBindingChange_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingChange_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
          });
        }
      }
      class InputBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
        }
      }
      class MonitorBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingUpdate_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
          });
        }
      }
      class MonitorBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
          this.viewProps.bindDisabled(this.binding.ticker);
          this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
        }
      }
      function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
          return api["apiSet_"];
        }
        if (api instanceof RackLikeApi) {
          return api["rackApi_"]["apiSet_"];
        }
        return null;
      }
      function getApiByController(apiSet, controller) {
        const api = apiSet.find((api2) => api2.controller_ === controller);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        return api;
      }
      function createBindingTarget(obj, key2, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
          throw TpError.notBindable();
        }
        return new BindingTarget(obj, key2, opt_id);
      }
      class RackApi extends BladeApi {
        constructor(controller, pool) {
          super(controller);
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          this.onRackInputChange_ = this.onRackInputChange_.bind(this);
          this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
          this.pool_ = pool;
          const rack = this.controller_.rack;
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          rack.emitter.on("inputchange", this.onRackInputChange_);
          rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
          rack.children.forEach((bc) => {
            this.setUpApi_(bc);
          });
        }
        get children() {
          return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
        }
        addInput(object, key2, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createInput(doc, createBindingTarget(object, key2, params.presetKey), params);
          const api = new InputBindingApi(bc);
          return this.add(api, params.index);
        }
        addMonitor(object, key2, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key2), params);
          const api = new MonitorBindingApi(bc);
          return forceCast(this.add(api, params.index));
        }
        addFolder(params) {
          return addFolderAsBlade(this, params);
        }
        addButton(params) {
          return addButtonAsBlade(this, params);
        }
        addSeparator(opt_params) {
          return addSeparatorAsBlade(this, opt_params);
        }
        addTab(params) {
          return addTabAsBlade(this, params);
        }
        add(api, opt_index) {
          this.controller_.rack.add(api.controller_, opt_index);
          const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
          if (gapi) {
            this.apiSet_.remove(gapi);
          }
          this.apiSet_.add(api);
          return api;
        }
        remove(api) {
          this.controller_.rack.remove(api.controller_);
        }
        addBlade(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createBlade(doc, params);
          const api = this.pool_.createBladeApi(bc);
          return this.add(api, params.index);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpApi_(bc) {
          const api = this.apiSet_.find((api2) => api2.controller_ === bc);
          if (!api) {
            this.apiSet_.add(this.pool_.createBladeApi(bc));
          }
        }
        onRackAdd_(ev) {
          this.setUpApi_(ev.bladeController);
        }
        onRackRemove_(ev) {
          if (ev.isRoot) {
            const api = getApiByController(this.apiSet_, ev.bladeController);
            this.apiSet_.remove(api);
          }
        }
        onRackInputChange_(ev) {
          const bc = ev.bladeController;
          if (bc instanceof InputBindingController) {
            const api = getApiByController(this.apiSet_, bc);
            const binding = bc.binding;
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
            });
          } else if (bc instanceof ValueBladeController) {
            const api = getApiByController(this.apiSet_, bc);
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
            });
          }
        }
        onRackMonitorUpdate_(ev) {
          if (!(ev.bladeController instanceof MonitorBindingController)) {
            throw TpError.shouldNeverHappen();
          }
          const api = getApiByController(this.apiSet_, ev.bladeController);
          const binding = ev.bladeController.binding;
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
          });
        }
      }
      class FolderApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.emitter_ = new Emitter();
          this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
            this.emitter_.emit("fold", {
              event: new TpFoldEvent(this, ev.sender.rawValue)
            });
          });
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
        }
        get expanded() {
          return this.controller_.foldable.get("expanded");
        }
        set expanded(expanded) {
          this.controller_.foldable.set("expanded", expanded);
        }
        get title() {
          return this.controller_.props.get("title");
        }
        set title(title) {
          this.controller_.props.set("title", title);
        }
        get children() {
          return this.rackApi_.children;
        }
        addInput(object, key2, opt_params) {
          return this.rackApi_.addInput(object, key2, opt_params);
        }
        addMonitor(object, key2, opt_params) {
          return this.rackApi_.addMonitor(object, key2, opt_params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          return this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class RackLikeController extends BladeController {
        constructor(config) {
          super({
            blade: config.blade,
            view: config.view,
            viewProps: config.rackController.viewProps
          });
          this.rackController = config.rackController;
        }
      }
      class PlainView {
        constructor(doc, config) {
          const className2 = ClassName(config.viewName);
          this.element = doc.createElement("div");
          this.element.classList.add(className2());
          config.viewProps.bindClassModifiers(this.element);
        }
      }
      function findInputBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof InputBindingController && bc.binding === b) {
            return bc;
          }
        }
        return null;
      }
      function findMonitorBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof MonitorBindingController && bc.binding === b) {
            return bc;
          }
        }
        return null;
      }
      function findValueBladeController(bcs, v4) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof ValueBladeController && bc.value === v4) {
            return bc;
          }
        }
        return null;
      }
      function findSubRack(bc) {
        if (bc instanceof RackController) {
          return bc.rack;
        }
        if (bc instanceof RackLikeController) {
          return bc.rackController.rack;
        }
        return null;
      }
      function findSubBladeControllerSet(bc) {
        const rack = findSubRack(bc);
        return rack ? rack["bcSet_"] : null;
      }
      class BladeRack {
        constructor(config) {
          var _a2, _b2;
          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
          this.onSetAdd_ = this.onSetAdd_.bind(this);
          this.onSetRemove_ = this.onSetRemove_.bind(this);
          this.onChildDispose_ = this.onChildDispose_.bind(this);
          this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
          this.onChildInputChange_ = this.onChildInputChange_.bind(this);
          this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
          this.onChildValueChange_ = this.onChildValueChange_.bind(this);
          this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
          this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
          this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
          this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
          this.emitter = new Emitter();
          this.blade_ = (_a2 = config.blade) !== null && _a2 !== void 0 ? _a2 : null;
          (_b2 = this.blade_) === null || _b2 === void 0 ? void 0 : _b2.value("positions").emitter.on("change", this.onBladePositionsChange_);
          this.viewProps = config.viewProps;
          this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
          this.bcSet_.emitter.on("add", this.onSetAdd_);
          this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }
        get children() {
          return this.bcSet_.items;
        }
        add(bc, opt_index) {
          var _a2;
          (_a2 = bc.parent) === null || _a2 === void 0 ? void 0 : _a2.remove(bc);
          if (isPropertyWritable(bc, "parent")) {
            bc.parent = this;
          } else {
            bc["parent_"] = this;
            warnMissing({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.add"
            });
          }
          this.bcSet_.add(bc, opt_index);
        }
        remove(bc) {
          if (isPropertyWritable(bc, "parent")) {
            bc.parent = null;
          } else {
            bc["parent_"] = null;
            warnMissing({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.remove"
            });
          }
          this.bcSet_.remove(bc);
        }
        find(controllerClass) {
          return forceCast(this.bcSet_.allItems().filter((bc) => {
            return bc instanceof controllerClass;
          }));
        }
        onSetAdd_(ev) {
          this.updatePositions_();
          const isRoot2 = ev.target === ev.root;
          this.emitter.emit("add", {
            bladeController: ev.item,
            index: ev.index,
            isRoot: isRoot2,
            sender: this
          });
          if (!isRoot2) {
            return;
          }
          const bc = ev.item;
          bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
          bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
          bc.viewProps.handleDispose(this.onChildDispose_);
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.on("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.on("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.on("layout", this.onDescendantLayout_);
              emitter.on("inputchange", this.onDescendantInputChange_);
              emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        onSetRemove_(ev) {
          this.updatePositions_();
          const isRoot2 = ev.target === ev.root;
          this.emitter.emit("remove", {
            bladeController: ev.item,
            isRoot: isRoot2,
            sender: this
          });
          if (!isRoot2) {
            return;
          }
          const bc = ev.item;
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.off("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.off("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.off("layout", this.onDescendantLayout_);
              emitter.off("inputchange", this.onDescendantInputChange_);
              emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        updatePositions_() {
          const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
          const firstVisibleItem = visibleItems[0];
          const lastVisibleItem = visibleItems[visibleItems.length - 1];
          this.bcSet_.items.forEach((bc) => {
            const ps = [];
            if (bc === firstVisibleItem) {
              ps.push("first");
              if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
                ps.push("veryfirst");
              }
            }
            if (bc === lastVisibleItem) {
              ps.push("last");
              if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
                ps.push("verylast");
              }
            }
            bc.blade.set("positions", ps);
          });
        }
        onChildPositionsChange_() {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildViewPropsChange_(_ev) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildDispose_() {
          const disposedUcs = this.bcSet_.items.filter((bc) => {
            return bc.viewProps.get("disposed");
          });
          disposedUcs.forEach((bc) => {
            this.bcSet_.remove(bc);
          });
        }
        onChildInputChange_(ev) {
          const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onChildMonitorUpdate_(ev) {
          const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("monitorupdate", {
            bladeController: bc,
            sender: this
          });
        }
        onChildValueChange_(ev) {
          const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onDescendantLayout_(_) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onDescendantInputChange_(ev) {
          this.emitter.emit("inputchange", {
            bladeController: ev.bladeController,
            options: ev.options,
            sender: this
          });
        }
        onDescendantMonitorUpdate_(ev) {
          this.emitter.emit("monitorupdate", {
            bladeController: ev.bladeController,
            sender: this
          });
        }
        onBladePositionsChange_() {
          this.updatePositions_();
        }
      }
      class RackController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
            viewName: "brk",
            viewProps: config.viewProps
          }) }));
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          const rack = new BladeRack({
            blade: config.root ? void 0 : config.blade,
            viewProps: config.viewProps
          });
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          this.rack = rack;
          this.viewProps.handleDispose(() => {
            for (let i = this.rack.children.length - 1; i >= 0; i--) {
              const bc = this.rack.children[i];
              bc.viewProps.set("disposed", true);
            }
          });
        }
        onRackAdd_(ev) {
          if (!ev.isRoot) {
            return;
          }
          insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
        }
        onRackRemove_(ev) {
          if (!ev.isRoot) {
            return;
          }
          removeElement(ev.bladeController.view.element);
        }
      }
      const bladeContainerClassName = ClassName("cnt");
      class FolderView {
        constructor(doc, config) {
          var _a2;
          this.className_ = ClassName((_a2 = config.viewName) !== null && _a2 !== void 0 ? _a2 : "fld");
          this.element = doc.createElement("div");
          this.element.classList.add(this.className_(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          this.foldable_ = config.foldable;
          this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
          bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(this.className_("b"));
          bindValueMap(config.props, "title", (title) => {
            if (isEmpty(title)) {
              this.element.classList.add(this.className_(void 0, "not"));
            } else {
              this.element.classList.remove(this.className_(void 0, "not"));
            }
          });
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const indentElem = doc.createElement("div");
          indentElem.classList.add(this.className_("i"));
          this.element.appendChild(indentElem);
          const titleElem = doc.createElement("div");
          titleElem.classList.add(this.className_("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(this.className_("m"));
          this.buttonElement.appendChild(markElem);
          const containerElem = config.containerElement;
          containerElem.classList.add(this.className_("c"));
          this.element.appendChild(containerElem);
          this.containerElement = containerElem;
        }
      }
      class FolderController extends RackLikeController {
        constructor(doc, config) {
          var _a2;
          const foldable = Foldable.create((_a2 = config.expanded) !== null && _a2 !== void 0 ? _a2 : true);
          const rc = new RackController(doc, {
            blade: config.blade,
            root: config.root,
            viewProps: config.viewProps
          });
          super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
            containerElement: rc.view.element,
            foldable,
            props: config.props,
            viewName: config.root ? "rot" : void 0,
            viewProps: config.viewProps
          }) }));
          this.onTitleClick_ = this.onTitleClick_.bind(this);
          this.props = config.props;
          this.foldable = foldable;
          bindFoldable(this.foldable, this.view.containerElement);
          this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          });
          this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          });
          this.view.buttonElement.addEventListener("click", this.onTitleClick_);
        }
        get document() {
          return this.view.element.ownerDocument;
        }
        onTitleClick_() {
          this.foldable.set("expanded", !this.foldable.get("expanded"));
        }
      }
      const FolderBladePlugin = {
        id: "folder",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant("folder"),
            expanded: p.optional.boolean
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new FolderController(args.document, {
            blade: args.blade,
            expanded: args.params.expanded,
            props: ValueMap.fromObject({
              title: args.params.title
            }),
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof FolderController)) {
            return null;
          }
          return new FolderApi(args.controller, args.pool);
        }
      };
      class LabeledValueController extends ValueBladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      class SeparatorApi extends BladeApi {
      }
      const className$m = ClassName("spr");
      class SeparatorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$m());
          config.viewProps.bindClassModifiers(this.element);
          const hrElem = doc.createElement("hr");
          hrElem.classList.add(className$m("r"));
          this.element.appendChild(hrElem);
        }
      }
      class SeparatorController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
            viewProps: config.viewProps
          }) }));
        }
      }
      const SeparatorBladePlugin = {
        id: "separator",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            view: p.required.constant("separator")
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new SeparatorController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof SeparatorController)) {
            return null;
          }
          return new SeparatorApi(args.controller);
        }
      };
      const className$l = ClassName("tbi");
      class TabItemView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$l());
          config.viewProps.bindClassModifiers(this.element);
          bindValueMap(config.props, "selected", (selected) => {
            if (selected) {
              this.element.classList.add(className$l(void 0, "sel"));
            } else {
              this.element.classList.remove(className$l(void 0, "sel"));
            }
          });
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$l("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$l("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
        }
      }
      class TabItemController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new TabItemView(doc, {
            props: config.props,
            viewProps: config.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class TabPageController {
        constructor(doc, config) {
          this.onItemClick_ = this.onItemClick_.bind(this);
          this.ic_ = new TabItemController(doc, {
            props: config.itemProps,
            viewProps: ViewProps.create()
          });
          this.ic_.emitter.on("click", this.onItemClick_);
          this.cc_ = new RackController(doc, {
            blade: createBlade(),
            viewProps: ViewProps.create()
          });
          this.props = config.props;
          bindValueMap(this.props, "selected", (selected) => {
            this.itemController.props.set("selected", selected);
            this.contentController.viewProps.set("hidden", !selected);
          });
        }
        get itemController() {
          return this.ic_;
        }
        get contentController() {
          return this.cc_;
        }
        onItemClick_() {
          this.props.set("selected", true);
        }
      }
      class TabPageApi {
        constructor(controller, contentRackApi) {
          this.controller_ = controller;
          this.rackApi_ = contentRackApi;
        }
        get title() {
          var _a2;
          return (_a2 = this.controller_.itemController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
        }
        set title(title) {
          this.controller_.itemController.props.set("title", title);
        }
        get selected() {
          return this.controller_.props.get("selected");
        }
        set selected(selected) {
          this.controller_.props.set("selected", selected);
        }
        get children() {
          return this.rackApi_.children;
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addInput(object, key2, opt_params) {
          return this.rackApi_.addInput(object, key2, opt_params);
        }
        addMonitor(object, key2, opt_params) {
          return this.rackApi_.addMonitor(object, key2, opt_params);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
      }
      class TabApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.onSelect_ = this.onSelect_.bind(this);
          this.emitter_ = new Emitter();
          this.pageApiMap_ = /* @__PURE__ */ new Map();
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
          this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_);
          this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
          this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
          this.controller_.pageSet.items.forEach((pc) => {
            this.setUpPageApi_(pc);
          });
        }
        get pages() {
          return this.controller_.pageSet.items.map((pc) => {
            const api = this.pageApiMap_.get(pc);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          });
        }
        addPage(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const pc = new TabPageController(doc, {
            itemProps: ValueMap.fromObject({
              selected: false,
              title: params.title
            }),
            props: ValueMap.fromObject({
              selected: false
            })
          });
          this.controller_.add(pc, params.index);
          const api = this.pageApiMap_.get(pc);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
        removePage(index) {
          this.controller_.remove(index);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpPageApi_(pc) {
          const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
          if (!rackApi) {
            throw TpError.shouldNeverHappen();
          }
          const api = new TabPageApi(pc, rackApi);
          this.pageApiMap_.set(pc, api);
        }
        onPageAdd_(ev) {
          this.setUpPageApi_(ev.item);
        }
        onPageRemove_(ev) {
          const api = this.pageApiMap_.get(ev.item);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          this.pageApiMap_.delete(ev.item);
        }
        onSelect_(ev) {
          this.emitter_.emit("select", {
            event: new TpTabSelectEvent(this, ev.rawValue)
          });
        }
      }
      const INDEX_NOT_SELECTED = -1;
      class Tab {
        constructor() {
          this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
          this.empty = createValue(true);
          this.selectedIndex = createValue(INDEX_NOT_SELECTED);
          this.items_ = [];
        }
        add(item, opt_index) {
          const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index, 0, item);
          item.emitter.on("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        remove(item) {
          const index = this.items_.indexOf(item);
          if (index < 0) {
            return;
          }
          this.items_.splice(index, 1);
          item.emitter.off("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        keepSelection_() {
          if (this.items_.length === 0) {
            this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
            this.empty.rawValue = true;
            return;
          }
          const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
          if (firstSelIndex < 0) {
            this.items_.forEach((s, i) => {
              s.rawValue = i === 0;
            });
            this.selectedIndex.rawValue = 0;
          } else {
            this.items_.forEach((s, i) => {
              s.rawValue = i === firstSelIndex;
            });
            this.selectedIndex.rawValue = firstSelIndex;
          }
          this.empty.rawValue = false;
        }
        onItemSelectedChange_(ev) {
          if (ev.rawValue) {
            const index = this.items_.findIndex((s) => s === ev.sender);
            this.items_.forEach((s, i) => {
              s.rawValue = i === index;
            });
            this.selectedIndex.rawValue = index;
          } else {
            this.keepSelection_();
          }
        }
      }
      const className$k = ClassName("tab");
      class TabView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$k(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.empty, valueToClassName(this.element, className$k(void 0, "nop")));
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$k("t"));
          this.element.appendChild(titleElem);
          this.itemsElement = titleElem;
          const indentElem = doc.createElement("div");
          indentElem.classList.add(className$k("i"));
          this.element.appendChild(indentElem);
          const contentsElem = config.contentsElement;
          contentsElem.classList.add(className$k("c"));
          this.element.appendChild(contentsElem);
          this.contentsElement = contentsElem;
        }
      }
      class TabController extends RackLikeController {
        constructor(doc, config) {
          const cr = new RackController(doc, {
            blade: config.blade,
            viewProps: config.viewProps
          });
          const tab = new Tab();
          super({
            blade: config.blade,
            rackController: cr,
            view: new TabView(doc, {
              contentsElement: cr.view.element,
              empty: tab.empty,
              viewProps: config.viewProps
            })
          });
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.pageSet_ = new NestedOrderedSet(() => null);
          this.pageSet_.emitter.on("add", this.onPageAdd_);
          this.pageSet_.emitter.on("remove", this.onPageRemove_);
          this.tab = tab;
        }
        get pageSet() {
          return this.pageSet_;
        }
        add(pc, opt_index) {
          this.pageSet_.add(pc, opt_index);
        }
        remove(index) {
          this.pageSet_.remove(this.pageSet_.items[index]);
        }
        onPageAdd_(ev) {
          const pc = ev.item;
          insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
          pc.itemController.viewProps.set("parent", this.viewProps);
          this.rackController.rack.add(pc.contentController, ev.index);
          this.tab.add(pc.props.value("selected"));
        }
        onPageRemove_(ev) {
          const pc = ev.item;
          removeElement(pc.itemController.view.element);
          pc.itemController.viewProps.set("parent", null);
          this.rackController.rack.remove(pc.contentController);
          this.tab.remove(pc.props.value("selected"));
        }
      }
      const TabBladePlugin = {
        id: "tab",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            pages: p.required.array(p.required.object({ title: p.required.string })),
            view: p.required.constant("tab")
          });
          if (!result || result.pages.length === 0) {
            return null;
          }
          return { params: result };
        },
        controller(args) {
          const c = new TabController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
          args.params.pages.forEach((p) => {
            const pc = new TabPageController(args.document, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: p.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            c.add(pc);
          });
          return c;
        },
        api(args) {
          if (!(args.controller instanceof TabController)) {
            return null;
          }
          return new TabApi(args.controller, args.pool);
        }
      };
      function createBladeController(plugin, args) {
        const ac = plugin.accept(args.params);
        if (!ac) {
          return null;
        }
        const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
        const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
        return plugin.controller({
          blade: createBlade(),
          document: args.document,
          params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
      }
      class ManualTicker {
        constructor() {
          this.disabled = false;
          this.emitter = new Emitter();
        }
        dispose() {
        }
        tick() {
          if (this.disabled) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class IntervalTicker {
        constructor(doc, interval) {
          this.disabled_ = false;
          this.timerId_ = null;
          this.onTick_ = this.onTick_.bind(this);
          this.doc_ = doc;
          this.emitter = new Emitter();
          this.interval_ = interval;
          this.setTimer_();
        }
        get disabled() {
          return this.disabled_;
        }
        set disabled(inactive) {
          this.disabled_ = inactive;
          if (this.disabled_) {
            this.clearTimer_();
          } else {
            this.setTimer_();
          }
        }
        dispose() {
          this.clearTimer_();
        }
        clearTimer_() {
          if (this.timerId_ === null) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            win.clearInterval(this.timerId_);
          }
          this.timerId_ = null;
        }
        setTimer_() {
          this.clearTimer_();
          if (this.interval_ <= 0) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            this.timerId_ = win.setInterval(this.onTick_, this.interval_);
          }
        }
        onTick_() {
          if (this.disabled_) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class InputBinding {
        constructor(config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.reader = config.reader;
          this.writer = config.writer;
          this.emitter = new Emitter();
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.target = config.target;
          this.read();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue !== void 0) {
            this.value.rawValue = this.reader(targetValue);
          }
        }
        write_(rawValue) {
          this.writer(this.target, rawValue);
        }
        onValueChange_(ev) {
          this.write_(ev.rawValue);
          this.emitter.emit("change", {
            options: ev.options,
            rawValue: ev.rawValue,
            sender: this
          });
        }
      }
      function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
          buffer.push(void 0);
        }
      }
      function initializeBuffer(bufferSize) {
        const buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
      }
      function createTrimmedBuffer(buffer) {
        const index = buffer.indexOf(void 0);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
      }
      function createPushedBuffer(buffer, newValue) {
        const newBuffer = [...createTrimmedBuffer(buffer), newValue];
        if (newBuffer.length > buffer.length) {
          newBuffer.splice(0, newBuffer.length - buffer.length);
        } else {
          fillBuffer(newBuffer, buffer.length);
        }
        return newBuffer;
      }
      class MonitorBinding {
        constructor(config) {
          this.onTick_ = this.onTick_.bind(this);
          this.reader_ = config.reader;
          this.target = config.target;
          this.emitter = new Emitter();
          this.value = config.value;
          this.ticker = config.ticker;
          this.ticker.emitter.on("tick", this.onTick_);
          this.read();
        }
        dispose() {
          this.ticker.dispose();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue === void 0) {
            return;
          }
          const buffer = this.value.rawValue;
          const newValue = this.reader_(targetValue);
          this.value.rawValue = createPushedBuffer(buffer, newValue);
          this.emitter.emit("update", {
            rawValue: newValue,
            sender: this
          });
        }
        onTick_(_) {
          this.read();
        }
      }
      class CompositeConstraint {
        constructor(constraints) {
          this.constraints = constraints;
        }
        constrain(value) {
          return this.constraints.reduce((result, c) => {
            return c.constrain(result);
          }, value);
        }
      }
      function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
          return c;
        }
        if (c instanceof CompositeConstraint) {
          const result = c.constraints.reduce((tmpResult, sc) => {
            if (tmpResult) {
              return tmpResult;
            }
            return sc instanceof constraintClass ? sc : null;
          }, null);
          if (result) {
            return result;
          }
        }
        return null;
      }
      class DefiniteRangeConstraint {
        constructor(config) {
          this.values = ValueMap.fromObject({
            max: config.max,
            min: config.min
          });
        }
        constrain(value) {
          const max2 = this.values.get("max");
          const min = this.values.get("min");
          return Math.min(Math.max(value, min), max2);
        }
      }
      class ListConstraint {
        constructor(options) {
          this.values = ValueMap.fromObject({
            options
          });
        }
        get options() {
          return this.values.get("options");
        }
        constrain(value) {
          const opts = this.values.get("options");
          if (opts.length === 0) {
            return value;
          }
          const matched = opts.filter((item) => {
            return item.value === value;
          }).length > 0;
          return matched ? value : opts[0].value;
        }
      }
      class RangeConstraint {
        constructor(config) {
          this.values = ValueMap.fromObject({
            max: config.max,
            min: config.min
          });
        }
        get maxValue() {
          return this.values.get("max");
        }
        get minValue() {
          return this.values.get("min");
        }
        constrain(value) {
          const max2 = this.values.get("max");
          const min = this.values.get("min");
          let result = value;
          if (!isEmpty(min)) {
            result = Math.max(result, min);
          }
          if (!isEmpty(max2)) {
            result = Math.min(result, max2);
          }
          return result;
        }
      }
      class StepConstraint {
        constructor(step, origin4 = 0) {
          this.step = step;
          this.origin = origin4;
        }
        constrain(value) {
          const o = this.origin % this.step;
          const r = Math.round((value - o) / this.step);
          return o + r * this.step;
        }
      }
      const className$j = ClassName("lst");
      class ListView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.props_ = config.props;
          this.element = doc.createElement("div");
          this.element.classList.add(className$j());
          config.viewProps.bindClassModifiers(this.element);
          const selectElem = doc.createElement("select");
          selectElem.classList.add(className$j("s"));
          config.viewProps.bindDisabled(selectElem);
          this.element.appendChild(selectElem);
          this.selectElement = selectElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(className$j("m"));
          markElem.appendChild(createSvgIconElement(doc, "dropdown"));
          this.element.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value_ = config.value;
          bindValueMap(this.props_, "options", (opts) => {
            removeChildElements(this.selectElement);
            opts.forEach((item) => {
              const optionElem = doc.createElement("option");
              optionElem.textContent = item.text;
              this.selectElement.appendChild(optionElem);
            });
            this.update_();
          });
        }
        update_() {
          const values = this.props_.get("options").map((o) => o.value);
          this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ListController {
        constructor(doc, config) {
          this.onSelectChange_ = this.onSelectChange_.bind(this);
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ListView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.selectElement.addEventListener("change", this.onSelectChange_);
        }
        onSelectChange_(e) {
          const selectElem = forceCast(e.currentTarget);
          this.value.rawValue = this.props.get("options")[selectElem.selectedIndex].value;
        }
      }
      const className$i = ClassName("pop");
      class PopupView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$i());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.shows, valueToClassName(this.element, className$i(void 0, "v")));
        }
      }
      class PopupController {
        constructor(doc, config) {
          this.shows = createValue(false);
          this.viewProps = config.viewProps;
          this.view = new PopupView(doc, {
            shows: this.shows,
            viewProps: this.viewProps
          });
        }
      }
      const className$h = ClassName("txt");
      class TextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$h());
          config.viewProps.bindClassModifiers(this.element);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$h("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value_.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class TextController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.parser_ = config.parser;
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new TextView(doc, {
            props: config.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = parsedValue;
          }
          this.view.refresh();
        }
      }
      function boolToString(value) {
        return String(value);
      }
      function boolFromUnknown(value) {
        if (value === "false") {
          return false;
        }
        return !!value;
      }
      function BooleanFormatter(value) {
        return boolToString(value);
      }
      class NumberLiteralNode {
        constructor(text) {
          this.text = text;
        }
        evaluate() {
          return Number(this.text);
        }
        toString() {
          return this.text;
        }
      }
      const BINARY_OPERATION_MAP = {
        "**": (v12, v22) => Math.pow(v12, v22),
        "*": (v12, v22) => v12 * v22,
        "/": (v12, v22) => v12 / v22,
        "%": (v12, v22) => v12 % v22,
        "+": (v12, v22) => v12 + v22,
        "-": (v12, v22) => v12 - v22,
        "<<": (v12, v22) => v12 << v22,
        ">>": (v12, v22) => v12 >> v22,
        ">>>": (v12, v22) => v12 >>> v22,
        "&": (v12, v22) => v12 & v22,
        "^": (v12, v22) => v12 ^ v22,
        "|": (v12, v22) => v12 | v22
      };
      class BinaryOperationNode {
        constructor(operator, left, right) {
          this.left = left;
          this.operator = operator;
          this.right = right;
        }
        evaluate() {
          const op = BINARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected binary operator: '${this.operator}`);
          }
          return op(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
          return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")"
          ].join(" ");
        }
      }
      const UNARY_OPERATION_MAP = {
        "+": (v4) => v4,
        "-": (v4) => -v4,
        "~": (v4) => ~v4
      };
      class UnaryOperationNode {
        constructor(operator, expr) {
          this.operator = operator;
          this.expression = expr;
        }
        evaluate() {
          const op = UNARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected unary operator: '${this.operator}`);
          }
          return op(this.expression.evaluate());
        }
        toString() {
          return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
        }
      }
      function combineReader(parsers) {
        return (text, cursor) => {
          for (let i = 0; i < parsers.length; i++) {
            const result = parsers[i](text, cursor);
            if (result !== "") {
              return result;
            }
          }
          return "";
        };
      }
      function readWhitespace(text, cursor) {
        var _a2;
        const m = text.substr(cursor).match(/^\s+/);
        return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readNonZeroDigit(text, cursor) {
        const ch3 = text.substr(cursor, 1);
        return ch3.match(/^[1-9]$/) ? ch3 : "";
      }
      function readDecimalDigits(text, cursor) {
        var _a2;
        const m = text.substr(cursor).match(/^[0-9]+/);
        return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readSignedInteger(text, cursor) {
        const ds = readDecimalDigits(text, cursor);
        if (ds !== "") {
          return ds;
        }
        const sign = text.substr(cursor, 1);
        cursor += 1;
        if (sign !== "-" && sign !== "+") {
          return "";
        }
        const sds = readDecimalDigits(text, cursor);
        if (sds === "") {
          return "";
        }
        return sign + sds;
      }
      function readExponentPart(text, cursor) {
        const e = text.substr(cursor, 1);
        cursor += 1;
        if (e.toLowerCase() !== "e") {
          return "";
        }
        const si = readSignedInteger(text, cursor);
        if (si === "") {
          return "";
        }
        return e + si;
      }
      function readDecimalIntegerLiteral(text, cursor) {
        const ch3 = text.substr(cursor, 1);
        if (ch3 === "0") {
          return ch3;
        }
        const nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;
        if (nzd === "") {
          return "";
        }
        return nzd + readDecimalDigits(text, cursor);
      }
      function readDecimalLiteral1(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral2(text, cursor) {
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        if (dds === "") {
          return "";
        }
        return dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral3(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        return dil + readExponentPart(text, cursor);
      }
      const readDecimalLiteral = combineReader([
        readDecimalLiteral1,
        readDecimalLiteral2,
        readDecimalLiteral3
      ]);
      function parseBinaryDigits(text, cursor) {
        var _a2;
        const m = text.substr(cursor).match(/^[01]+/);
        return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readBinaryIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0b") {
          return "";
        }
        const bds = parseBinaryDigits(text, cursor);
        if (bds === "") {
          return "";
        }
        return prefix + bds;
      }
      function readOctalDigits(text, cursor) {
        var _a2;
        const m = text.substr(cursor).match(/^[0-7]+/);
        return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readOctalIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0o") {
          return "";
        }
        const ods = readOctalDigits(text, cursor);
        if (ods === "") {
          return "";
        }
        return prefix + ods;
      }
      function readHexDigits(text, cursor) {
        var _a2;
        const m = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
      }
      function readHexIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0x") {
          return "";
        }
        const hds = readHexDigits(text, cursor);
        if (hds === "") {
          return "";
        }
        return prefix + hds;
      }
      const readNonDecimalIntegerLiteral = combineReader([
        readBinaryIntegerLiteral,
        readOctalIntegerLiteral,
        readHexIntegerLiteral
      ]);
      const readNumericLiteral = combineReader([
        readNonDecimalIntegerLiteral,
        readDecimalLiteral
      ]);
      function parseLiteral(text, cursor) {
        const num = readNumericLiteral(text, cursor);
        cursor += num.length;
        if (num === "") {
          return null;
        }
        return {
          evaluable: new NumberLiteralNode(num),
          cursor
        };
      }
      function parseParenthesizedExpression(text, cursor) {
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "(") {
          return null;
        }
        const expr = parseExpression(text, cursor);
        if (!expr) {
          return null;
        }
        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        const cl = text.substr(cursor, 1);
        cursor += cl.length;
        if (cl !== ")") {
          return null;
        }
        return {
          evaluable: expr.evaluable,
          cursor
        };
      }
      function parsePrimaryExpression(text, cursor) {
        var _a2;
        return (_a2 = parseLiteral(text, cursor)) !== null && _a2 !== void 0 ? _a2 : parseParenthesizedExpression(text, cursor);
      }
      function parseUnaryExpression(text, cursor) {
        const expr = parsePrimaryExpression(text, cursor);
        if (expr) {
          return expr;
        }
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "+" && op !== "-" && op !== "~") {
          return null;
        }
        const num = parseUnaryExpression(text, cursor);
        if (!num) {
          return null;
        }
        cursor = num.cursor;
        return {
          cursor,
          evaluable: new UnaryOperationNode(op, num.evaluable)
        };
      }
      function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
        if (!op) {
          return null;
        }
        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
          cursor,
          operator: op
        };
      }
      function createBinaryOperationExpressionParser(exprParser, ops) {
        return (text, cursor) => {
          const firstExpr = exprParser(text, cursor);
          if (!firstExpr) {
            return null;
          }
          cursor = firstExpr.cursor;
          let expr = firstExpr.evaluable;
          for (; ; ) {
            const op = readBinaryOperator(ops, text, cursor);
            if (!op) {
              break;
            }
            cursor = op.cursor;
            const nextExpr = exprParser(text, cursor);
            if (!nextExpr) {
              return null;
            }
            cursor = nextExpr.cursor;
            expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
          }
          return expr ? {
            cursor,
            evaluable: expr
          } : null;
        };
      }
      const parseBinaryOperationExpression = [
        ["**"],
        ["*", "/", "%"],
        ["+", "-"],
        ["<<", ">>>", ">>"],
        ["&"],
        ["^"],
        ["|"]
      ].reduce((parser, ops) => {
        return createBinaryOperationExpressionParser(parser, ops);
      }, parseUnaryExpression);
      function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
      }
      function parseEcmaNumberExpression(text) {
        const expr = parseExpression(text, 0);
        if (!expr) {
          return null;
        }
        const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
        if (cursor !== text.length) {
          return null;
        }
        return expr.evaluable;
      }
      function parseNumber(text) {
        var _a2;
        const r = parseEcmaNumberExpression(text);
        return (_a2 = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function numberFromUnknown(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          const pv = parseNumber(value);
          if (!isEmpty(pv)) {
            return pv;
          }
        }
        return 0;
      }
      function numberToString(value) {
        return String(value);
      }
      function createNumberFormatter(digits) {
        return (value) => {
          return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
      }
      const innerFormatter = createNumberFormatter(0);
      function formatPercentage(value) {
        return innerFormatter(value) + "%";
      }
      function stringFromUnknown(value) {
        return String(value);
      }
      function formatString(value) {
        return value;
      }
      function connectValues({ primary, secondary, forward, backward }) {
        let changing = false;
        function preventFeedback(callback) {
          if (changing) {
            return;
          }
          changing = true;
          callback();
          changing = false;
        }
        primary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        secondary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            primary.setRawValue(backward(primary, secondary), ev.options);
          });
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        preventFeedback(() => {
          secondary.setRawValue(forward(primary, secondary), {
            forceEmit: false,
            last: true
          });
        });
      }
      function getStepForKey(baseStep, keys) {
        const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
        if (keys.upKey) {
          return +step;
        } else if (keys.downKey) {
          return -step;
        }
        return 0;
      }
      function getVerticalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowDown",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowUp"
        };
      }
      function getHorizontalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowLeft",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowRight"
        };
      }
      function isVerticalArrowKey(key2) {
        return key2 === "ArrowUp" || key2 === "ArrowDown";
      }
      function isArrowKey(key2) {
        return isVerticalArrowKey(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight";
      }
      function computeOffset$1(ev, elem) {
        var _a2, _b2;
        const win = elem.ownerDocument.defaultView;
        const rect = elem.getBoundingClientRect();
        return {
          x: ev.pageX - (((_a2 = win && win.scrollX) !== null && _a2 !== void 0 ? _a2 : 0) + rect.left),
          y: ev.pageY - (((_b2 = win && win.scrollY) !== null && _b2 !== void 0 ? _b2 : 0) + rect.top)
        };
      }
      class PointerHandler {
        constructor(element2) {
          this.lastTouch_ = null;
          this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
          this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
          this.onMouseDown_ = this.onMouseDown_.bind(this);
          this.onTouchEnd_ = this.onTouchEnd_.bind(this);
          this.onTouchMove_ = this.onTouchMove_.bind(this);
          this.onTouchStart_ = this.onTouchStart_.bind(this);
          this.elem_ = element2;
          this.emitter = new Emitter();
          element2.addEventListener("touchstart", this.onTouchStart_, {
            passive: false
          });
          element2.addEventListener("touchmove", this.onTouchMove_, {
            passive: true
          });
          element2.addEventListener("touchend", this.onTouchEnd_);
          element2.addEventListener("mousedown", this.onMouseDown_);
        }
        computePosition_(offset) {
          const rect = this.elem_.getBoundingClientRect();
          return {
            bounds: {
              width: rect.width,
              height: rect.height
            },
            point: offset ? {
              x: offset.x,
              y: offset.y
            } : null
          };
        }
        onMouseDown_(ev) {
          var _a2;
          ev.preventDefault();
          (_a2 = ev.currentTarget) === null || _a2 === void 0 ? void 0 : _a2.focus();
          const doc = this.elem_.ownerDocument;
          doc.addEventListener("mousemove", this.onDocumentMouseMove_);
          doc.addEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseMove_(ev) {
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseUp_(ev) {
          const doc = this.elem_.ownerDocument;
          doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
          doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onTouchStart_(ev) {
          ev.preventDefault();
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchMove_(ev) {
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchEnd_(ev) {
          var _a2;
          const touch = (_a2 = ev.targetTouches.item(0)) !== null && _a2 !== void 0 ? _a2 : this.lastTouch_;
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
      }
      function mapRange(value, start1, end1, start2, end2) {
        const p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
      }
      function getDecimalDigits(value) {
        const text = String(value.toFixed(10));
        const frac = text.split(".")[1];
        return frac.replace(/0+$/, "").length;
      }
      function constrainRange(value, min, max2) {
        return Math.min(Math.max(value, min), max2);
      }
      function loopRange(value, max2) {
        return (value % max2 + max2) % max2;
      }
      const className$g = ClassName("txt");
      class NumberTextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$g(), className$g(void 0, "num"));
          if (config.arrayPosition) {
            this.element.classList.add(className$g(void 0, config.arrayPosition));
          }
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$g("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          this.onDraggingChange_ = this.onDraggingChange_.bind(this);
          this.dragging_ = config.dragging;
          this.dragging_.emitter.on("change", this.onDraggingChange_);
          this.element.classList.add(className$g());
          this.inputElement.classList.add(className$g("i"));
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$g("k"));
          this.element.appendChild(knobElem);
          this.knobElement = knobElem;
          const guideElem = doc.createElementNS(SVG_NS, "svg");
          guideElem.classList.add(className$g("g"));
          this.knobElement.appendChild(guideElem);
          const bodyElem = doc.createElementNS(SVG_NS, "path");
          bodyElem.classList.add(className$g("gb"));
          guideElem.appendChild(bodyElem);
          this.guideBodyElem_ = bodyElem;
          const headElem = doc.createElementNS(SVG_NS, "path");
          headElem.classList.add(className$g("gh"));
          guideElem.appendChild(headElem);
          this.guideHeadElem_ = headElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(ClassName("tt")());
          this.knobElement.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.refresh();
        }
        onDraggingChange_(ev) {
          if (ev.rawValue === null) {
            this.element.classList.remove(className$g(void 0, "drg"));
            return;
          }
          this.element.classList.add(className$g(void 0, "drg"));
          const x = ev.rawValue / this.props_.get("draggingScale");
          const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
          const adx = constrainRange(-aox, -4, 4);
          this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(" "));
          this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
          const formatter = this.props_.get("formatter");
          this.tooltipElem_.textContent = formatter(this.value.rawValue);
          this.tooltipElem_.style.left = `${x}px`;
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class NumberTextController {
        constructor(doc, config) {
          var _a2;
          this.originRawValue_ = 0;
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
          this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.parser_ = config.parser;
          this.props = config.props;
          this.sliderProps_ = (_a2 = config.sliderProps) !== null && _a2 !== void 0 ? _a2 : null;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.dragging_ = createValue(null);
          this.view = new NumberTextView(doc, {
            arrayPosition: config.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
          this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
          this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
          const ph = new PointerHandler(this.view.knobElement);
          ph.emitter.on("down", this.onPointerDown_);
          ph.emitter.on("move", this.onPointerMove_);
          ph.emitter.on("up", this.onPointerUp_);
        }
        constrainValue_(value) {
          var _a2, _b2;
          const min = (_a2 = this.sliderProps_) === null || _a2 === void 0 ? void 0 : _a2.get("minValue");
          const max2 = (_b2 = this.sliderProps_) === null || _b2 === void 0 ? void 0 : _b2.get("maxValue");
          let v4 = value;
          if (min !== void 0) {
            v4 = Math.max(v4, min);
          }
          if (max2 !== void 0) {
            v4 = Math.min(v4, max2);
          }
          return v4;
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = this.constrainValue_(parsedValue);
          }
          this.view.refresh();
        }
        onInputKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
            forceEmit: false,
            last: false
          });
        }
        onInputKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
        onPointerDown_() {
          this.originRawValue_ = this.value.rawValue;
          this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(data) {
          if (!data.point) {
            return null;
          }
          const dx = data.point.x - data.bounds.width / 2;
          return this.constrainValue_(this.originRawValue_ + dx * this.props.get("draggingScale"));
        }
        onPointerMove_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: false,
            last: false
          });
          this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
        }
        onPointerUp_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: true,
            last: true
          });
          this.dragging_.rawValue = null;
        }
      }
      const className$f = ClassName("sld");
      class SliderView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$f());
          config.viewProps.bindClassModifiers(this.element);
          const trackElem = doc.createElement("div");
          trackElem.classList.add(className$f("t"));
          config.viewProps.bindTabIndex(trackElem);
          this.element.appendChild(trackElem);
          this.trackElement = trackElem;
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$f("k"));
          this.trackElement.appendChild(knobElem);
          this.knobElement = knobElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const p = constrainRange(mapRange(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
          this.knobElement.style.width = `${p}%`;
        }
        onChange_() {
          this.update_();
        }
      }
      class SliderController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.props = config.props;
          this.view = new SliderView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.trackElement);
          this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
          this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
        }
        onPointerDownOrMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue + step, {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$e = ClassName("sldtxt");
      class SliderTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$e());
          const sliderElem = doc.createElement("div");
          sliderElem.classList.add(className$e("s"));
          this.sliderView_ = config.sliderView;
          sliderElem.appendChild(this.sliderView_.element);
          this.element.appendChild(sliderElem);
          const textElem = doc.createElement("div");
          textElem.classList.add(className$e("t"));
          this.textView_ = config.textView;
          textElem.appendChild(this.textView_.element);
          this.element.appendChild(textElem);
        }
      }
      class SliderTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.sliderC_ = new SliderController(doc, {
            baseStep: config.baseStep,
            props: config.sliderProps,
            value: config.value,
            viewProps: this.viewProps
          });
          this.textC_ = new NumberTextController(doc, {
            baseStep: config.baseStep,
            parser: config.parser,
            props: config.textProps,
            sliderProps: config.sliderProps,
            value: config.value,
            viewProps: config.viewProps
          });
          this.view = new SliderTextView(doc, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }
        get sliderController() {
          return this.sliderC_;
        }
        get textController() {
          return this.textC_;
        }
      }
      function writePrimitive(target, value) {
        target.write(value);
      }
      function parseListOptions(value) {
        const p = ParamsParsers;
        if (Array.isArray(value)) {
          return p.required.array(p.required.object({
            text: p.required.string,
            value: p.required.raw
          }))(value).value;
        }
        if (typeof value === "object") {
          return p.required.raw(value).value;
        }
        return void 0;
      }
      function parsePickerLayout(value) {
        if (value === "inline" || value === "popup") {
          return value;
        }
        return void 0;
      }
      function parsePointDimensionParams(value) {
        const p = ParamsParsers;
        return p.required.object({
          max: p.optional.number,
          min: p.optional.number,
          step: p.optional.number
        })(value).value;
      }
      function normalizeListOptions(options) {
        if (Array.isArray(options)) {
          return options;
        }
        const items = [];
        Object.keys(options).forEach((text) => {
          items.push({ text, value: options[text] });
        });
        return items;
      }
      function createListConstraint(options) {
        return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
      }
      function findStep(constraint) {
        const c = constraint ? findConstraint(constraint, StepConstraint) : null;
        if (!c) {
          return null;
        }
        return c.step;
      }
      function getSuitableDecimalDigits(constraint, rawValue) {
        const sc = constraint && findConstraint(constraint, StepConstraint);
        if (sc) {
          return getDecimalDigits(sc.step);
        }
        return Math.max(getDecimalDigits(rawValue), 2);
      }
      function getBaseStep(constraint) {
        const step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
      }
      function getSuitableDraggingScale(constraint, rawValue) {
        var _a2;
        const sc = constraint && findConstraint(constraint, StepConstraint);
        const base = Math.abs((_a2 = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a2 !== void 0 ? _a2 : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
      }
      const className$d = ClassName("ckb");
      class CheckboxView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$d());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("label");
          labelElem.classList.add(className$d("l"));
          this.element.appendChild(labelElem);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$d("i"));
          inputElem.type = "checkbox";
          labelElem.appendChild(inputElem);
          this.inputElement = inputElem;
          config.viewProps.bindDisabled(this.inputElement);
          const wrapperElem = doc.createElement("div");
          wrapperElem.classList.add(className$d("w"));
          labelElem.appendChild(wrapperElem);
          const markElem = createSvgIconElement(doc, "check");
          wrapperElem.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class CheckboxController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new CheckboxView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          this.value.rawValue = inputElem.checked;
        }
      }
      function createConstraint$6(params) {
        const constraints = [];
        const lc2 = createListConstraint(params.options);
        if (lc2) {
          constraints.push(lc2);
        }
        return new CompositeConstraint(constraints);
      }
      const BooleanInputPlugin = {
        id: "input-bool",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown,
          constraint: (args) => createConstraint$6(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          const lc2 = c && findConstraint(c, ListConstraint);
          if (lc2) {
            return new ListController(doc, {
              props: new ValueMap({
                options: lc2.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new CheckboxController(doc, {
            value,
            viewProps: args.viewProps
          });
        }
      };
      const className$c = ClassName("col");
      class ColorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$c());
          config.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
          bindValueMap(config.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$c("h"));
          this.element.appendChild(headElem);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$c("s"));
          headElem.appendChild(swatchElem);
          this.swatchElement = swatchElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$c("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$c("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      function rgbToHslInt(r, g4, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g4 / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const c = cmax - cmin;
        let h = 0;
        let s = 0;
        const l = (cmin + cmax) / 2;
        if (c !== 0) {
          s = c / (1 - Math.abs(cmax + cmin - 1));
          if (rp === cmax) {
            h = (gp - bp) / c;
          } else if (gp === cmax) {
            h = 2 + (bp - rp) / c;
          } else {
            h = 4 + (rp - gp) / c;
          }
          h = h / 6 + (h < 0 ? 1 : 0);
        }
        return [h * 360, s * 100, l * 100];
      }
      function hslToRgbInt(h, s, l) {
        const hp = (h % 360 + 360) % 360;
        const sp = constrainRange(s / 100, 0, 1);
        const lp = constrainRange(l / 100, 0, 1);
        const c = (1 - Math.abs(2 * lp - 1)) * sp;
        const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        const m = lp - c / 2;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c, x, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x, c, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c, x];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x, c];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x, 0, c];
        } else {
          [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
      }
      function rgbToHsvInt(r, g4, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g4 / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const d = cmax - cmin;
        let h;
        if (d === 0) {
          h = 0;
        } else if (cmax === rp) {
          h = 60 * (((gp - bp) / d % 6 + 6) % 6);
        } else if (cmax === gp) {
          h = 60 * ((bp - rp) / d + 2);
        } else {
          h = 60 * ((rp - gp) / d + 4);
        }
        const s = cmax === 0 ? 0 : d / cmax;
        const v4 = cmax;
        return [h, s * 100, v4 * 100];
      }
      function hsvToRgbInt(h, s, v4) {
        const hp = loopRange(h, 360);
        const sp = constrainRange(s / 100, 0, 1);
        const vp = constrainRange(v4 / 100, 0, 1);
        const c = vp * sp;
        const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        const m = vp - c;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c, x, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x, c, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c, x];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x, c];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x, 0, c];
        } else {
          [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
      }
      function hslToHsvInt(h, s, l) {
        const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
        return [
          h,
          sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,
          l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)
        ];
      }
      function hsvToHslInt(h, s, v4) {
        const sd = 100 - Math.abs(v4 * (200 - s) / 100 - 100);
        return [h, sd !== 0 ? s * v4 / sd : 0, v4 * (200 - s) / (2 * 100)];
      }
      function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
      }
      function appendAlphaComponent(comps, alpha) {
        return [comps[0], comps[1], comps[2], alpha];
      }
      const MODE_CONVERTER_MAP = {
        hsl: {
          hsl: (h, s, l) => [h, s, l],
          hsv: hslToHsvInt,
          rgb: hslToRgbInt
        },
        hsv: {
          hsl: hsvToHslInt,
          hsv: (h, s, v4) => [h, s, v4],
          rgb: hsvToRgbInt
        },
        rgb: {
          hsl: rgbToHslInt,
          hsv: rgbToHsvInt,
          rgb: (r, g4, b) => [r, g4, b]
        }
      };
      function getColorMaxComponents(mode, type) {
        return [
          type === "float" ? 1 : mode === "rgb" ? 255 : 360,
          type === "float" ? 1 : mode === "rgb" ? 255 : 100,
          type === "float" ? 1 : mode === "rgb" ? 255 : 100
        ];
      }
      function loopHueRange(hue, max2) {
        return hue === max2 ? max2 : loopRange(hue, max2);
      }
      function constrainColorComponents(components, mode, type) {
        var _a2;
        const ms = getColorMaxComponents(mode, type);
        return [
          mode === "rgb" ? constrainRange(components[0], 0, ms[0]) : loopHueRange(components[0], ms[0]),
          constrainRange(components[1], 0, ms[1]),
          constrainRange(components[2], 0, ms[2]),
          constrainRange((_a2 = components[3]) !== null && _a2 !== void 0 ? _a2 : 1, 0, 1)
        ];
      }
      function convertColorType(comps, mode, from2, to) {
        const fms = getColorMaxComponents(mode, from2);
        const tms = getColorMaxComponents(mode, to);
        return comps.map((c, index) => c / fms[index] * tms[index]);
      }
      function convertColor(components, from2, to) {
        const intComps = convertColorType(components, from2.mode, from2.type, "int");
        const result = MODE_CONVERTER_MAP[from2.mode][to.mode](...intComps);
        return convertColorType(result, to.mode, "int", to.type);
      }
      function isRgbColorComponent(obj, key2) {
        if (typeof obj !== "object" || isEmpty(obj)) {
          return false;
        }
        return key2 in obj && typeof obj[key2] === "number";
      }
      class Color2 {
        static black(type = "int") {
          return new Color2([0, 0, 0], "rgb", type);
        }
        static fromObject(obj, type = "int") {
          const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
          return new Color2(comps, "rgb", type);
        }
        static toRgbaObject(color2, type = "int") {
          return color2.toRgbaObject(type);
        }
        static isRgbColorObject(obj) {
          return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
        }
        static isRgbaColorObject(obj) {
          return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
        }
        static isColorObject(obj) {
          return this.isRgbColorObject(obj);
        }
        static equals(v12, v22) {
          if (v12.mode !== v22.mode) {
            return false;
          }
          const comps1 = v12.comps_;
          const comps2 = v22.comps_;
          for (let i = 0; i < comps1.length; i++) {
            if (comps1[i] !== comps2[i]) {
              return false;
            }
          }
          return true;
        }
        constructor(comps, mode, type = "int") {
          this.mode = mode;
          this.type = type;
          this.comps_ = constrainColorComponents(comps, mode, type);
        }
        getComponents(opt_mode, type = "int") {
          return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type }), this.comps_[3]);
        }
        toRgbaObject(type = "int") {
          const rgbComps = this.getComponents("rgb", type);
          return {
            r: rgbComps[0],
            g: rgbComps[1],
            b: rgbComps[2],
            a: rgbComps[3]
          };
        }
      }
      const className$b = ClassName("colp");
      class ColorPickerView {
        constructor(doc, config) {
          this.alphaViews_ = null;
          this.element = doc.createElement("div");
          this.element.classList.add(className$b());
          config.viewProps.bindClassModifiers(this.element);
          const hsvElem = doc.createElement("div");
          hsvElem.classList.add(className$b("hsv"));
          const svElem = doc.createElement("div");
          svElem.classList.add(className$b("sv"));
          this.svPaletteView_ = config.svPaletteView;
          svElem.appendChild(this.svPaletteView_.element);
          hsvElem.appendChild(svElem);
          const hElem = doc.createElement("div");
          hElem.classList.add(className$b("h"));
          this.hPaletteView_ = config.hPaletteView;
          hElem.appendChild(this.hPaletteView_.element);
          hsvElem.appendChild(hElem);
          this.element.appendChild(hsvElem);
          const rgbElem = doc.createElement("div");
          rgbElem.classList.add(className$b("rgb"));
          this.textView_ = config.textView;
          rgbElem.appendChild(this.textView_.element);
          this.element.appendChild(rgbElem);
          if (config.alphaViews) {
            this.alphaViews_ = {
              palette: config.alphaViews.palette,
              text: config.alphaViews.text
            };
            const aElem = doc.createElement("div");
            aElem.classList.add(className$b("a"));
            const apElem = doc.createElement("div");
            apElem.classList.add(className$b("ap"));
            apElem.appendChild(this.alphaViews_.palette.element);
            aElem.appendChild(apElem);
            const atElem = doc.createElement("div");
            atElem.classList.add(className$b("at"));
            atElem.appendChild(this.alphaViews_.text.element);
            aElem.appendChild(atElem);
            this.element.appendChild(aElem);
          }
        }
        get allFocusableElements() {
          const elems = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textView_.modeSelectElement,
            ...this.textView_.textViews.map((v4) => v4.inputElement)
          ];
          if (this.alphaViews_) {
            elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
          }
          return elems;
        }
      }
      function parseColorType(value) {
        return value === "int" ? "int" : value === "float" ? "float" : void 0;
      }
      function parseColorInputParams(params) {
        const p = ParamsParsers;
        return parseParams(params, {
          alpha: p.optional.boolean,
          color: p.optional.object({
            alpha: p.optional.boolean,
            type: p.optional.custom(parseColorType)
          }),
          expanded: p.optional.boolean,
          picker: p.optional.custom(parsePickerLayout)
        });
      }
      function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
      }
      function extractColorType(params) {
        var _a2;
        return (_a2 = params.color) === null || _a2 === void 0 ? void 0 : _a2.type;
      }
      function equalsStringColorFormat(f1, f2) {
        return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;
      }
      function parseCssNumberOrPercentage(text, maxValue) {
        const m = text.match(/^(.+)%$/);
        if (!m) {
          return Math.min(parseFloat(text), maxValue);
        }
        return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
      }
      const ANGLE_TO_DEG_MAP = {
        deg: (angle) => angle,
        grad: (angle) => angle * 360 / 400,
        rad: (angle) => angle * 360 / (2 * Math.PI),
        turn: (angle) => angle * 360
      };
      function parseCssNumberOrAngle(text) {
        const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!m) {
          return parseFloat(text);
        }
        const angle = parseFloat(m[1]);
        const unit = m[2];
        return ANGLE_TO_DEG_MAP[unit](angle);
      }
      function parseFunctionalRgbColorComponents(text) {
        const m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m[1], 255),
          parseCssNumberOrPercentage(m[2], 255),
          parseCssNumberOrPercentage(m[3], 255)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbColorParser(type) {
        return (text) => {
          const comps = parseFunctionalRgbColorComponents(text);
          return comps ? new Color2(comps, "rgb", type) : null;
        };
      }
      function parseFunctionalRgbaColorComponents(text) {
        const m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m[1], 255),
          parseCssNumberOrPercentage(m[2], 255),
          parseCssNumberOrPercentage(m[3], 255),
          parseCssNumberOrPercentage(m[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbaColorParser(type) {
        return (text) => {
          const comps = parseFunctionalRgbaColorComponents(text);
          return comps ? new Color2(comps, "rgb", type) : null;
        };
      }
      function parseHslColorComponents(text) {
        const m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m[1]),
          parseCssNumberOrPercentage(m[2], 100),
          parseCssNumberOrPercentage(m[3], 100)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createHslColorParser(type) {
        return (text) => {
          const comps = parseHslColorComponents(text);
          return comps ? new Color2(comps, "hsl", type) : null;
        };
      }
      function parseHslaColorComponents(text) {
        const m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m[1]),
          parseCssNumberOrPercentage(m[2], 100),
          parseCssNumberOrPercentage(m[3], 100),
          parseCssNumberOrPercentage(m[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createHslaColorParser(type) {
        return (text) => {
          const comps = parseHslaColorComponents(text);
          return comps ? new Color2(comps, "hsl", type) : null;
        };
      }
      function parseHexRgbColorComponents(text) {
        const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16)
          ];
        }
        return null;
      }
      function parseHexRgbColor(text) {
        const comps = parseHexRgbColorComponents(text);
        return comps ? new Color2(comps, "rgb", "int") : null;
      }
      function parseHexRgbaColorComponents(text) {
        const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16),
            mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16),
            mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
          ];
        }
        return null;
      }
      function parseHexRgbaColor(text) {
        const comps = parseHexRgbaColorComponents(text);
        return comps ? new Color2(comps, "rgb", "int") : null;
      }
      function parseObjectRgbColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseFloat(m[1]),
          parseFloat(m[2]),
          parseFloat(m[3])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbColorParser(type) {
        return (text) => {
          const comps = parseObjectRgbColorComponents(text);
          return comps ? new Color2(comps, "rgb", type) : null;
        };
      }
      function parseObjectRgbaColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
          return null;
        }
        const comps = [
          parseFloat(m[1]),
          parseFloat(m[2]),
          parseFloat(m[3]),
          parseFloat(m[4])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbaColorParser(type) {
        return (text) => {
          const comps = parseObjectRgbaColorComponents(text);
          return comps ? new Color2(comps, "rgb", type) : null;
        };
      }
      const PARSER_AND_RESULT = [
        {
          parser: parseHexRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseHexRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseFunctionalRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseFunctionalRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseHslColorComponents,
          result: {
            alpha: false,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseHslaColorComponents,
          result: {
            alpha: true,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseObjectRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "object"
          }
        },
        {
          parser: parseObjectRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "object"
          }
        }
      ];
      function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
          if (prev) {
            return prev;
          }
          return parser(text) ? detection : null;
        }, null);
      }
      function detectStringColorFormat(text, type = "int") {
        const r = detectStringColor(text);
        if (!r) {
          return null;
        }
        if (r.notation === "hex" && type !== "float") {
          return Object.assign(Object.assign({}, r), { type: "int" });
        }
        if (r.notation === "func") {
          return Object.assign(Object.assign({}, r), { type });
        }
        return null;
      }
      const TYPE_TO_PARSERS = {
        int: [
          parseHexRgbColor,
          parseHexRgbaColor,
          createFunctionalRgbColorParser("int"),
          createFunctionalRgbaColorParser("int"),
          createHslColorParser("int"),
          createHslaColorParser("int"),
          createObjectRgbColorParser("int"),
          createObjectRgbaColorParser("int")
        ],
        float: [
          createFunctionalRgbColorParser("float"),
          createFunctionalRgbaColorParser("float"),
          createHslColorParser("float"),
          createHslaColorParser("float"),
          createObjectRgbColorParser("float"),
          createObjectRgbaColorParser("float")
        ]
      };
      function createColorStringBindingReader(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
          if (typeof value !== "string") {
            return Color2.black(type);
          }
          const result = parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
          return result !== null && result !== void 0 ? result : Color2.black(type);
        };
      }
      function createColorStringParser(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
          return parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
        };
      }
      function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }
      function colorToHexRgbString(value, prefix = "#") {
        const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToHexRgbaString(value, prefix = "#") {
        const rgbaComps = value.getComponents("rgb");
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents("rgb", opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(", ")})`;
      }
      function createFunctionalRgbColorFormatter(type) {
        return (value) => {
          return colorToFunctionalRgbString(value, type);
        };
      }
      function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = value.getComponents("rgb", opt_type).map((comp, index) => {
          const formatter = index === 3 ? aFormatter : rgbFormatter;
          return formatter(comp);
        });
        return `rgba(${comps.join(", ")})`;
      }
      function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
          return colorToFunctionalRgbaString(value, type);
        };
      }
      function colorToFunctionalHslString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage
        ];
        const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(", ")})`;
      }
      function colorToFunctionalHslaString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage,
          createNumberFormatter(2)
        ];
        const comps = value.getComponents("hsl").map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(", ")})`;
      }
      function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === "float" ? 2 : 0);
        const names = ["r", "g", "b"];
        const comps = removeAlphaComponent(value.getComponents("rgb", type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
      }
      function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === "float" ? 2 : 0);
        const names = ["r", "g", "b", "a"];
        const comps = value.getComponents("rgb", type).map((comp, index) => {
          const formatter = index === 3 ? aFormatter : rgbFormatter;
          return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
      }
      const FORMAT_AND_STRINGIFIERS = [
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbString
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbaString
        },
        {
          format: {
            alpha: false,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslString
        },
        {
          format: {
            alpha: true,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslaString
        },
        ...["int", "float"].reduce((prev, type) => {
          return [
            ...prev,
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "func",
                type
              },
              stringifier: createFunctionalRgbColorFormatter(type)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "func",
                type
              },
              stringifier: createFunctionalRgbaColorFormatter(type)
            },
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "object",
                type
              },
              stringifier: createObjectRgbColorFormatter(type)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "object",
                type
              },
              stringifier: createObjectRgbaColorFormatter(type)
            }
          ];
        }, [])
      ];
      function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
          if (prev) {
            return prev;
          }
          return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
        }, null);
      }
      const className$a = ClassName("apl");
      class APaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$a());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const barElem = doc.createElement("div");
          barElem.classList.add(className$a("b"));
          this.element.appendChild(barElem);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$a("c"));
          barElem.appendChild(colorElem);
          this.colorElem_ = colorElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$a("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          const previewElem = doc.createElement("div");
          previewElem.classList.add(className$a("p"));
          this.markerElem_.appendChild(previewElem);
          this.previewElem_ = previewElem;
          this.update_();
        }
        update_() {
          const c = this.value.rawValue;
          const rgbaComps = c.getComponents("rgb");
          const leftColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
          const rightColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
          const gradientComps = [
            "to right",
            colorToFunctionalRgbaString(leftColor),
            colorToFunctionalRgbaString(rightColor)
          ];
          this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
          this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
          const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class APaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new APaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const alpha = d.point.x / d.bounds.width;
          const c = this.value.rawValue;
          const [h, s, v4] = c.getComponents("hsv");
          this.value.setRawValue(new Color2([h, s, v4, alpha], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c = this.value.rawValue;
          const [h, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color2([h, s, v4, a + step], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$9 = ClassName("coltxt");
      function createModeSelectElement(doc) {
        const selectElem = doc.createElement("select");
        const items = [
          { text: "RGB", value: "rgb" },
          { text: "HSL", value: "hsl" },
          { text: "HSV", value: "hsv" }
        ];
        selectElem.appendChild(items.reduce((frag, item) => {
          const optElem = doc.createElement("option");
          optElem.textContent = item.text;
          optElem.value = item.value;
          frag.appendChild(optElem);
          return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
      }
      class ColorTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$9());
          config.viewProps.bindClassModifiers(this.element);
          const modeElem = doc.createElement("div");
          modeElem.classList.add(className$9("m"));
          this.modeElem_ = createModeSelectElement(doc);
          this.modeElem_.classList.add(className$9("ms"));
          modeElem.appendChild(this.modeSelectElement);
          config.viewProps.bindDisabled(this.modeElem_);
          const modeMarkerElem = doc.createElement("div");
          modeMarkerElem.classList.add(className$9("mm"));
          modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
          modeElem.appendChild(modeMarkerElem);
          this.element.appendChild(modeElem);
          const textsElem = doc.createElement("div");
          textsElem.classList.add(className$9("w"));
          this.element.appendChild(textsElem);
          this.textsElem_ = textsElem;
          this.textViews_ = config.textViews;
          this.applyTextViews_();
          bindValue(config.colorMode, (mode) => {
            this.modeElem_.value = mode;
          });
        }
        get modeSelectElement() {
          return this.modeElem_;
        }
        get textViews() {
          return this.textViews_;
        }
        set textViews(textViews) {
          this.textViews_ = textViews;
          this.applyTextViews_();
        }
        applyTextViews_() {
          removeChildElements(this.textsElem_);
          const doc = this.element.ownerDocument;
          this.textViews_.forEach((v4) => {
            const compElem = doc.createElement("div");
            compElem.classList.add(className$9("c"));
            compElem.appendChild(v4.element);
            this.textsElem_.appendChild(compElem);
          });
        }
      }
      function createFormatter$2(type) {
        return createNumberFormatter(type === "float" ? 2 : 0);
      }
      function createConstraint$5(mode, type, index) {
        const max2 = getColorMaxComponents(mode, type)[index];
        return new DefiniteRangeConstraint({
          min: 0,
          max: max2
        });
      }
      function createComponentController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
          baseStep: getBaseStepForColor(false),
          parser: config.parser,
          props: ValueMap.fromObject({
            draggingScale: config.colorType === "float" ? 0.01 : 1,
            formatter: createFormatter$2(config.colorType)
          }),
          value: createValue(0, {
            constraint: createConstraint$5(config.colorMode, config.colorType, index)
          }),
          viewProps: config.viewProps
        });
      }
      class ColorTextController {
        constructor(doc, config) {
          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
          this.colorType_ = config.colorType;
          this.parser_ = config.parser;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.colorMode = createValue(this.value.rawValue.mode);
          this.ccs_ = this.createComponentControllers_(doc);
          this.view = new ColorTextView(doc, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
          });
          this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
        }
        createComponentControllers_(doc) {
          const cc = {
            colorMode: this.colorMode.rawValue,
            colorType: this.colorType_,
            parser: this.parser_,
            viewProps: this.viewProps
          };
          const ccs = [
            createComponentController(doc, cc, 0),
            createComponentController(doc, cc, 1),
            createComponentController(doc, cc, 2)
          ];
          ccs.forEach((cs, index) => {
            connectValues({
              primary: this.value,
              secondary: cs.value,
              forward: (p) => {
                return p.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index];
              },
              backward: (p, s) => {
                const pickedMode = this.colorMode.rawValue;
                const comps = p.rawValue.getComponents(pickedMode, this.colorType_);
                comps[index] = s.rawValue;
                return new Color2(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
              }
            });
          });
          return ccs;
        }
        onModeSelectChange_(ev) {
          const selectElem = ev.currentTarget;
          this.colorMode.rawValue = selectElem.value;
          this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
          this.view.textViews = [
            this.ccs_[0].view,
            this.ccs_[1].view,
            this.ccs_[2].view
          ];
        }
      }
      const className$8 = ClassName("hpl");
      class HPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$8());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$8("c"));
          this.element.appendChild(colorElem);
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$8("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const c = this.value.rawValue;
          const [h] = c.getComponents("hsv");
          this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color2([h, 100, 100], "hsv"));
          const left = mapRange(h, 0, 360, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class HPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new HPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 360);
          const c = this.value.rawValue;
          const [, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color2([hue, s, v4, a], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c = this.value.rawValue;
          const [h, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color2([h + step, s, v4, a], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$7 = ClassName("svp");
      const CANVAS_RESOL = 64;
      class SvPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$7());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const canvasElem = doc.createElement("canvas");
          canvasElem.height = CANVAS_RESOL;
          canvasElem.width = CANVAS_RESOL;
          canvasElem.classList.add(className$7("c"));
          this.element.appendChild(canvasElem);
          this.canvasElement = canvasElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$7("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const ctx = getCanvasContext(this.canvasElement);
          if (!ctx) {
            return;
          }
          const c = this.value.rawValue;
          const hsvComps = c.getComponents("hsv");
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;
          const imgData = ctx.getImageData(0, 0, width, height);
          const data = imgData.data;
          for (let iy = 0; iy < height; iy++) {
            for (let ix = 0; ix < width; ix++) {
              const s = mapRange(ix, 0, width, 0, 100);
              const v4 = mapRange(iy, 0, height, 100, 0);
              const rgbComps = hsvToRgbInt(hsvComps[0], s, v4);
              const i = (iy * width + ix) * 4;
              data[i] = rgbComps[0];
              data[i + 1] = rgbComps[1];
              data[i + 2] = rgbComps[2];
              data[i + 3] = 255;
            }
          }
          ctx.putImageData(imgData, 0, 0);
          const left = mapRange(hsvComps[1], 0, 100, 0, 100);
          this.markerElem_.style.left = `${left}%`;
          const top = mapRange(hsvComps[2], 0, 100, 100, 0);
          this.markerElem_.style.top = `${top}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class SvPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SvPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
          const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
          const [h, , , a] = this.value.rawValue.getComponents("hsv");
          this.value.setRawValue(new Color2([h, saturation, value, a], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [h, s, v4, a] = this.value.rawValue.getComponents("hsv");
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(new Color2([h, s + ds, v4 + dv, a], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class ColorPickerController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.hPaletteC_ = new HPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.svPaletteC_ = new SvPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.alphaIcs_ = config.supportsAlpha ? {
            palette: new APaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new NumberTextController(doc, {
              parser: parseNumber,
              baseStep: 0.1,
              props: ValueMap.fromObject({
                draggingScale: 0.01,
                formatter: createNumberFormatter(2)
              }),
              value: createValue(0, {
                constraint: new DefiniteRangeConstraint({ min: 0, max: 1 })
              }),
              viewProps: this.viewProps
            })
          } : null;
          if (this.alphaIcs_) {
            connectValues({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: (p) => {
                return p.rawValue.getComponents()[3];
              },
              backward: (p, s) => {
                const comps = p.rawValue.getComponents();
                comps[3] = s.rawValue;
                return new Color2(comps, p.rawValue.mode);
              }
            });
          }
          this.textC_ = new ColorTextController(doc, {
            colorType: config.colorType,
            parser: parseNumber,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorPickerView(doc, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: config.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view,
            viewProps: this.viewProps
          });
        }
        get textController() {
          return this.textC_;
        }
      }
      const className$6 = ClassName("colsw");
      class ColorSwatchView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.element = doc.createElement("div");
          this.element.classList.add(className$6());
          config.viewProps.bindClassModifiers(this.element);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$6("sw"));
          this.element.appendChild(swatchElem);
          this.swatchElem_ = swatchElem;
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$6("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          this.update_();
        }
        update_() {
          const value = this.value.rawValue;
          this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ColorSwatchController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ColorSwatchView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      class ColorController {
        constructor(doc, config) {
          this.onButtonBlur_ = this.onButtonBlur_.bind(this);
          this.onButtonClick_ = this.onButtonClick_.bind(this);
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.swatchC_ = new ColorSwatchController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          const buttonElem = this.swatchC_.view.buttonElement;
          buttonElem.addEventListener("blur", this.onButtonBlur_);
          buttonElem.addEventListener("click", this.onButtonClick_);
          this.textC_ = new TextController(doc, {
            parser: config.parser,
            props: ValueMap.fromObject({
              formatter: config.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorView(doc, {
            foldable: this.foldable_,
            pickerLayout: config.pickerLayout
          });
          this.view.swatchElement.appendChild(this.swatchC_.view.element);
          this.view.textElement.appendChild(this.textC_.view.element);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const pickerC = new ColorPickerController(doc, {
            colorType: config.colorType,
            supportsAlpha: config.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          pickerC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = pickerC;
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(pickerC.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p) => p.rawValue,
              backward: (_, s) => s.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        get textController() {
          return this.textC_;
        }
        onButtonBlur_(e) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.swatchC_.view.buttonElement.focus();
            }
          }
        }
      }
      function colorFromObject(value, opt_type) {
        if (Color2.isColorObject(value)) {
          return Color2.fromObject(value, opt_type);
        }
        return Color2.black(opt_type);
      }
      function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
          return result << 8 | Math.floor(comp) & 255;
        }, 0);
      }
      function colorToRgbaNumber(value) {
        return value.getComponents("rgb").reduce((result, comp, index) => {
          const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
          return result << 8 | hex;
        }, 0) >>> 0;
      }
      function numberToRgbColor(num) {
        return new Color2([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
      }
      function numberToRgbaColor(num) {
        return new Color2([
          num >> 24 & 255,
          num >> 16 & 255,
          num >> 8 & 255,
          mapRange(num & 255, 0, 255, 0, 1)
        ], "rgb");
      }
      function colorFromRgbNumber(value) {
        if (typeof value !== "number") {
          return Color2.black();
        }
        return numberToRgbColor(value);
      }
      function colorFromRgbaNumber(value) {
        if (typeof value !== "number") {
          return Color2.black();
        }
        return numberToRgbaColor(value);
      }
      function createColorStringWriter(format) {
        const stringify = findColorStringifier(format);
        return stringify ? (target, value) => {
          writePrimitive(target, stringify(value));
        } : null;
      }
      function createColorNumberWriter(supportsAlpha) {
        const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return (target, value) => {
          writePrimitive(target, colorToNumber(value));
        };
      }
      function writeRgbaColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
        target.writeProperty("a", obj.a);
      }
      function writeRgbColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
      }
      function createColorObjectWriter(supportsAlpha, opt_type) {
        return (target, inValue) => {
          if (supportsAlpha) {
            writeRgbaColorObject(target, inValue, opt_type);
          } else {
            writeRgbColorObject(target, inValue, opt_type);
          }
        };
      }
      function shouldSupportAlpha$1(inputParams) {
        var _a2;
        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a2 = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a2 === void 0 ? void 0 : _a2.alpha)) {
          return true;
        }
        return false;
      }
      function createFormatter$1(supportsAlpha) {
        return supportsAlpha ? (v4) => colorToHexRgbaString(v4, "0x") : (v4) => colorToHexRgbString(v4, "0x");
      }
      function isForColor(params) {
        if ("color" in params) {
          return true;
        }
        if ("view" in params && params.view === "color") {
          return true;
        }
        return false;
      }
      const NumberColorInputPlugin = {
        id: "input-color-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          if (!isForColor(params)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
          },
          equals: Color2.equals,
          writer: (args) => {
            return createColorNumberWriter(shouldSupportAlpha$1(args.params));
          }
        },
        controller: (args) => {
          const supportsAlpha = shouldSupportAlpha$1(args.params);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: "int",
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createFormatter$1(supportsAlpha),
            parser: createColorStringParser("int"),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      function shouldSupportAlpha(initialValue) {
        return Color2.isRgbaColorObject(initialValue);
      }
      function createColorObjectReader(opt_type) {
        return (value) => {
          return colorFromObject(value, opt_type);
        };
      }
      function createColorObjectFormatter(supportsAlpha, type) {
        return (value) => {
          if (supportsAlpha) {
            return colorToObjectRgbaString(value, type);
          }
          return colorToObjectRgbString(value, type);
        };
      }
      const ObjectColorInputPlugin = {
        id: "input-color-object",
        type: "input",
        accept: (value, params) => {
          if (!Color2.isColorObject(value)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => createColorObjectReader(extractColorType(args.params)),
          equals: Color2.equals,
          writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params))
        },
        controller: (args) => {
          var _a2;
          const supportsAlpha = Color2.isRgbaColorObject(args.initialValue);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          const type = (_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int";
          return new ColorController(args.document, {
            colorType: type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createColorObjectFormatter(supportsAlpha, type),
            parser: createColorStringParser(type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const StringColorInputPlugin = {
        id: "input-color-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          if ("view" in params && params.view === "text") {
            return null;
          }
          const format = detectStringColorFormat(value, extractColorType(params));
          if (!format) {
            return null;
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            var _a2;
            return createColorStringBindingReader((_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int");
          },
          equals: Color2.equals,
          writer: (args) => {
            const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
            if (!format) {
              throw TpError.shouldNeverHappen();
            }
            const writer = createColorStringWriter(format);
            if (!writer) {
              throw TpError.notBindable();
            }
            return writer;
          }
        },
        controller: (args) => {
          const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
          if (!format) {
            throw TpError.shouldNeverHappen();
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: format.type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: stringifier,
            parser: createColorStringParser(format.type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha: format.alpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      class PointNdConstraint {
        constructor(config) {
          this.components = config.components;
          this.asm_ = config.assembly;
        }
        constrain(value) {
          const comps = this.asm_.toComponents(value).map((comp, index) => {
            var _a2, _b2;
            return (_b2 = (_a2 = this.components[index]) === null || _a2 === void 0 ? void 0 : _a2.constrain(comp)) !== null && _b2 !== void 0 ? _b2 : comp;
          });
          return this.asm_.fromComponents(comps);
        }
      }
      const className$5 = ClassName("pndtxt");
      class PointNdTextView {
        constructor(doc, config) {
          this.textViews = config.textViews;
          this.element = doc.createElement("div");
          this.element.classList.add(className$5());
          this.textViews.forEach((v4) => {
            const axisElem = doc.createElement("div");
            axisElem.classList.add(className$5("a"));
            axisElem.appendChild(v4.element);
            this.element.appendChild(axisElem);
          });
        }
      }
      function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
          baseStep: config.axes[index].baseStep,
          parser: config.parser,
          props: config.axes[index].textProps,
          value: createValue(0, {
            constraint: config.axes[index].constraint
          }),
          viewProps: config.viewProps
        });
      }
      class PointNdTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
          this.acs_.forEach((c, index) => {
            connectValues({
              primary: this.value,
              secondary: c.value,
              forward: (p) => {
                return config.assembly.toComponents(p.rawValue)[index];
              },
              backward: (p, s) => {
                const comps = config.assembly.toComponents(p.rawValue);
                comps[index] = s.rawValue;
                return config.assembly.fromComponents(comps);
              }
            });
          });
          this.view = new PointNdTextView(doc, {
            textViews: this.acs_.map((ac) => ac.view)
          });
        }
      }
      function createStepConstraint(params, initialValue) {
        if ("step" in params && !isEmpty(params.step)) {
          return new StepConstraint(params.step, initialValue);
        }
        return null;
      }
      function createRangeConstraint(params) {
        if (!isEmpty(params.max) && !isEmpty(params.min)) {
          return new DefiniteRangeConstraint({
            max: params.max,
            min: params.min
          });
        }
        if (!isEmpty(params.max) || !isEmpty(params.min)) {
          return new RangeConstraint({
            max: params.max,
            min: params.min
          });
        }
        return null;
      }
      function findNumberRange(c) {
        const drc = findConstraint(c, DefiniteRangeConstraint);
        if (drc) {
          return [drc.values.get("min"), drc.values.get("max")];
        }
        const rc = findConstraint(c, RangeConstraint);
        if (rc) {
          return [rc.minValue, rc.maxValue];
        }
        return [void 0, void 0];
      }
      function createConstraint$4(params, initialValue) {
        const constraints = [];
        const sc = createStepConstraint(params, initialValue);
        if (sc) {
          constraints.push(sc);
        }
        const rc = createRangeConstraint(params);
        if (rc) {
          constraints.push(rc);
        }
        const lc2 = createListConstraint(params.options);
        if (lc2) {
          constraints.push(lc2);
        }
        return new CompositeConstraint(constraints);
      }
      const NumberInputPlugin = {
        id: "input-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            format: p.optional.function,
            max: p.optional.number,
            min: p.optional.number,
            options: p.optional.custom(parseListOptions),
            step: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => numberFromUnknown,
          constraint: (args) => createConstraint$4(args.params, args.initialValue),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          var _a2;
          const value = args.value;
          const c = args.constraint;
          const lc2 = c && findConstraint(c, ListConstraint);
          if (lc2) {
            return new ListController(args.document, {
              props: new ValueMap({
                options: lc2.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          const formatter = (_a2 = "format" in args.params ? args.params.format : void 0) !== null && _a2 !== void 0 ? _a2 : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
          const drc = c && findConstraint(c, DefiniteRangeConstraint);
          if (drc) {
            return new SliderTextController(args.document, {
              baseStep: getBaseStep(c),
              parser: parseNumber,
              sliderProps: new ValueMap({
                maxValue: drc.values.value("max"),
                minValue: drc.values.value("min")
              }),
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c, value.rawValue),
                formatter
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new NumberTextController(args.document, {
            baseStep: getBaseStep(c),
            parser: parseNumber,
            props: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(c, value.rawValue),
              formatter
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point2d {
        constructor(x = 0, y2 = 0) {
          this.x = x;
          this.y = y2;
        }
        getComponents() {
          return [this.x, this.y];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          if (typeof x !== "number" || typeof y2 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }
      }
      const Point2dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point2d(...comps)
      };
      const className$4 = ClassName("p2d");
      class Point2dView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$4());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$4("h"));
          this.element.appendChild(headElem);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$4("b"));
          buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
          config.viewProps.bindDisabled(buttonElem);
          headElem.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$4("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$4("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      const className$3 = ClassName("p2dp");
      class Point2dPickerView {
        constructor(doc, config) {
          this.onFoldableChange_ = this.onFoldableChange_.bind(this);
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.invertsY_ = config.invertsY;
          this.maxValue_ = config.maxValue;
          this.element = doc.createElement("div");
          this.element.classList.add(className$3());
          if (config.layout === "popup") {
            this.element.classList.add(className$3(void 0, "p"));
          }
          config.viewProps.bindClassModifiers(this.element);
          const padElem = doc.createElement("div");
          padElem.classList.add(className$3("p"));
          config.viewProps.bindTabIndex(padElem);
          this.element.appendChild(padElem);
          this.padElement = padElem;
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className$3("g"));
          this.padElement.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const xAxisElem = doc.createElementNS(SVG_NS, "line");
          xAxisElem.classList.add(className$3("ax"));
          xAxisElem.setAttributeNS(null, "x1", "0");
          xAxisElem.setAttributeNS(null, "y1", "50%");
          xAxisElem.setAttributeNS(null, "x2", "100%");
          xAxisElem.setAttributeNS(null, "y2", "50%");
          this.svgElem_.appendChild(xAxisElem);
          const yAxisElem = doc.createElementNS(SVG_NS, "line");
          yAxisElem.classList.add(className$3("ax"));
          yAxisElem.setAttributeNS(null, "x1", "50%");
          yAxisElem.setAttributeNS(null, "y1", "0");
          yAxisElem.setAttributeNS(null, "x2", "50%");
          yAxisElem.setAttributeNS(null, "y2", "100%");
          this.svgElem_.appendChild(yAxisElem);
          const lineElem = doc.createElementNS(SVG_NS, "line");
          lineElem.classList.add(className$3("l"));
          lineElem.setAttributeNS(null, "x1", "50%");
          lineElem.setAttributeNS(null, "y1", "50%");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$3("m"));
          this.padElement.appendChild(markerElem);
          this.markerElem_ = markerElem;
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        get allFocusableElements() {
          return [this.padElement];
        }
        update_() {
          const [x, y2] = this.value.rawValue.getComponents();
          const max2 = this.maxValue_;
          const px = mapRange(x, -max2, +max2, 0, 100);
          const py = mapRange(y2, -max2, +max2, 0, 100);
          const ipy = this.invertsY_ ? 100 - py : py;
          this.lineElem_.setAttributeNS(null, "x2", `${px}%`);
          this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
          this.markerElem_.style.left = `${px}%`;
          this.markerElem_.style.top = `${ipy}%`;
        }
        onValueChange_() {
          this.update_();
        }
        onFoldableChange_() {
          this.update_();
        }
      }
      function computeOffset(ev, baseSteps, invertsY) {
        return [
          getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
          getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
        ];
      }
      class Point2dPickerController {
        constructor(doc, config) {
          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
          this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.baseSteps_ = config.baseSteps;
          this.maxValue_ = config.maxValue;
          this.invertsY_ = config.invertsY;
          this.view = new Point2dPickerView(doc, {
            invertsY: this.invertsY_,
            layout: config.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.padElement);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
          this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const max2 = this.maxValue_;
          const px = mapRange(d.point.x, 0, d.bounds.width, -max2, +max2);
          const py = mapRange(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max2, +max2);
          this.value.setRawValue(new Point2d(px, py), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onPadKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
            forceEmit: false,
            last: false
          });
        }
        onPadKeyUp_(ev) {
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class Point2dController {
        constructor(doc, config) {
          var _a2, _b2;
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
          this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const padC = new Point2dPickerController(doc, {
            baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
            invertsY: config.invertsY,
            layout: config.pickerLayout,
            maxValue: config.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          padC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = padC;
          this.textC_ = new PointNdTextController(doc, {
            assembly: Point2dAssembly,
            axes: config.axes,
            parser: config.parser,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new Point2dView(doc, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: config.pickerLayout,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.textC_.view.element);
          (_a2 = this.view.buttonElement) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("blur", this.onPadButtonBlur_);
          (_b2 = this.view.buttonElement) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("click", this.onPadButtonClick_);
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(this.pickerC_.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p) => p.rawValue,
              backward: (_, s) => s.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        onPadButtonBlur_(e) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onPadButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.view.buttonElement.focus();
            }
          }
        }
      }
      class Point3d {
        constructor(x = 0, y2 = 0, z2 = 0) {
          this.x = x;
          this.y = y2;
          this.z = z2;
        }
        getComponents() {
          return [this.x, this.y, this.z];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          const z2 = obj.z;
          if (typeof x !== "number" || typeof y2 !== "number" || typeof z2 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y && v12.z === v22.z;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z
          };
        }
      }
      const Point3dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point3d(...comps)
      };
      function point3dFromUnknown(value) {
        return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
      }
      function writePoint3d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
      }
      function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point3dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z)
          ]
        });
      }
      function createAxis$2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point3dInputPlugin = {
        id: "input-point3d",
        type: "input",
        accept: (value, params) => {
          if (!Point3d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point3dFromUnknown,
          constraint: (args) => createConstraint$3(args.params, args.initialValue),
          equals: Point3d.equals,
          writer: (_args) => writePoint3d
        },
        controller: (args) => {
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point3dAssembly,
            axes: [
              createAxis$2(value.rawValue.x, c.components[0]),
              createAxis$2(value.rawValue.y, c.components[1]),
              createAxis$2(value.rawValue.z, c.components[2])
            ],
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point4d {
        constructor(x = 0, y2 = 0, z2 = 0, w = 0) {
          this.x = x;
          this.y = y2;
          this.z = z2;
          this.w = w;
        }
        getComponents() {
          return [this.x, this.y, this.z, this.w];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          const z2 = obj.z;
          const w = obj.w;
          if (typeof x !== "number" || typeof y2 !== "number" || typeof z2 !== "number" || typeof w !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y && v12.z === v22.z && v12.w === v22.w;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
          };
        }
      }
      const Point4dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point4d(...comps)
      };
      function point4dFromUnknown(value) {
        return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
      }
      function writePoint4d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
        target.writeProperty("w", value.w);
      }
      function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point4dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z),
            createDimensionConstraint("w" in params ? params.w : void 0, initialValue.w)
          ]
        });
      }
      function createAxis$1(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point4dInputPlugin = {
        id: "input-point4d",
        type: "input",
        accept: (value, params) => {
          if (!Point4d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams),
            w: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point4dFromUnknown,
          constraint: (args) => createConstraint$2(args.params, args.initialValue),
          equals: Point4d.equals,
          writer: (_args) => writePoint4d
        },
        controller: (args) => {
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point4dAssembly,
            axes: value.rawValue.getComponents().map((comp, index) => createAxis$1(comp, c.components[index])),
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      function createConstraint$1(params) {
        const constraints = [];
        const lc2 = createListConstraint(params.options);
        if (lc2) {
          constraints.push(lc2);
        }
        return new CompositeConstraint(constraints);
      }
      const StringInputPlugin = {
        id: "input-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown,
          constraint: (args) => createConstraint$1(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          const lc2 = c && findConstraint(c, ListConstraint);
          if (lc2) {
            return new ListController(doc, {
              props: new ValueMap({
                options: lc2.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new TextController(doc, {
            parser: (v4) => v4,
            props: ValueMap.fromObject({
              formatter: formatString
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      const Constants = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      };
      const className$2 = ClassName("mll");
      class MultiLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$2());
          config.viewProps.bindClassModifiers(this.element);
          const textareaElem = doc.createElement("textarea");
          textareaElem.classList.add(className$2("i"));
          textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          textareaElem.readOnly = true;
          config.viewProps.bindDisabled(textareaElem);
          this.element.appendChild(textareaElem);
          this.textareaElem_ = textareaElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const elem = this.textareaElem_;
          const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
          const lines = [];
          this.value.rawValue.forEach((value) => {
            if (value !== void 0) {
              lines.push(this.formatter_(value));
            }
          });
          elem.textContent = lines.join("\n");
          if (shouldScroll) {
            elem.scrollTop = elem.scrollHeight;
          }
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class MultiLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new MultiLogView(doc, {
            formatter: config.formatter,
            lineCount: config.lineCount,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const className$1 = ClassName("sgl");
      class SingleLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$1());
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$1("i"));
          inputElem.readOnly = true;
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const values = this.value.rawValue;
          const lastValue = values[values.length - 1];
          this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class SingleLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SingleLogView(doc, {
            formatter: config.formatter,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const BooleanMonitorPlugin = {
        id: "monitor-bool",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown
        },
        controller: (args) => {
          var _a2;
          if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
              formatter: BooleanFormatter,
              value: args.value,
              viewProps: args.viewProps
            });
          }
          return new MultiLogController(args.document, {
            formatter: BooleanFormatter,
            lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const className = ClassName("grl");
      class GraphLogView {
        constructor(doc, config) {
          this.onCursorChange_ = this.onCursorChange_.bind(this);
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className());
          config.viewProps.bindClassModifiers(this.element);
          this.formatter_ = config.formatter;
          this.props_ = config.props;
          this.cursor_ = config.cursor;
          this.cursor_.emitter.on("change", this.onCursorChange_);
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className("g"));
          svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const lineElem = doc.createElementNS(SVG_NS, "polyline");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(className("t"), ClassName("tt")());
          this.element.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        get graphElement() {
          return this.svgElem_;
        }
        update_() {
          const bounds = this.svgElem_.getBoundingClientRect();
          const maxIndex = this.value.rawValue.length - 1;
          const min = this.props_.get("minValue");
          const max2 = this.props_.get("maxValue");
          const points = [];
          this.value.rawValue.forEach((v4, index) => {
            if (v4 === void 0) {
              return;
            }
            const x = mapRange(index, 0, maxIndex, 0, bounds.width);
            const y2 = mapRange(v4, min, max2, bounds.height, 0);
            points.push([x, y2].join(","));
          });
          this.lineElem_.setAttributeNS(null, "points", points.join(" "));
          const tooltipElem = this.tooltipElem_;
          const value = this.value.rawValue[this.cursor_.rawValue];
          if (value === void 0) {
            tooltipElem.classList.remove(className("t", "a"));
            return;
          }
          const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
          const ty = mapRange(value, min, max2, bounds.height, 0);
          tooltipElem.style.left = `${tx}px`;
          tooltipElem.style.top = `${ty}px`;
          tooltipElem.textContent = `${this.formatter_(value)}`;
          if (!tooltipElem.classList.contains(className("t", "a"))) {
            tooltipElem.classList.add(className("t", "a"), className("t", "in"));
            forceReflow(tooltipElem);
            tooltipElem.classList.remove(className("t", "in"));
          }
        }
        onValueUpdate_() {
          this.update_();
        }
        onCursorChange_() {
          this.update_();
        }
      }
      class GraphLogController {
        constructor(doc, config) {
          this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
          this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
          this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
          this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
          this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
          this.props_ = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.cursor_ = createValue(-1);
          this.view = new GraphLogView(doc, {
            cursor: this.cursor_,
            formatter: config.formatter,
            lineCount: config.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          });
          if (!supportsTouch(doc)) {
            this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
            this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
          } else {
            const ph = new PointerHandler(this.view.element);
            ph.emitter.on("down", this.onGraphPointerDown_);
            ph.emitter.on("move", this.onGraphPointerMove_);
            ph.emitter.on("up", this.onGraphPointerUp_);
          }
        }
        onGraphMouseLeave_() {
          this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(ev) {
          const bounds = this.view.element.getBoundingClientRect();
          this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(ev) {
          this.onGraphPointerMove_(ev);
        }
        onGraphPointerMove_(ev) {
          if (!ev.data.point) {
            this.cursor_.rawValue = -1;
            return;
          }
          this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
          this.cursor_.rawValue = -1;
        }
      }
      function createFormatter(params) {
        return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
      }
      function createTextMonitor(args) {
        var _a2;
        if (args.value.rawValue.length === 1) {
          return new SingleLogController(args.document, {
            formatter: createFormatter(args.params),
            value: args.value,
            viewProps: args.viewProps
          });
        }
        return new MultiLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function createGraphMonitor(args) {
        var _a2, _b2, _c;
        return new GraphLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
          props: ValueMap.fromObject({
            maxValue: (_b2 = "max" in args.params ? args.params.max : null) !== null && _b2 !== void 0 ? _b2 : 100,
            minValue: (_c = "min" in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0
          }),
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function shouldShowGraph(params) {
        return "view" in params && params.view === "graph";
      }
      const NumberMonitorPlugin = {
        id: "monitor-number",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            format: p.optional.function,
            lineCount: p.optional.number,
            max: p.optional.number,
            min: p.optional.number,
            view: p.optional.string
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
          reader: (_args) => numberFromUnknown
        },
        controller: (args) => {
          if (shouldShowGraph(args.params)) {
            return createGraphMonitor(args);
          }
          return createTextMonitor(args);
        }
      };
      const StringMonitorPlugin = {
        id: "monitor-string",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p.optional.number,
            multiline: p.optional.boolean
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown
        },
        controller: (args) => {
          var _a2;
          const value = args.value;
          const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
          if (multiline) {
            return new MultiLogController(args.document, {
              formatter: formatString,
              lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
              value,
              viewProps: args.viewProps
            });
          }
          return new SingleLogController(args.document, {
            formatter: formatString,
            value,
            viewProps: args.viewProps
          });
        }
      };
      function createInputBindingController(plugin, args) {
        var _a2;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const p = ParamsParsers;
        const valueArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(valueArgs);
        const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
        const value = createValue(reader(result.initialValue), {
          constraint,
          equals: plugin.binding.equals
        });
        const binding = new InputBinding({
          reader,
          target: args.target,
          value,
          writer: plugin.binding.writer(valueArgs)
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          constraint,
          document: args.document,
          initialValue: result.initialValue,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        return new InputBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: "label" in args.params ? (_a2 = p.optional.string(args.params.label).value) !== null && _a2 !== void 0 ? _a2 : null : args.target.key
          }),
          valueController: controller
        });
      }
      function createTicker(document2, interval) {
        return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
      }
      function createMonitorBindingController(plugin, args) {
        var _a2, _b2, _c;
        const p = ParamsParsers;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const bindingArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(bindingArgs);
        const bufferSize = (_b2 = (_a2 = p.optional.number(args.params.bufferSize).value) !== null && _a2 !== void 0 ? _a2 : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b2 !== void 0 ? _b2 : 1;
        const interval = p.optional.number(args.params.interval).value;
        const binding = new MonitorBinding({
          reader,
          target: args.target,
          ticker: createTicker(args.document, interval),
          value: initializeBuffer(bufferSize)
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          document: args.document,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        return new MonitorBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: "label" in args.params ? (_c = p.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : null : args.target.key
          }),
          valueController: controller
        });
      }
      class PluginPool {
        constructor() {
          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }
        getAll() {
          return [
            ...this.pluginsMap_.blades,
            ...this.pluginsMap_.inputs,
            ...this.pluginsMap_.monitors
          ];
        }
        register(r) {
          if (r.type === "blade") {
            this.pluginsMap_.blades.unshift(r);
          } else if (r.type === "input") {
            this.pluginsMap_.inputs.unshift(r);
          } else if (r.type === "monitor") {
            this.pluginsMap_.monitors.unshift(r);
          }
        }
        createInput(document2, target, params) {
          const initialValue = target.read();
          if (isEmpty(initialValue)) {
            throw new TpError({
              context: {
                key: target.key
              },
              type: "nomatchingcontroller"
            });
          }
          const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
            document: document2,
            target,
            params
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createMonitor(document2, target, params) {
          const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
            document: document2,
            params,
            target
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createBlade(document2, params) {
          const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
            document: document2,
            params
          }), null);
          if (!bc) {
            throw new TpError({
              type: "nomatchingview",
              context: {
                params
              }
            });
          }
          return bc;
        }
        createBladeApi(bc) {
          if (bc instanceof InputBindingController) {
            return new InputBindingApi(bc);
          }
          if (bc instanceof MonitorBindingController) {
            return new MonitorBindingApi(bc);
          }
          if (bc instanceof RackController) {
            return new RackApi(bc, this);
          }
          const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
            controller: bc,
            pool: this
          }), null);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
      }
      function createDefaultPluginPool() {
        const pool = new PluginPool();
        [
          Point2dInputPlugin,
          Point3dInputPlugin,
          Point4dInputPlugin,
          StringInputPlugin,
          NumberInputPlugin,
          StringColorInputPlugin,
          ObjectColorInputPlugin,
          NumberColorInputPlugin,
          BooleanInputPlugin,
          BooleanMonitorPlugin,
          StringMonitorPlugin,
          NumberMonitorPlugin,
          ButtonBladePlugin,
          FolderBladePlugin,
          SeparatorBladePlugin,
          TabBladePlugin
        ].forEach((p) => {
          pool.register(p);
        });
        return pool;
      }
      function point2dFromUnknown(value) {
        return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
      }
      function writePoint2d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
      }
      function createDimensionConstraint(params, initialValue) {
        if (!params) {
          return void 0;
        }
        const constraints = [];
        const cs = createStepConstraint(params, initialValue);
        if (cs) {
          constraints.push(cs);
        }
        const rs = createRangeConstraint(params);
        if (rs) {
          constraints.push(rs);
        }
        return new CompositeConstraint(constraints);
      }
      function createConstraint(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point2dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y)
          ]
        });
      }
      function getSuitableMaxDimensionValue(constraint, rawValue) {
        const [min, max2] = constraint ? findNumberRange(constraint) : [];
        if (!isEmpty(min) || !isEmpty(max2)) {
          return Math.max(Math.abs(min !== null && min !== void 0 ? min : 0), Math.abs(max2 !== null && max2 !== void 0 ? max2 : 0));
        }
        const step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
      }
      function getSuitableMaxValue(initialValue, constraint) {
        const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
        const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
        const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
      }
      function createAxis2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      function shouldInvertY(params) {
        if (!("y" in params)) {
          return false;
        }
        const yParams = params.y;
        if (!yParams) {
          return false;
        }
        return "inverted" in yParams ? !!yParams.inverted : false;
      }
      const Point2dInputPlugin = {
        id: "input-point2d",
        type: "input",
        accept: (value, params) => {
          if (!Point2d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            expanded: p.optional.boolean,
            picker: p.optional.custom(parsePickerLayout),
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.object({
              inverted: p.optional.boolean,
              max: p.optional.number,
              min: p.optional.number,
              step: p.optional.number
            })
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point2dFromUnknown,
          constraint: (args) => createConstraint(args.params, args.initialValue),
          equals: Point2d.equals,
          writer: (_args) => writePoint2d
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new Point2dController(doc, {
            axes: [
              createAxis2(value.rawValue.x, c.components[0]),
              createAxis2(value.rawValue.y, c.components[1])
            ],
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            invertsY: shouldInvertY(args.params),
            maxValue: getSuitableMaxValue(value.rawValue, c),
            parser: parseNumber,
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            value,
            viewProps: args.viewProps
          });
        }
      };
      class ListApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get options() {
          return this.controller_.valueController.props.get("options");
        }
        set options(options) {
          this.controller_.valueController.props.set("options", options);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class SliderApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get maxValue() {
          return this.controller_.valueController.sliderController.props.get("maxValue");
        }
        set maxValue(maxValue) {
          this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
        }
        get minValue() {
          return this.controller_.valueController.sliderController.props.get("minValue");
        }
        set minValue(minValue) {
          this.controller_.valueController.sliderController.props.set("minValue", minValue);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class TextApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get formatter() {
          return this.controller_.valueController.props.get("formatter");
        }
        set formatter(formatter) {
          this.controller_.valueController.props.set("formatter", formatter);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      const ListBladePlugin = /* @__PURE__ */ function() {
        return {
          id: "list",
          type: "blade",
          accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
              options: p.required.custom(parseListOptions),
              value: p.required.raw,
              view: p.required.constant("list"),
              label: p.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            const lc2 = new ListConstraint(normalizeListOptions(args.params.options));
            const value = createValue(args.params.value, {
              constraint: lc2
            });
            const ic = new ListController(args.document, {
              props: new ValueMap({
                options: lc2.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof ListController)) {
              return null;
            }
            return new ListApi(args.controller);
          }
        };
      }();
      function exportPresetJson(targets) {
        return targets.reduce((result, target) => {
          return Object.assign(result, {
            [target.presetKey]: target.read()
          });
        }, {});
      }
      function importPresetJson(bindings, preset) {
        bindings.forEach((binding) => {
          const value = preset[binding.target.presetKey];
          if (value !== void 0) {
            binding.writer(binding.target, binding.reader(value));
          }
        });
      }
      class RootApi extends FolderApi {
        /**
         * @hidden
         */
        constructor(controller, pool) {
          super(controller, pool);
        }
        get element() {
          return this.controller_.view.element;
        }
        /**
         * Imports a preset of all inputs.
         * @param preset The preset object to import.
         */
        importPreset(preset) {
          const bindings = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding;
          });
          importPresetJson(bindings, preset);
          this.refresh();
        }
        /**
         * Exports a preset of all inputs.
         * @return An exported preset object.
         */
        exportPreset() {
          const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding.target;
          });
          return exportPresetJson(targets);
        }
        /**
         * Refreshes all bindings of the pane.
         */
        refresh() {
          this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
            ibc.binding.read();
          });
          this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
            mbc.binding.read();
          });
        }
      }
      class RootController extends FolderController {
        constructor(doc, config) {
          super(doc, {
            expanded: config.expanded,
            blade: config.blade,
            props: config.props,
            root: true,
            viewProps: config.viewProps
          });
        }
      }
      const SliderBladePlugin = {
        id: "slider",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            max: p.required.number,
            min: p.required.number,
            view: p.required.constant("slider"),
            format: p.optional.function,
            label: p.optional.string,
            value: p.optional.number
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          var _a2, _b2;
          const initialValue = (_a2 = args.params.value) !== null && _a2 !== void 0 ? _a2 : 0;
          const drc = new DefiniteRangeConstraint({
            max: args.params.max,
            min: args.params.min
          });
          const vc = new SliderTextController(args.document, {
            baseStep: 1,
            parser: parseNumber,
            sliderProps: new ValueMap({
              maxValue: drc.values.value("max"),
              minValue: drc.values.value("min")
            }),
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(void 0, initialValue),
              formatter: (_b2 = args.params.format) !== null && _b2 !== void 0 ? _b2 : numberToString
            }),
            value: createValue(initialValue, {
              constraint: drc
            }),
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: vc
          });
        },
        api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof SliderTextController)) {
            return null;
          }
          return new SliderApi(args.controller);
        }
      };
      const TextBladePlugin = /* @__PURE__ */ function() {
        return {
          id: "text",
          type: "blade",
          accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
              parse: p.required.function,
              value: p.required.raw,
              view: p.required.constant("text"),
              format: p.optional.function,
              label: p.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            var _a2;
            const ic = new TextController(args.document, {
              parser: args.params.parse,
              props: ValueMap.fromObject({
                formatter: (_a2 = args.params.format) !== null && _a2 !== void 0 ? _a2 : (v4) => String(v4)
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof TextController)) {
              return null;
            }
            return new TextApi(args.controller);
          }
        };
      }();
      function createDefaultWrapperElement(doc) {
        const elem = doc.createElement("div");
        elem.classList.add(ClassName("dfw")());
        if (doc.body) {
          doc.body.appendChild(elem);
        }
        return elem;
      }
      function embedStyle(doc, id, css) {
        if (doc.querySelector(`style[data-tp-style=${id}]`)) {
          return;
        }
        const styleElem = doc.createElement("style");
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
      }
      class Pane2 extends RootApi {
        constructor(opt_config) {
          var _a2, _b2;
          const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
          const doc = (_a2 = config.document) !== null && _a2 !== void 0 ? _a2 : getWindowDocument();
          const pool = createDefaultPluginPool();
          const rootController = new RootController(doc, {
            expanded: config.expanded,
            blade: createBlade(),
            props: ValueMap.fromObject({
              title: config.title
            }),
            viewProps: ViewProps.create()
          });
          super(rootController, pool);
          this.pool_ = pool;
          this.containerElem_ = (_b2 = config.container) !== null && _b2 !== void 0 ? _b2 : createDefaultWrapperElement(doc);
          this.containerElem_.appendChild(this.element);
          this.doc_ = doc;
          this.usesDefaultWrapper_ = !config.container;
          this.setUpDefaultPlugins_();
        }
        get document() {
          if (!this.doc_) {
            throw TpError.alreadyDisposed();
          }
          return this.doc_;
        }
        dispose() {
          const containerElem = this.containerElem_;
          if (!containerElem) {
            throw TpError.alreadyDisposed();
          }
          if (this.usesDefaultWrapper_) {
            const parentElem = containerElem.parentElement;
            if (parentElem) {
              parentElem.removeChild(containerElem);
            }
          }
          this.containerElem_ = null;
          this.doc_ = null;
          super.dispose();
        }
        registerPlugin(bundle) {
          const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
          plugins.forEach((p) => {
            this.pool_.register(p);
            this.embedPluginStyle_(p);
          });
        }
        embedPluginStyle_(plugin) {
          if (plugin.css) {
            embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
          }
        }
        setUpDefaultPlugins_() {
          embedStyle(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
          this.pool_.getAll().forEach((plugin) => {
            this.embedPluginStyle_(plugin);
          });
          this.registerPlugin({
            plugins: [
              SliderBladePlugin,
              ListBladePlugin,
              TabBladePlugin,
              TextBladePlugin
            ]
          });
        }
      }
      const VERSION = new Semver("3.1.10");
      exports2.BladeApi = BladeApi;
      exports2.ButtonApi = ButtonApi;
      exports2.FolderApi = FolderApi;
      exports2.InputBindingApi = InputBindingApi;
      exports2.ListApi = ListApi;
      exports2.MonitorBindingApi = MonitorBindingApi;
      exports2.Pane = Pane2;
      exports2.SeparatorApi = SeparatorApi;
      exports2.SliderApi = SliderApi;
      exports2.TabApi = TabApi;
      exports2.TabPageApi = TabPageApi;
      exports2.TextApi = TextApi;
      exports2.TpChangeEvent = TpChangeEvent;
      exports2.VERSION = VERSION;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@threlte/extras/dist/hooks/useCursor.js
var useCursor = (onPointerOver = "pointer", onPointerOut = "auto", target = void 0) => {
  let hovering = false;
  const hoveringStore = writable(false);
  const onPointerEnter = () => {
    hoveringStore.set(true);
  };
  const onPointerLeave = () => {
    hoveringStore.set(false);
  };
  if (typeof window === "undefined") {
    return {
      hovering: hoveringStore,
      onPointerEnter,
      onPointerLeave
    };
  }
  const el2 = target ?? document.body;
  let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get2(onPointerOver);
  if (typeof onPointerOver !== "string") {
    watch(onPointerOver, (cursorStyle) => {
      onPointerOverValue = cursorStyle;
      if (hovering) {
        el2.style.cursor = cursorStyle;
      }
    });
  }
  let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get2(onPointerOut);
  if (typeof onPointerOut !== "string") {
    watch(onPointerOut, (cursorStyle) => {
      onPointerOutValue = cursorStyle;
      if (!hovering) {
        el2.style.cursor = cursorStyle;
      }
    });
  }
  watch(hoveringStore, (isHovering) => {
    hovering = isHovering;
    if (hovering) {
      el2.style.cursor = onPointerOverValue;
    } else {
      el2.style.cursor = onPointerOutValue;
    }
  });
  onDestroy(() => {
    el2.style.cursor = onPointerOutValue;
  });
  return {
    hovering: hoveringStore,
    onPointerEnter,
    onPointerLeave
  };
};

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position2 = geometry.getAttribute("position");
      if (position2 !== void 0) {
        for (let i = 0; i < position2.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
  const creaseDot = Math.cos(creaseAngle);
  const hashMultiplier = (1 + 1e-10) * 100;
  const verts = [new Vector3(), new Vector3(), new Vector3()];
  const tempVec1 = new Vector3();
  const tempVec2 = new Vector3();
  const tempNorm = new Vector3();
  const tempNorm2 = new Vector3();
  function hashVertex(v4) {
    const x = ~~(v4.x * hashMultiplier);
    const y2 = ~~(v4.y * hashMultiplier);
    const z2 = ~~(v4.z * hashMultiplier);
    return `${x},${y2},${z2}`;
  }
  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttr = resultGeometry.attributes.position;
  const vertexMap = {};
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();
    for (let n2 = 0; n2 < 3; n2++) {
      const vert = verts[n2];
      const hash = hashVertex(vert);
      if (!(hash in vertexMap)) {
        vertexMap[hash] = [];
      }
      vertexMap[hash].push(normal);
    }
  }
  const normalArray = new Float32Array(posAttr.count * 3);
  const normAttr = new BufferAttribute(normalArray, 3, false);
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    tempNorm.crossVectors(tempVec1, tempVec2).normalize();
    for (let n2 = 0; n2 < 3; n2++) {
      const vert = verts[n2];
      const hash = hashVertex(vert);
      const otherNormals = vertexMap[hash];
      tempNorm2.set(0, 0, 0);
      for (let k = 0, lk = otherNormals.length; k < lk; k++) {
        const otherNorm = otherNormals[k];
        if (tempNorm.dot(otherNorm) > creaseDot) {
          tempNorm2.add(otherNorm);
        }
      }
      tempNorm2.normalize();
      normAttr.setXYZ(i3 + n2, tempNorm2.x, tempNorm2.y, tempNorm2.z);
    }
  }
  resultGeometry.setAttribute("normal", normAttr);
  return resultGeometry;
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError2) {
        onError2(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad2(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad2, onError2) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError2) onError2(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError2) onError2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad2, onError2);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key2) {
      return objects[key2];
    },
    add: function(key2, object) {
      objects[key2] = object;
    },
    remove: function(key2) {
      delete objects[key2];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color2 = new Color(16777215);
    if (lightDef.color !== void 0) color2.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color2);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color2);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color2);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light") return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key2 in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key2]).then((accessor) => {
        attributes[key2] = accessor;
        return attributes[key2];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q2 = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q2.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q2, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td2 = t1 - t0;
    const p = (t2 - t0) / td2;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td2;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td2;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  if (uri.search(/\.ktx2($|\?)/i) > 0 || uri.search(/^data\:image\/ktx2/) === 0) return "image/ktx2";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad2, onError2) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad2(result);
      });
    }).catch(onError2);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(cache, index) {
    if (index === void 0) return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @param {Object} cache
   * @param {Number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child2] of original.children.entries()) {
        updateMappings(child2, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad2 = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad2 = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad2, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} colorSpace
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @param {String} originalName
   * @return {String}
   */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0) continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh) return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key2, value] of parser.associations) {
          if (key2 instanceof Material || key2 instanceof Texture) {
            reducedAssociations.set(key2, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
      const track = new TypedKeyframeTrack(
        targetNames[j2] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
        scaled[j2] = outputArray[j2] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max2 = accessor.max;
    if (min !== void 0 && max2 !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max2[0], max2[1], max2[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max2 = accessor.max;
        if (min !== void 0 && max2 !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max2[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max2[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max2[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere2 = new Sphere();
  box.getCenter(sphere2.center);
  sphere2.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere2;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/@threlte/extras/dist/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
function useGltf(urlOrOptions, options) {
  const opts = typeof urlOrOptions === "string" ? options : urlOrOptions;
  const loader = useLoader(GLTFLoader, {
    extend(loader2) {
      if (opts == null ? void 0 : opts.dracoLoader) {
        loader2.setDRACOLoader(opts.dracoLoader);
      }
      if (opts == null ? void 0 : opts.meshoptDecoder) {
        loader2.setMeshoptDecoder(opts.meshoptDecoder);
      }
      if (opts == null ? void 0 : opts.ktx2Loader) {
        loader2.setKTX2Loader(opts.ktx2Loader);
      }
    }
  });
  const load = (url2) => {
    return loader.load(url2, {
      transform(result) {
        return {
          ...result,
          ...buildSceneGraph(result.scene)
        };
      }
    });
  };
  const url = typeof urlOrOptions === "string" ? urlOrOptions : void 0;
  if (url) {
    return load(url);
  } else {
    return {
      load
    };
  }
}

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad2, onProgress, onError2) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad2, onError2);
    }, onProgress, onError2);
  }
  parse(buffer, onLoad2, onError2 = () => {
  }) {
    this.decodeDracoFile(buffer, onLoad2, null, null, SRGBColorSpace, onError2).catch(onError2);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError2 = () => {
  }) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError2);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace) return;
    const _color = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color.fromBufferAttribute(attribute, i);
      ColorManagement.toWorkingColorSpace(_color, SRGBColorSpace);
      attribute.setXYZ(i, _color.r, _color.g, _color.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index) buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1) continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/@threlte/extras/dist/hooks/useDraco.js
var defaultPath = "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
var dracoLoaderInstances = {};
var useDraco = (decoderPath = defaultPath) => {
  const cachedLoader = dracoLoaderInstances[decoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const loader = new DRACOLoader().setDecoderPath(decoderPath);
  dracoLoaderInstances[decoderPath] = loader;
  return loader;
};

// node_modules/three/examples/jsm/libs/meshopt_decoder.module.js
var MeshoptDecoder = function() {
  "use strict";
  var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
  var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
  var instance;
  var ready = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
    instance = result.instance;
    instance.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    var result = new Uint8Array(data.length);
    for (var i = 0; i < data.length; ++i) {
      var ch3 = data.charCodeAt(i);
      result[i] = ch3 > 96 ? ch3 - 97 : ch3 > 64 ? ch3 - 39 : ch3 + 4;
    }
    var write = 0;
    for (var i = 0; i < data.length; ++i) {
      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
    }
    return result.buffer.slice(0, write);
  }
  function decode(fun, target, count, size, source, filter) {
    var sbrk = instance.exports.sbrk;
    var count4 = count + 3 & ~3;
    var tp = sbrk(count4 * size);
    var sp = sbrk(source.length);
    var heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    var res = fun(tp, count, size, sp, source.length);
    if (res == 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res != 0) {
      throw new Error("Malformed buffer data: " + res);
    }
  }
  var filters = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var decoders = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  var workers3 = [];
  var requestId = 0;
  function createWorker(url) {
    var worker = {
      object: new Worker(url),
      pending: 0,
      requests: {}
    };
    worker.object.onmessage = function(event) {
      var data = event.data;
      worker.pending -= data.count;
      worker.requests[data.id][data.action](data.value);
      delete worker.requests[data.id];
    };
    return worker;
  }
  function initWorkers(count) {
    var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + decode.toString() + workerProcess.toString();
    var blob = new Blob([source], { type: "text/javascript" });
    var url = URL.createObjectURL(blob);
    for (var i = 0; i < count; ++i) {
      workers3[i] = createWorker(url);
    }
    URL.revokeObjectURL(url);
  }
  function decodeWorker(count, size, source, mode, filter) {
    var worker = workers3[0];
    for (var i = 1; i < workers3.length; ++i) {
      if (workers3[i].pending < worker.pending) {
        worker = workers3[i];
      }
    }
    return new Promise(function(resolve, reject) {
      var data = new Uint8Array(source);
      var id = requestId++;
      worker.pending += count;
      worker.requests[id] = { resolve, reject };
      worker.object.postMessage({ id, count, size, source: data, mode, filter }, [data.buffer]);
    });
  }
  function workerProcess(event) {
    ready.then(function() {
      var data = event.data;
      try {
        var target = new Uint8Array(data.count * data.size);
        decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
        self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);
      } catch (error) {
        self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
      }
    });
  }
  return {
    ready,
    supported: true,
    useWorkers: function(count) {
      initWorkers(count);
    },
    decodeVertexBuffer: function(target, count, size, source, filter) {
      decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeIndexBuffer: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
    },
    decodeIndexSequence: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
    },
    decodeGltfBuffer: function(target, count, size, source, mode, filter) {
      decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeGltfBufferAsync: function(count, size, source, mode, filter) {
      if (workers3.length > 0) {
        return decodeWorker(count, size, source, decoders[mode], filters[filter]);
      }
      return ready.then(function() {
        var target = new Uint8Array(count * size);
        decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
        return target;
      });
    }
  };
}();

// node_modules/@threlte/extras/dist/hooks/useMeshopt.js
var useMeshopt = () => {
  return MeshoptDecoder;
};

// node_modules/three/examples/jsm/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i)) return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/three/examples/jsm/libs/ktx-parse.module.js
var t = 0;
var n = 2;
var g = 1;
var u = 2;
var T2 = 0;
var C = 1;
var R = 10;
var it = 0;
var ct = 9;
var yt = 15;
var xt = 16;
var wt = 22;
var Ft = 37;
var Ct = 43;
var te = 76;
var ae = 83;
var ge = 97;
var ue = 100;
var we = 103;
var Ae = 109;
var In = 165;
var Sn = 166;
var pi = 1000066e3;
var Ii = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Si = class {
  constructor(t2, e, n2, i) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint8Array(t2) {
    const e = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, t2);
    return this._offset += t2, e;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e) {
    void 0 === e && (e = 0);
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; ) i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Fi = new Uint8Array([0]);
var Oi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ti(t2) {
  return new TextDecoder().decode(t2);
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Oi.length);
  if (e[0] !== Oi[0] || e[1] !== Oi[1] || e[2] !== Oi[2] || e[3] !== Oi[3] || e[4] !== Oi[4] || e[5] !== Oi[5] || e[6] !== Oi[6] || e[7] !== Oi[7] || e[8] !== Oi[8] || e[9] !== Oi[9] || e[10] !== Oi[10] || e[11] !== Oi[11]) throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Ii(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Si(t2, Oi.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), h = s._nextUint64(), U2 = s._nextUint64(), c = new Si(t2, Oi.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++) n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + c._nextUint64(), c._nextUint64()), uncompressedByteLength: c._nextUint64() });
  const _ = new Si(t2, r, o, true), p = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g4 = (p.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g4; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p);
  const y2 = new Si(t2, l, f, true);
  for (; y2._offset < f; ) {
    const t3 = y2._nextUint32(), e2 = y2._scan(t3), i2 = Ti(e2);
    if (n2.keyValue[i2] = y2._nextUint8Array(t3 - e2.byteLength - 1), i2.match(/^ktx/i)) {
      const t4 = Ti(n2.keyValue[i2]);
      n2.keyValue[i2] = t4.substring(0, t4.lastIndexOf("\0"));
    }
    y2._skip(t3 % 4 ? 4 - t3 % 4 : 0);
  }
  if (U2 <= 0) return n2;
  const x = new Si(t2, h, U2, true), u2 = x._nextUint16(), b = x._nextUint16(), d = x._nextUint32(), w = x._nextUint32(), m = x._nextUint32(), D2 = x._nextUint32(), B3 = [];
  for (let t3 = 0; t3 < a; t3++) B3.push({ imageFlags: x._nextUint32(), rgbSliceByteOffset: x._nextUint32(), rgbSliceByteLength: x._nextUint32(), alphaSliceByteOffset: x._nextUint32(), alphaSliceByteLength: x._nextUint32() });
  const L = h + x._offset, v4 = L + d, A3 = v4 + w, k = A3 + m, V2 = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I4 = new Uint8Array(t2.buffer, t2.byteOffset + v4, w), S = new Uint8Array(t2.buffer, t2.byteOffset + A3, m), F3 = new Uint8Array(t2.buffer, t2.byteOffset + k, D2);
  return n2.globalData = { endpointCount: u2, selectorCount: b, imageDescs: B3, endpointsData: V2, selectorsData: I4, tablesData: S, extendedData: F3 }, n2;
}

// node_modules/three/examples/jsm/libs/zstddec.module.js
var A;
var I;
var B;
var g2 = { env: { emscripten_notify_memory_growth: function(A3) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C2).then((A3) => A3.arrayBuffer()).then((A3) => WebAssembly.instantiate(A3, g2)).then(this._init) : WebAssembly.instantiate(Buffer.from(C2, "base64"), g2).then(this._init), A);
  }
  _init(A3) {
    I = A3.instance, g2.env.emscripten_notify_memory_growth(0);
  }
  decode(A3, g4 = 0) {
    if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A3.byteLength, C3 = I.exports.malloc(Q2);
    B.set(A3, C3), g4 = g4 || Number(I.exports.ZSTD_findDecompressedSize(C3, Q2));
    const E3 = I.exports.malloc(g4), i = I.exports.ZSTD_decompress(E3, g4, C3, Q2), D2 = B.slice(E3, E3 + i);
    return I.exports.free(C3), I.exports.free(E3), D2;
  }
};
var C2 = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three/examples/jsm/math/ColorSpaces.js
var LINEAR_DISPLAY_P3_TO_XYZ = new Matrix3().set(
  0.4865709,
  0.2656677,
  0.1982173,
  0.2289746,
  0.6917385,
  0.0792869,
  0,
  0.0451134,
  1.0439444
);
var XYZ_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
  2.4934969,
  -0.9313836,
  -0.4027108,
  -0.829489,
  1.7626641,
  0.0236247,
  0.0358458,
  -0.0761724,
  0.9568845
);
var DisplayP3ColorSpace = "display-p3";
var LinearDisplayP3ColorSpace = "display-p3-linear";
var LINEAR_REC2020_TO_XYZ = new Matrix3().set(
  0.636958,
  0.1446169,
  0.168881,
  0.2627002,
  0.6779981,
  0.0593017,
  0,
  0.0280727,
  1.0609851
);
var XYZ_TO_LINEAR_REC2020 = new Matrix3().set(
  1.7166512,
  -0.3556708,
  -0.2533663,
  -0.6666844,
  1.6164812,
  0.0157685,
  0.0176399,
  -0.0427706,
  0.9421031
);

// node_modules/three/examples/jsm/loaders/KTX2Loader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class _KTX2Loader extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  async detectSupportAsync(renderer) {
    this.workerConfig = {
      astcSupported: await renderer.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: false,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: await renderer.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await renderer.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await renderer.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await renderer.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await renderer.hasFeatureAsync("texture-compression-pvrtc")
    };
    return this;
  }
  detectSupport(renderer) {
    if (renderer.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer.hasFeature("texture-compression-astc"),
        astcHDRSupported: false,
        // https://github.com/gpuweb/gpuweb/issues/3856
        etc1Supported: renderer.hasFeature("texture-compression-etc1"),
        etc2Supported: renderer.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer.hasFeature("texture-compression-bc"),
        bptcSupported: renderer.hasFeature("texture-compression-bptc"),
        pvrtcSupported: renderer.hasFeature("texture-compression-pvrtc")
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
        astcHDRSupported: renderer.extensions.has("WEBGL_compressed_texture_astc") && renderer.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
        etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = _KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat),
          "let _EngineType = " + JSON.stringify(_KTX2Loader.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad2, onProgress, onError2) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad2, onError2);
    }, onProgress, onError2);
  }
  parse(buffer, onLoad2, onError2) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    if (_taskCache2.has(buffer)) {
      const cachedTask = _taskCache2.get(buffer);
      return cachedTask.promise.then(onLoad2).catch(onError2);
    }
    this._createTexture(buffer).then((texture) => onLoad2 ? onLoad2(texture) : null).catch(onError2);
  }
  _createTextureFrom(transcodeResult, container) {
    const { type: messageType, error, data: { faces, width, height, format, type, dfdFlags } } = transcodeResult;
    if (messageType === "error") return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedCubeTexture(faces, format, type);
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, type) : new CompressedTexture(mipmaps, width, height, format, type);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = parseColorSpace(container);
    texture.premultiplyAlpha = !!(dfdFlags & g);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config = {}) {
    const container = Pi(new Uint8Array(buffer));
    const isBasisHDR = container.vkFormat === pi && container.dataFormatDescriptor[0].colorModel === 167;
    const needsTranscoder = container.vkFormat === it || isBasisHDR && !this.workerConfig.astcHDRSupported;
    if (!needsTranscoder) {
      return createRawTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache2.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format
};
KTX2Loader.EngineType = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const EngineType = _EngineType;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init2(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, type, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, data: { faces, width, height, hasAlpha, format, type, dfdFlags } }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init2(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    let basisFormat;
    if (ktx2File.isUASTC()) {
      basisFormat = BasisFormat.UASTC;
    } else if (ktx2File.isETC1S()) {
      basisFormat = BasisFormat.ETC1S;
    } else if (ktx2File.isHDR()) {
      basisFormat = BasisFormat.UASTC_HDR;
    } else {
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    }
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat, engineType } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          let dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (engineType === EngineType.HalfFloatType) {
            dst = new Uint16Array(dst.buffer, dst.byteOffset, dst.byteLength / Uint16Array.BYTES_PER_ELEMENT);
          }
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat, type: engineType });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, dfdFlags, format: engineFormat, type: engineType };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.BC6H],
      engineFormat: [EngineFormat.RGB_BPTC_UNSIGNED_Format],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: false
    },
    // Uncompressed fallbacks.
    {
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.RGBA32, TranscoderFormat.RGBA32],
      engineFormat: [EngineFormat.RGBAFormat, EngineFormat.RGBAFormat],
      engineType: [EngineType.UnsignedByteType, EngineType.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: false
    },
    {
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.RGBA_HALF],
      engineFormat: [EngineFormat.RGBAFormat],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: false
    }
  ];
  const OPTIONS = {
    // TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
    // a historical accident shown to avoid performance pitfalls for Linux with
    // Firefox & AMD GPU (RadeonSI). Further work needed.
    // See https://github.com/mrdoob/three.js/pull/29730.
    [BasisFormat.ETC1S]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.ETC1S)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC_HDR]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC_HDR)).sort((a, b) => a.priorityHDR - b.priorityHDR)
  };
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    const options = OPTIONS[basisFormat];
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (opt.if && !config[opt.if]) continue;
      if (!opt.basisFormat.includes(basisFormat)) continue;
      if (hasAlpha && opt.transcoderFormat.length < 2) continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
      const transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      const engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      const engineType = opt.engineType[0];
      return { transcoderFormat, engineFormat, engineType };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function isPowerOfTwo(value) {
    if (value <= 2) return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1) return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]);
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [ge]: RGBAFormat,
  [Ft]: RGBAFormat,
  [Ct]: RGBAFormat,
  [we]: RGFormat,
  [ae]: RGFormat,
  [xt]: RGFormat,
  [wt]: RGFormat,
  [ue]: RedFormat,
  [te]: RedFormat,
  [yt]: RedFormat,
  [ct]: RedFormat,
  [pi]: RGBA_ASTC_4x4_Format,
  [Sn]: RGBA_ASTC_6x6_Format,
  [In]: RGBA_ASTC_6x6_Format
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [ge]: HalfFloatType,
  [Ft]: UnsignedByteType,
  [Ct]: UnsignedByteType,
  [we]: FloatType,
  [ae]: HalfFloatType,
  [xt]: UnsignedByteType,
  [wt]: UnsignedByteType,
  [ue]: FloatType,
  [te]: HalfFloatType,
  [yt]: UnsignedByteType,
  [ct]: UnsignedByteType,
  [pi]: HalfFloatType,
  [Sn]: UnsignedByteType,
  [In]: UnsignedByteType
};
async function createRawTexture(container) {
  const { vkFormat } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  let zstd;
  if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd2 = new Q();
        await zstd2.init();
        resolve(zstd2);
      });
    }
    zstd = await _zstd;
  }
  const mipmaps = [];
  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);
    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);
    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;
    const level = container.levels[levelIndex];
    let levelData;
    if (container.supercompressionScheme === t) {
      levelData = level.levelData;
    } else if (container.supercompressionScheme === n) {
      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
    } else {
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    }
    let data;
    if (TYPE_MAP[vkFormat] === FloatType) {
      data = new Float32Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
      );
    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
      data = new Uint16Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
      );
    } else {
      data = levelData;
    }
    mipmaps.push({
      data,
      width: levelWidth,
      height: levelHeight,
      depth: levelDepth
    });
  }
  let texture;
  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {
    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
  } else {
    if (container.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);
    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
  }
  texture.mipmaps = mipmaps;
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = parseColorSpace(container);
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}
function parseColorSpace(container) {
  const dfd = container.dataFormatDescriptor[0];
  if (dfd.colorPrimaries === C) {
    return dfd.transferFunction === u ? SRGBColorSpace : LinearSRGBColorSpace;
  } else if (dfd.colorPrimaries === R) {
    return dfd.transferFunction === u ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;
  } else if (dfd.colorPrimaries === T2) {
    return NoColorSpace;
  } else {
    console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`);
    return NoColorSpace;
  }
}

// node_modules/@threlte/extras/dist/hooks/useKtx2.js
var ktxLoaderInstances = {};
var useKtx2 = (transcoderPath) => {
  const cachedLoader = ktxLoaderInstances[transcoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const { renderer } = useThrelte();
  const ktx2Loader = new KTX2Loader();
  ktx2Loader.setTranscoderPath(transcoderPath);
  ktx2Loader.detectSupport(renderer);
  ktxLoaderInstances[transcoderPath] = ktx2Loader;
  return ktx2Loader;
};

// node_modules/@threlte/extras/dist/hooks/useGltfAnimations.js
var isRoot = (value) => !!(value == null ? void 0 : value.isObject3D);
var isGltfStore = (value) => !!(value == null ? void 0 : value.subscribe) && typeof value.subscribe === "function";
function useGltfAnimations(rootOrGltf, maybeRoot) {
  const gltf = isGltfStore(rootOrGltf) ? rootOrGltf : writable(void 0);
  const root6 = currentWritable(isRoot(rootOrGltf) ? rootOrGltf : isRoot(maybeRoot) ? maybeRoot : void 0);
  const actualRoot = derived2([root6, gltf], ([root7, gltf2]) => {
    return root7 ?? (gltf2 == null ? void 0 : gltf2.scene);
  });
  const actions = currentWritable({});
  const mixer = new AnimationMixer(void 0);
  watch([gltf, actualRoot], async ([gltf2, actualRoot2]) => {
    if (!gltf2 || !gltf2.animations.length || !actualRoot2)
      return;
    await tick();
    const newActions = gltf2.animations.reduce((acc, clip) => {
      const action2 = mixer.clipAction(clip, actualRoot2);
      return {
        ...acc,
        [clip.name]: action2
      };
    }, {});
    actions.set(newActions);
    return () => {
      Object.values(newActions).forEach((a) => {
        const action2 = a;
        action2.stop();
        mixer.uncacheClip(action2.getClip());
      });
    };
  });
  const { start, stop } = useTask((delta) => {
    mixer.update(delta);
  }, { autoStart: false });
  watch(actions, (actions2) => {
    if (Object.keys(actions2).length)
      start();
    else
      stop();
  });
  return {
    gltf,
    root: root6,
    mixer,
    actions
  };
}

// node_modules/@threlte/extras/dist/lib/storeUtils.js
var toCurrentReadable = (store) => {
  return {
    subscribe: store.subscribe,
    get current() {
      return store.current;
    }
  };
};

// node_modules/@threlte/extras/dist/hooks/useProgress.js
var previousTotalLoaded = 0;
var finishedOnce = currentWritable(false);
var activeStore = currentWritable(false);
var itemStore = currentWritable(void 0);
var loadedStore = currentWritable(0);
var totalStore = currentWritable(0);
var errorsStore = currentWritable([]);
var progressStore = currentWritable(0);
var { onStart, onLoad, onError } = DefaultLoadingManager;
DefaultLoadingManager.onStart = (url, loaded, total) => {
  onStart == null ? void 0 : onStart(url, loaded, total);
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
DefaultLoadingManager.onLoad = () => {
  onLoad == null ? void 0 : onLoad();
  activeStore.set(false);
};
DefaultLoadingManager.onError = (url) => {
  onError == null ? void 0 : onError(url);
  errorsStore.update((errors) => {
    return [...errors, url];
  });
};
DefaultLoadingManager.onProgress = (url, loaded, total) => {
  if (loaded === total) {
    previousTotalLoaded = total;
  }
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
var stores = {
  active: toCurrentReadable(activeStore),
  item: toCurrentReadable(itemStore),
  loaded: toCurrentReadable(loadedStore),
  total: toCurrentReadable(totalStore),
  errors: toCurrentReadable(errorsStore),
  progress: toCurrentReadable(progressStore),
  finishedOnce: toCurrentReadable(finishedOnce)
};
var useProgress = () => {
  return stores;
};

// node_modules/@threlte/extras/dist/hooks/useTexture.js
var useTexture = (input, options) => {
  const loader = useLoader(TextureLoader, options);
  const { renderer } = useThrelte();
  return loader.load(input, {
    ...options,
    transform: (res) => {
      var _a2;
      res.colorSpace = renderer.outputColorSpace;
      res.needsUpdate = true;
      return ((_a2 = options == null ? void 0 : options.transform) == null ? void 0 : _a2.call(options, res)) ?? res;
    }
  });
};

// node_modules/@threlte/extras/dist/hooks/useFBO.js
var useFBO = ({ depth = false, size, ...targetOptions } = {}) => {
  const target = new WebGLRenderTarget(1, 1, targetOptions);
  if (size === void 0) {
    const { dpr, size: size2 } = useThrelte();
    watch([dpr, size2], ([dpr2, { width, height }]) => {
      target.setSize(dpr2 * width, dpr2 * height);
    });
  } else {
    const width = Math.max(size.width ?? 1, target.width);
    const height = Math.max(size.height ?? 1, target.height);
    target.setSize(width, height);
  }
  if (depth === true) {
    target.depthTexture = new DepthTexture(target.width, target.height);
  } else if (isInstanceOf(depth, "DepthTexture")) {
    target.depthTexture = depth;
  } else if (depth !== false) {
    const width = Math.max(depth.width ?? 1, 1);
    const height = Math.max(depth.height ?? 1, 1);
    target.depthTexture = new DepthTexture(width, height);
  }
  onDestroy(() => {
    target.dispose();
  });
  return target;
};

// node_modules/@threlte/extras/dist/hooks/useGamepad.js
var standardButtons = [
  "clusterBottom",
  "clusterRight",
  "clusterLeft",
  "clusterTop",
  "leftBumper",
  "rightBumper",
  "leftTrigger",
  "rightTrigger",
  "select",
  "start",
  "leftStickButton",
  "rightStickButton",
  "directionalTop",
  "directionalBottom",
  "directionalLeft",
  "directionalRight",
  "center"
];
var xrButtons = [
  "trigger",
  "squeeze",
  "touchpadButton",
  "thumbstickButton",
  "clusterBottom",
  "clusterTop"
];
var standardAxes = ["leftStick", "rightStick"];
var xrAxes = ["touchpad", "thumbstick"];
var createButton = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a2;
    (_a2 = events[index])[name] ?? (_a2[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    pressed: false,
    touched: false,
    value: 0,
    on,
    off
  };
};
var createAxis = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a2;
    (_a2 = events[index])[name] ?? (_a2[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    x: 0,
    y: 0,
    on,
    off
  };
};
var createXrStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Primary trigger */
    trigger: createButton(events, 0),
    /** buttons[1] - Primary squeeze button */
    squeeze: createButton(events, 1),
    /** buttons[2] - Primary touchpad */
    touchpadButton: createButton(events, 2),
    /** buttons[3] - Primary thumbstick */
    thumbstickButton: createButton(events, 3),
    /** buttons[4] - Bottom cluster button */
    clusterBottom: createButton(events, 4),
    /** buttons[5] - Top cluster button */
    clusterTop: createButton(events, 5),
    /** axes[0], axes[1] - Horizontal / vertical axis for the primary touchpad */
    touchpad: createAxis(events, 6),
    /** axes[2], axes[3] - Horizontal / vertical axis for the primary thumbstick */
    thumbstick: createAxis(events, 7)
  };
};
var createStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Botton button in right cluster */
    clusterBottom: createButton(events, 0),
    /** buttons[1] - Right button in right cluster */
    clusterRight: createButton(events, 1),
    /** buttons[2] - Left button in right cluster */
    clusterLeft: createButton(events, 2),
    /** buttons[3] - Top button in right cluster */
    clusterTop: createButton(events, 3),
    /** buttons[4] - Top left front button */
    leftBumper: createButton(events, 4),
    /** buttons[5] - Top right front button */
    rightBumper: createButton(events, 5),
    /** buttons[6] - Bottom left front button */
    leftTrigger: createButton(events, 6),
    /** buttons[7] - Bottom right front button */
    rightTrigger: createButton(events, 7),
    /** buttons[8] - Left button in center cluster */
    select: createButton(events, 8),
    /** buttons[9] - Right button in center cluster */
    start: createButton(events, 9),
    /** buttons[10] - Left stick pressed button */
    leftStickButton: createButton(events, 10),
    /** buttons[11] -	Right stick pressed button */
    rightStickButton: createButton(events, 11),
    /** buttons[12] -	Top button in left cluster */
    directionalTop: createButton(events, 12),
    /** buttons[13] -	Bottom button in left cluster */
    directionalBottom: createButton(events, 13),
    /** buttons[14] -	Left button in left cluster */
    directionalLeft: createButton(events, 14),
    /** buttons[15] -	Right button in left cluster */
    directionalRight: createButton(events, 15),
    /** buttons[16] -	Center button in center cluster */
    center: createButton(events, 16),
    /** axes[0], axes[1] - Horizontal / vertical axis for left stick (negative left/positive right) */
    leftStick: createAxis(events, 17),
    /** axes[2], axes[3] - Horizontal / vertical axis for right stick (negative left/positive right) */
    rightStick: createAxis(events, 18)
  };
};
var processButton = (target, mappedButton, allEvents, buttonEvents, source) => {
  var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const lastTouched = mappedButton.touched;
  const lastPressed = mappedButton.pressed;
  const lastValue = mappedButton.value;
  mappedButton.touched = (source == null ? void 0 : source.touched) ?? false;
  mappedButton.pressed = (source == null ? void 0 : source.pressed) ?? false;
  const value = mappedButton.value = (source == null ? void 0 : source.value) ?? 0;
  if (!lastTouched && mappedButton.touched) {
    (_a2 = allEvents.touchstart) == null ? void 0 : _a2.forEach((fn) => fn({ type: "touchstart", target, value }));
    (_b2 = buttonEvents.touchstart) == null ? void 0 : _b2.forEach((fn) => fn({ type: "touchstart", target, value }));
  } else if (lastTouched && !mappedButton.touched) {
    (_c = allEvents.touch) == null ? void 0 : _c.forEach((fn) => fn({ type: "touch", target, value }));
    (_d = buttonEvents.touch) == null ? void 0 : _d.forEach((fn) => fn({ type: "touch", target, value }));
    (_e2 = allEvents.touchend) == null ? void 0 : _e2.forEach((fn) => fn({ type: "touchend", target, value }));
    (_f = buttonEvents.touchend) == null ? void 0 : _f.forEach((fn) => fn({ type: "touchend", target, value }));
  }
  if (!lastPressed && mappedButton.pressed) {
    (_g = allEvents.down) == null ? void 0 : _g.forEach((fn) => fn({ type: "down", target, value }));
    (_h = buttonEvents.down) == null ? void 0 : _h.forEach((fn) => fn({ type: "down", target, value }));
  } else if (lastPressed && !mappedButton.pressed) {
    (_i = allEvents.press) == null ? void 0 : _i.forEach((fn) => fn({ type: "press", target, value }));
    (_j = buttonEvents.press) == null ? void 0 : _j.forEach((fn) => fn({ type: "press", target, value }));
    (_k = allEvents.up) == null ? void 0 : _k.forEach((fn) => fn({ type: "up", target, value }));
    (_l = buttonEvents.up) == null ? void 0 : _l.forEach((fn) => fn({ type: "up", target, value }));
  }
  if (lastValue !== mappedButton.value) {
    (_m = allEvents.change) == null ? void 0 : _m.forEach((fn) => fn({ type: "change", target, value }));
    (_n = buttonEvents.change) == null ? void 0 : _n.forEach((fn) => fn({ type: "change", target, value }));
  }
};
var processAxis = (target, mappedStick, allEvents, axisEvents, axisDeadzone, rawX = 0, rawY = 0) => {
  var _a2, _b2;
  const lastValueX = mappedStick.x;
  const lastValueY = mappedStick.y;
  const x = Math.abs(rawX) < axisDeadzone ? 0 : rawX;
  const y2 = Math.abs(rawY) < axisDeadzone ? 0 : rawY;
  mappedStick.x = x;
  mappedStick.y = y2;
  if (lastValueX !== x || lastValueY !== y2) {
    (_a2 = allEvents.change) == null ? void 0 : _a2.forEach((fn) => fn({ type: "change", target, value: { x, y: y2 } }));
    (_b2 = axisEvents.change) == null ? void 0 : _b2.forEach((fn) => fn({ type: "change", target, value: { x, y: y2 } }));
  }
};
function useGamepad(options = {}) {
  const { axisDeadzone = 0.05 } = options;
  const allEvents = {};
  const events = [];
  if ("xr" in options) {
    for (let i = 0; i < xrButtons.length + xrAxes.length; i += 1) {
      events.push({});
    }
    const gamepad = createXrStandard(allEvents, events);
    const { xr } = useThrelte().renderer;
    const processSnapshot = () => {
      var _a2;
      (_a2 = xr.getSession()) == null ? void 0 : _a2.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        gamepad.raw = source.gamepad ?? null;
        const { buttons = [], axes = [] } = gamepad.raw ?? {};
        xrButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
        processAxis("touchpad", gamepad.touchpad, allEvents, events[6], axisDeadzone, axes[0], axes[1]);
        processAxis("thumbstick", gamepad.thumbstick, allEvents, events[7], axisDeadzone, axes[2], axes[3]);
      });
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleConnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      const pad = event.data.gamepad;
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    const handleDisconnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      gamepad.raw = null;
      gamepad.connected.set(false);
      stop();
    };
    const session = xr.getSession();
    if (session) {
      session.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        const pad = source.gamepad;
        if (pad) {
          gamepad.raw = pad;
          gamepad.connected.set(true);
          start();
        }
      });
    }
    for (const index of [0, 1]) {
      const controller = xr.getController(index);
      controller.addEventListener("connected", handleConnected);
      controller.addEventListener("disconnected", handleDisconnected);
    }
    onDestroy(() => {
      for (const index of [0, 1]) {
        const controller = xr.getController(index);
        controller.removeEventListener("connected", handleConnected);
        controller.removeEventListener("disconnected", handleDisconnected);
      }
    });
    return gamepad;
  } else {
    for (let i = 0; i < standardButtons.length + standardAxes.length; i += 1) {
      events.push({});
    }
    const { index: gamepadIndex = 0 } = options;
    const gamepad = createStandard(allEvents, events);
    const processSnapshot = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      gamepad.raw = pad;
      const { buttons = [], axes = [] } = pad ?? {};
      standardButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
      processAxis("leftStick", gamepad.leftStick, allEvents, events[17], axisDeadzone, axes[0], axes[1]);
      processAxis("rightStick", gamepad.rightStick, allEvents, events[18], axisDeadzone, axes[2], axes[3]);
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleGamepadDisconnected = (event) => {
      var _a2;
      const { id } = event.gamepad;
      if (id === ((_a2 = gamepad.raw) == null ? void 0 : _a2.id)) {
        gamepad.raw = null;
        gamepad.connected.set(false);
        stop();
      }
    };
    const handleGamepadConnected = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    handleGamepadConnected();
    window.addEventListener("gamepadconnected", handleGamepadConnected);
    window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);
    onDestroy(() => {
      window.removeEventListener("gamepadconnected", handleGamepadConnected);
      window.removeEventListener("gamepaddisconnected", handleGamepadDisconnected);
    });
    return gamepad;
  }
}

// node_modules/@threlte/extras/dist/hooks/useMask.js
var useMask = (id = 1, inverse = false) => {
  return {
    stencilRef: id,
    stencilWrite: true,
    stencilFunc: inverse ? NotEqualStencilFunc : EqualStencilFunc,
    stencilFail: KeepStencilOp,
    stencilZFail: KeepStencilOp,
    stencilZPass: KeepStencilOp
  };
};

// node_modules/@threlte/extras/dist/hooks/useViewport.js
var origin = new Vector3();
var position = new Vector3();
var lastPosition = new Vector3();
var useViewport = (target) => {
  const viewport = currentWritable({
    width: 0,
    height: 0,
    factor: 0,
    distance: 0
  });
  const { camera, size, renderStage, scheduler } = useThrelte();
  const updateViewport = ($size, $camera, distance) => {
    viewport.update(($viewport) => {
      const { width, height } = $size;
      if (Array.isArray(target)) {
        origin.fromArray(target);
      } else if (target !== void 0) {
        origin.copy(target);
      }
      $viewport.distance = distance;
      if (isInstanceOf($camera, "OrthographicCamera")) {
        $viewport.width = width / $camera.zoom;
        $viewport.height = height / $camera.zoom;
        $viewport.factor = 1;
      } else if (isInstanceOf($camera, "PerspectiveCamera")) {
        const fov = $camera.fov * Math.PI / 180;
        const h = 2 * Math.tan(fov / 2) * distance;
        const w = h * (width / height);
        $viewport.width = w;
        $viewport.height = h;
        $viewport.factor = width / w;
      }
      return $viewport;
    });
  };
  useTask(() => {
    camera.current.getWorldPosition(position);
    if (!position.equals(lastPosition)) {
      const distance = position.distanceTo(origin);
      updateViewport(size.current, camera.current, distance);
      lastPosition.copy(position);
    }
  }, {
    autoInvalidate: false,
    stage: scheduler.createStage(Symbol("viewport-stage"), { before: renderStage })
  });
  watch([camera, size], ([$camera, $size]) => {
    const distance = $camera.getWorldPosition(position).distanceTo(origin);
    updateViewport($size, $camera, distance);
  });
  return viewport;
};

// node_modules/@threlte/extras/dist/utilities/meshBounds.js
var sphere = new Sphere();
var inverseMatrix = new Matrix4();
var ray = new Ray();
var v = new Vector3();
var meshBounds = function(raycaster, intersects) {
  if (this.geometry.boundingSphere === null) {
    this.geometry.computeBoundingSphere();
  }
  sphere.copy(this.geometry.boundingSphere ?? sphere);
  sphere.applyMatrix4(this.matrixWorld);
  if (!raycaster.ray.intersectsSphere(sphere)) {
    return;
  }
  inverseMatrix.copy(this.matrixWorld).invert();
  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
  if (this.geometry.boundingBox !== null && ray.intersectBox(this.geometry.boundingBox, v) === null) {
    return;
  }
  const distance = v.distanceTo(raycaster.ray.origin);
  const point = v.clone();
  intersects.push({
    distance,
    point,
    object: this
  });
};

// node_modules/@threlte/extras/dist/suspense/context.js
var suspenseContextIdentifier = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER");
var createSuspenseContext = (options) => {
  const promises = currentWritable(/* @__PURE__ */ new Set());
  const errors = currentWritable(/* @__PURE__ */ new Map());
  const finalized = writable(false);
  const checkFinalized = () => {
    if (promises.current.size === 0 && errors.current.size === 0)
      finalized.set(true);
  };
  const finalStore = writable((options == null ? void 0 : options.final) ?? false);
  const addPromise = (promise) => {
    promises.update((set2) => {
      set2.add(promise);
      return set2;
    });
  };
  const removePromise = (promise) => {
    promises.update((set2) => {
      set2.delete(promise);
      return set2;
    });
  };
  const addError = (promise, error) => {
    errors.update((map) => {
      map.set(promise, error);
      return map;
    });
  };
  const removeError = (promise) => {
    errors.update((map) => {
      map.delete(promise);
      return map;
    });
  };
  const suspended = derived2([promises, errors, finalStore, finalized], ([promises2, errors2, final, finalized2]) => {
    if (final && finalized2) {
      return false;
    } else if (errors2.size > 0) {
      return true;
    } else {
      return promises2.size > 0;
    }
  });
  const context = {
    suspend(promise) {
      addPromise(promise);
      promise.catch((error) => {
        addError(promise, error);
      }).finally(() => {
        removePromise(promise);
        checkFinalized();
      });
    },
    onComponentDestroy(promise) {
      removePromise(promise);
      removeError(promise);
      checkFinalized();
    },
    suspended
  };
  const errorsArray = derived2(errors, (errors2) => Array.from(errors2.values()));
  setContext(suspenseContextIdentifier, context);
  return {
    promises,
    suspended,
    errors: errorsArray,
    setFinal: (final) => finalStore.set(final ?? false)
  };
};

// node_modules/@threlte/extras/dist/suspense/useSuspense.js
var useSuspense = () => {
  const ctx = getContext(suspenseContextIdentifier);
  const promises = /* @__PURE__ */ new Set();
  const suspend = (promise) => {
    if (ctx) {
      ctx.suspend(promise);
      promises.add(promise);
    }
    return promise;
  };
  const state2 = {
    suspended: derived2((ctx == null ? void 0 : ctx.suspended) ?? readable(false), (suspended) => suspended)
  };
  onDestroy(() => {
    if (!ctx)
      return;
    for (const promise of promises) {
      ctx.onComponentDestroy(promise);
    }
    promises.clear();
  });
  return Object.assign(suspend, state2);
};

// node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte
mark_module_start();
AnimatedSpriteMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte";
var root_1 = add_locations(template(`<!> <!>`, 1), AnimatedSpriteMaterial[FILENAME], []);
function AnimatedSpriteMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnimatedSpriteMaterial);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  let dataUrl = prop($$props, "dataUrl", 3, ""), animation = prop($$props, "animation", 3, ""), loop = prop($$props, "loop", 3, true), autoplay = prop($$props, "autoplay", 3, true), fps = prop($$props, "fps", 3, 10), filter = prop($$props, "filter", 3, "nearest"), alphaTest = prop($$props, "alphaTest", 3, 0.1), delay = prop($$props, "delay", 3, 0), transparent = prop($$props, "transparent", 3, true), flipX = prop($$props, "flipX", 3, false), startFrame = prop($$props, "startFrame", 3, 0), endFrame = prop($$props, "endFrame", 3, void 0), rows = prop($$props, "rows", 3, 1), columns = prop($$props, "columns", 3, void 0), totalFrames = prop($$props, "totalFrames", 3, 0), is = prop($$props, "is", 15), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "textureUrl",
      "dataUrl",
      "animation",
      "loop",
      "autoplay",
      "fps",
      "filter",
      "alphaTest",
      "delay",
      "transparent",
      "flipX",
      "startFrame",
      "endFrame",
      "rows",
      "columns",
      "totalFrames",
      "is",
      "ref",
      "onload",
      "onstart",
      "onend",
      "onloop"
    ],
    "props"
  );
  const parent = useParent();
  const supportedDirections = ["forward", "reverse"];
  const isSupportedDirection = (value) => {
    const isSupported = supportedDirections.includes(value);
    if (!isSupported) {
      console.warn(...log_if_contains_state("warn", `frame tag direction: "${value}" is not supported.${equals(dataUrl(), "", false) ? `
source dataURL: ${dataUrl()}` : `
texture URL: ${$$props.textureUrl}`}`));
    }
    return isSupported;
  };
  let timerOffset = 0;
  let currentFrame = startFrame();
  let numFrames = 0;
  let flipOffset = flipX() ? -1 : 1;
  let frameWidth = 0;
  let frameHeight = 0;
  let texture = state(void 0);
  let json;
  let frameNames = [];
  let direction2 = "forward";
  let frameTag;
  let spritesheetSize = { w: 0, h: 0 };
  let fpsInterval = 0;
  let isMesh = state(false);
  user_pre_effect(() => {
    set(isMesh, proxy(strict_equals($parent(), void 0, false) && isInstanceOf($parent(), "Mesh"), null, isMesh));
  });
  user_pre_effect(() => {
    fpsInterval = 1e3 / fps();
  });
  is(is() ?? (get(isMesh) ? new MeshBasicMaterial() : new SpriteMaterial()));
  const suspend = useSuspense();
  const textureStore = suspend(useTexture($$props.textureUrl, {
    transform: (value) => {
      value.matrixAutoUpdate = false;
      value.generateMipmaps = false;
      value.premultiplyAlpha = false;
      value.wrapS = assign(value, "wrapT", RepeatWrapping, "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte:42:22");
      value.magFilter = assign(value, "minFilter", strict_equals(filter(), "nearest") ? NearestFilter : LinearFilter, "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte:43:26");
      return value;
    }
  }));
  const jsonStore = suspend(dataUrl() ? useLoader(FileLoader).load(dataUrl(), {
    transform: (file) => {
      if (strict_equals(typeof file, "string", false)) return;
      try {
        return JSON.parse(file);
      } catch {
        return;
      }
    }
  }) : asyncWritable(new Promise((resolve) => {
    const unsub = textureStore.subscribe((value) => {
      if (!value) return;
      unsub();
      resolve(createData(value));
    });
  })));
  const createData = (texture2) => {
    const { width, height } = texture2.image;
    const cols = columns() ?? totalFrames();
    numFrames = totalFrames();
    const frameWidth2 = width / cols;
    const frameHeight2 = height / rows();
    const data = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: width, h: height },
        scale: 1
      }
    };
    for (let i = 0; i < numFrames; i += 1) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const x = col * frameWidth2;
      const y2 = row * frameHeight2;
      data.frames[`${i}`] = {
        frame: { x, y: y2, w: frameWidth2, h: frameHeight2 },
        spriteSourceSize: { x: 0, y: 0, w: frameWidth2, h: frameHeight2 },
        sourceSize: { w: frameWidth2, h: frameHeight2 }
      };
    }
    return data;
  };
  const setFrame = (frame) => {
    var _a2, _b2;
    const horizontalFrames = spritesheetSize.w / frameWidth;
    const verticalFrames = spritesheetSize.h / frameHeight;
    const frameOffsetX = 1 / horizontalFrames;
    const frameOffsetY = 1 / verticalFrames;
    const x = flipOffset > 0 ? frameOffsetX * (frame.x / frameWidth) : frameOffsetX * (frame.x / frameHeight) - get(texture).repeat.x;
    const y2 = Math.abs(1 - frameOffsetY) - frameOffsetY * (frame.y / frameHeight);
    (_a2 = get(texture)) == null ? void 0 : _a2.offset.set(x, y2);
    (_b2 = get(texture)) == null ? void 0 : _b2.updateMatrix();
  };
  const setAnimation = (name) => {
    var _a2;
    if (!json) return;
    frameTag = json == null ? void 0 : json.meta.frameTags.find((tag) => strict_equals(tag.name, name));
    direction2 = "forward";
    if (frameTag == null ? void 0 : frameTag.direction) {
      direction2 = isSupportedDirection(frameTag == null ? void 0 : frameTag.direction) ? frameTag.direction : "forward";
    }
    currentFrame = strict_equals(direction2, "forward") ? (frameTag == null ? void 0 : frameTag.from) ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? numFrames - 1;
    setFrame(json.frames[frameNames[currentFrame]].frame);
    (_a2 = $$props.onstart) == null ? void 0 : _a2.call($$props);
  };
  let playQueued = false;
  const play = async () => {
    playQueued = true;
    await Promise.all([textureStore, jsonStore]);
    if (!playQueued) return;
    timerOffset = performance.now() - delay();
    start();
  };
  const pause = () => {
    playQueued = false;
    stop();
  };
  const { start, stop } = useTask(
    () => {
      var _a2, _b2;
      if (!json) return;
      const now3 = performance.now();
      const diff = now3 - timerOffset;
      const name = frameNames[currentFrame];
      const { frame, duration } = json.frames[name];
      const interval = duration ?? fpsInterval;
      if (diff <= interval) return;
      timerOffset = now3 - diff % interval;
      const start2 = strict_equals(direction2, "forward") ? (frameTag == null ? void 0 : frameTag.from) ?? startFrame() ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? endFrame() ?? numFrames - 1;
      const end = strict_equals(direction2, "forward") ? (frameTag == null ? void 0 : frameTag.to) ?? endFrame() ?? numFrames - 1 : (frameTag == null ? void 0 : frameTag.from) ?? startFrame() ?? 0;
      setFrame(frame);
      switch (direction2) {
        case "forward":
          currentFrame += 1;
          break;
        case "reverse":
          currentFrame -= 1;
          break;
        default:
          break;
      }
      if (strict_equals(direction2, "forward") && currentFrame > end || strict_equals(direction2, "reverse") && currentFrame < end) {
        currentFrame = start2;
        if (loop()) {
          (_a2 = $$props.onloop) == null ? void 0 : _a2.call($$props);
        } else {
          pause();
          (_b2 = $$props.onend) == null ? void 0 : _b2.call($$props);
        }
      }
    },
    { autoStart: false }
  );
  watch([textureStore, jsonStore], ([nextTexture, nextJson]) => {
    var _a2;
    if (strict_equals(nextTexture, void 0) || strict_equals(nextJson, void 0)) return;
    set(texture, proxy(nextTexture.clone(), null, texture));
    json = nextJson;
    frameNames = Object.keys(json.frames);
    numFrames = frameNames.length;
    spritesheetSize = json.meta.size;
    const { sourceSize } = Object.values(json.frames)[0];
    frameWidth = sourceSize.w;
    frameHeight = sourceSize.h;
    get(texture).repeat.set(1 * flipOffset / (spritesheetSize.w / frameWidth), 1 / (spritesheetSize.h / frameHeight));
    setAnimation(animation());
    (_a2 = $$props.onload) == null ? void 0 : _a2.call($$props);
    if (autoplay()) {
      play();
    }
  });
  user_pre_effect(() => {
    setAnimation(animation());
    if (autoplay()) {
      play();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_1();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, spread_props(
          {
            get is() {
              return is();
            },
            get map() {
              return get(texture);
            },
            toneMapped: false,
            side: DoubleSide,
            shadowSide: DoubleSide,
            get transparent() {
              return transparent();
            },
            get alphaTest() {
              return alphaTest();
            }
          },
          () => props,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
      var node_2 = sibling(node_1, 2);
      component(node_2, () => T.MeshDepthMaterial, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          attach: "customDepthMaterial",
          depthPacking: RGBADepthPacking,
          get map() {
            return get(texture);
          },
          get alphaTest() {
            return alphaTest();
          }
        });
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            add_owner_effect(ref, T);
            T(node_4, spread_props(
              {
                get is() {
                  return is();
                },
                get map() {
                  return get(texture);
                },
                toneMapped: false,
                get transparent() {
                  return transparent();
                },
                get alphaTest() {
                  return alphaTest();
                }
              },
              () => props,
              {
                get ref() {
                  return ref();
                },
                set ref($$value) {
                  ref($$value);
                }
              }
            ));
          }
          append($$anchor3, fragment_3);
        };
        if_block(
          node_3,
          ($$render) => {
            if (get(texture)) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (get(texture) && get(isMesh)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({
    get play() {
      return play;
    },
    get pause() {
      return pause;
    },
    ...legacy_api()
  });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  AnimatedSpriteMaterial = hmr(AnimatedSpriteMaterial, () => AnimatedSpriteMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimatedSpriteMaterial[HMR].source;
    set(AnimatedSpriteMaterial[HMR].source, module.default[HMR].original);
  });
}
var AnimatedSpriteMaterial_default = AnimatedSpriteMaterial;
mark_module_end(AnimatedSpriteMaterial);

// node_modules/@threlte/extras/dist/components/Edges/Edges.svelte
mark_module_start();
Edges[FILENAME] = "node_modules/@threlte/extras/dist/components/Edges/Edges.svelte";
var root_12 = add_locations(template(`<!> <!> <!>`, 1), Edges[FILENAME], []);
function Edges($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Edges);
  let thresholdAngle = prop($$props, "thresholdAngle", 3, 1), color2 = prop($$props, "color", 3, "#ffffff"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "thresholdAngle",
      "color",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = fromStore(useParent());
  const geometry = derived(() => {
    if (!isInstanceOf(parent.current, "Mesh")) {
      throw new Error("Edges: component must be a child of a Mesh");
    }
    return parent.current.geometry;
  });
  ref(new LineSegments());
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props(
    {
      get is() {
        return ref();
      }
    },
    () => props,
    {
      children: wrap_snippet(Edges, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_12();
        var node_1 = first_child(fragment_1);
        var args = derived(() => [get(geometry), thresholdAngle()]);
        component(node_1, () => T.EdgesGeometry, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            get args() {
              return get(args);
            }
          });
        });
        var node_2 = sibling(node_1, 2);
        component(node_2, () => T.LineBasicMaterial, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            get color() {
              return color2();
            }
          });
        });
        var node_3 = sibling(node_2, 2);
        snippet(node_3, () => $$props.children ?? noop, () => ({ ref: ref() }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Edges = hmr(Edges, () => Edges[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Edges[HMR].source;
    set(Edges[HMR].source, module.default[HMR].original);
  });
}
var Edges_default = Edges;
mark_module_end(Edges);

// node_modules/@threlte/extras/dist/components/HTML/utils.js
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
var vec2 = new Vector2();
var defaultCalculatePosition = (obj, camera, size) => {
  const objectPos = v1.setFromMatrixPosition(obj.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
};
var isObjectBehindCamera = (el2, camera) => {
  const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el2, camera, raycaster, occlude) => {
  const elPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const screenPos = v2.copy(v1);
  screenPos.project(camera);
  raycaster.setFromCamera(vec2.set(screenPos.x, screenPos.y), camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectScale = (el2, camera) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return camera.zoom;
  } else if (isInstanceOf(camera, "PerspectiveCamera")) {
    const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var objectZIndex = (el2, camera, zIndexRange) => {
  const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const dist = objectPos.distanceTo(cameraPos);
  const A3 = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
  const B3 = zIndexRange[1] - A3 * camera.far;
  return Math.round(A3 * dist + B3);
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (mat4, m, prepend = "") => {
  const { elements: e } = mat4;
  return `${prepend}matrix3d(
    ${epsilon(m[0] * e[0])},${epsilon(m[1] * e[1])},${epsilon(m[2] * e[2])},${epsilon(m[3] * e[3])},
    ${epsilon(m[4] * e[4])},${epsilon(m[5] * e[5])},${epsilon(m[6] * e[6])},${epsilon(m[7] * e[7])},
    ${epsilon(m[8] * e[8])},${epsilon(m[9] * e[9])},${epsilon(m[10] * e[10])},${epsilon(m[11] * e[11])},
    ${epsilon(m[12] * e[12])},${epsilon(m[13] * e[13])},${epsilon(m[14] * e[14])},${epsilon(m[15] * e[15])}
  )`;
};
var getCameraCSSMatrix = /* @__PURE__ */ ((multipliers) => {
  return (matrix) => getCSSMatrix(matrix, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = /* @__PURE__ */ ((scaleMultipliers) => {
  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);
var getViewportFactor = (camera, target, size) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return 1;
  }
  if (isInstanceOf(camera, "PerspectiveCamera")) {
    const { width, height } = size;
    const distance = camera.getWorldPosition(v1).distanceTo(target);
    const fov = camera.fov * Math.PI / 180;
    const h = 2 * Math.tan(fov / 2) * distance;
    const w = h * (width / height);
    return width / w;
  }
  throw new Error("getViewportFactor needs a Perspective or Orthographic Camera");
};

// node_modules/@threlte/extras/dist/components/HTML/shaders.js
var logVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`;
var logFragment = `
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
}`;
var spriteVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;
  
  // This is somewhat arbitrary, but it seems to work well
  // Need to figure out how to derive this dynamically if it even matters
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale = vec2(
    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),
    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )
  );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  #include <logdepthbuf_vertex>
}`;

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
mark_module_start();
HTML[FILENAME] = "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte";
var canvasModified = false;
var activeOccludeInstances = 0;
var oldZIndex = "";
var oldPosition = "";
var oldPointerEvents = "";
var modifyCanvas = (canvas, zIndexRange) => {
  if (strict_equals(activeOccludeInstances, 1) && !canvasModified) {
    oldZIndex = canvas.style.zIndex;
    oldPosition = canvas.style.position;
    oldPointerEvents = canvas.style.pointerEvents;
    canvas.style.zIndex = `${Math.floor(zIndexRange / 2)}`;
    canvas.style.position = "absolute";
    canvas.style.pointerEvents = "none";
    canvasModified = true;
  } else if (strict_equals(activeOccludeInstances, 0) && canvasModified) {
    canvas.style.zIndex = oldZIndex;
    canvas.style.position = oldPosition;
    canvas.style.pointerEvents = oldPointerEvents;
    canvasModified = false;
  }
};
var root_3 = add_locations(template(`<!> <!>`, 1), HTML[FILENAME], []);
var root_11 = add_locations(template(`<div><div><div><!></div></div></div>`), HTML[FILENAME], [
  [
    254,
    4,
    [[264, 6, [[269, 8]]]]
  ]
]);
var root_122 = add_locations(template(`<div><!></div>`), HTML[FILENAME], [[278, 4]]);
var root = add_locations(template(`<!> <!>`, 1), HTML[FILENAME], []);
function HTML($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HTML);
  const [$$stores, $$cleanup] = setup_stores();
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  let autoRender = prop($$props, "autoRender", 3, true), eps = prop($$props, "eps", 3, 1e-3), center = prop($$props, "center", 3, false), fullscreen = prop($$props, "fullscreen", 3, false), sprite = prop($$props, "sprite", 3, false), transform = prop($$props, "transform", 3, false), occlude = prop($$props, "occlude", 3, false), zIndexRange = prop($$props, "zIndexRange", 19, () => [16777271, 0]), calculatePosition = prop($$props, "calculatePosition", 3, defaultCalculatePosition), as = prop($$props, "as", 3, "div"), pointerEvents = prop($$props, "pointerEvents", 3, "auto"), ref = prop($$props, "ref", 15), visible = prop($$props, "visible", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoRender",
      "eps",
      "center",
      "fullscreen",
      "portal",
      "distanceFactor",
      "sprite",
      "transform",
      "occlude",
      "castShadow",
      "receiveShadow",
      "material",
      "geometry",
      "zIndexRange",
      "calculatePosition",
      "as",
      "wrapperClass",
      "pointerEvents",
      "ref",
      "visible",
      "style",
      "children"
    ],
    "props"
  );
  visible(true);
  const { camera, scene, size, dom, canvas } = useThrelte();
  const group = new Group();
  let element2 = document.createElement(as());
  let oldZoom = 0;
  let oldPosition2 = [0, 0];
  let transformOuterRef = state(void 0);
  let transformInnerRef = state(void 0);
  let isMeshSizeSet = false;
  const occlusionMesh = new Mesh();
  const raycaster = new Raycaster();
  let isRayCastOcclusion = derived(() => occlude() && strict_equals(occlude(), "blending", false) || Array.isArray(occlude()) && occlude().length > 0);
  let matrix = new Matrix4();
  let width = derived(() => $size().width);
  let height = derived(() => $size().height);
  let halfWidth = derived(() => get(width) / 2);
  let halfHeight = derived(() => get(height) / 2);
  let fov = derived(() => $camera().projectionMatrix.elements[5] * get(halfHeight));
  let viewportFactor = derived(() => getViewportFactor($camera(), new Vector3(), $size()));
  user_pre_effect(() => {
    if ($$props.wrapperClass) element2.className = $$props.wrapperClass;
  });
  user_pre_effect(() => {
    if (strict_equals(occlude(), "blending")) {
      activeOccludeInstances += 1;
      modifyCanvas(canvas, zIndexRange()[0]);
    }
    return () => {
      activeOccludeInstances -= 1;
      modifyCanvas(canvas, zIndexRange()[0]);
    };
  });
  const render = () => {
    camera.current.updateMatrixWorld();
    group.updateWorldMatrix(true, false);
    const vec = transform() ? oldPosition2 : calculatePosition()(group, camera.current, $size());
    if (transform() || Math.abs(oldZoom - camera.current.zoom) > eps() || Math.abs(oldPosition2[0] - vec[0]) > eps() || Math.abs(oldPosition2[1] - vec[1]) > eps()) {
      const isBehindCamera = isObjectBehindCamera(group, camera.current);
      let raytraceTarget = false;
      if (get(isRayCastOcclusion)) {
        if (Array.isArray(occlude())) {
          raytraceTarget = occlude();
        } else if (strict_equals(occlude(), "blending", false)) {
          raytraceTarget = [scene];
        }
      }
      const previouslyVisible = visible();
      if (raytraceTarget) {
        const isvisible = isObjectVisible(group, camera.current, raycaster, raytraceTarget);
        visible(isvisible && !isBehindCamera);
      } else {
        visible(!isBehindCamera);
      }
      if (strict_equals(previouslyVisible, visible(), false)) {
        if ($$props.onvisibilitychange) {
          $$props.onvisibilitychange(visible());
        } else {
          element2.style.display = visible() ? "block" : "none";
        }
      }
      const halfRange = Math.floor(zIndexRange()[0] / 2);
      const zRange = occlude() ? get(isRayCastOcclusion) ? [
        zIndexRange()[0],
        //
        halfRange
      ] : [halfRange - 1, 0] : zIndexRange();
      element2.style.zIndex = `${objectZIndex(group, camera.current, zRange)}`;
      if (transform() && get(transformOuterRef) && get(transformInnerRef)) {
        const {
          isOrthographicCamera,
          top,
          left,
          bottom,
          right
        } = camera.current;
        const cameraMatrix = getCameraCSSMatrix(camera.current.matrixWorldInverse);
        const cameraTransform = isOrthographicCamera ? `scale(${get(fov)})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${get(fov)}px)`;
        if (sprite()) {
          matrix.copy(camera.current.matrixWorldInverse).transpose().copyPosition(matrix).scale(group.scale);
          matrix.elements[3] = assign(matrix.elements, 7, assign(matrix.elements, 11, 0, "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte:120:58"), "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte:120:37");
          matrix.elements[15] = 1;
        } else {
          matrix.copy(group.matrixWorld);
        }
        element2.style.width = `${get(width)}px`;
        element2.style.height = `${get(height)}px`;
        element2.style.perspective = isOrthographicCamera ? "" : `${get(fov)}px`;
        get(transformOuterRef).style.transform = `${cameraTransform}${cameraMatrix}translate(${get(halfWidth)}px,${get(halfHeight)}px)`;
        get(transformInnerRef).style.transform = getObjectCSSMatrix(matrix, 1 / (($$props.distanceFactor || 10) / 400));
      } else {
        const scale = strict_equals($$props.distanceFactor, void 0) ? 1 : objectScale(group, camera.current) * $$props.distanceFactor;
        element2.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;
      }
      oldPosition2 = vec;
      oldZoom = camera.current.zoom;
    }
    if (!get(isRayCastOcclusion) && !isMeshSizeSet) {
      if (transform() && get(transformOuterRef)) {
        const el2 = get(transformOuterRef).children[0];
        if ((el2 == null ? void 0 : el2.clientWidth) && (el2 == null ? void 0 : el2.clientHeight)) {
          const { isOrthographicCamera } = camera.current;
          if (isOrthographicCamera || $$props.geometry) {
            const { scale } = props;
            if (scale) {
              if (!Array.isArray(scale)) {
                occlusionMesh.scale.setScalar(1 / scale);
              } else {
                occlusionMesh.scale.set(1 / scale[0], 1 / scale[1], 1 / scale[2]);
              }
            }
          } else {
            const ratio = ($$props.distanceFactor ?? 10) / 400;
            const w = el2.clientWidth * ratio;
            const h = el2.clientHeight * ratio;
            occlusionMesh.scale.set(w, h, 1);
          }
          isMeshSizeSet = true;
        }
      } else {
        const el2 = element2.children[0];
        if ((el2 == null ? void 0 : el2.clientWidth) && (el2 == null ? void 0 : el2.clientHeight)) {
          const ratio = 1 / get(viewportFactor);
          const w = el2.clientWidth * ratio;
          const h = el2.clientHeight * ratio;
          occlusionMesh.scale.set(w, h, 1);
          isMeshSizeSet = true;
        }
        occlusionMesh.lookAt(camera.current.position);
      }
    }
  };
  const { start: startRendering, stop: stopRendering } = useTask(render, { autoStart: false });
  user_effect(() => {
    if (autoRender()) {
      startRendering();
      return () => {
        stopRendering();
      };
    }
  });
  let pos = derived(() => {
    scene.updateMatrixWorld();
    return calculatePosition()(group, $camera(), $size());
  });
  const portalAction = (el2) => {
    const target = $$props.portal ?? dom;
    if (!target) {
      console.warn(...log_if_contains_state("warn", "<HTML>: target is undefined."));
      return;
    }
    target.append(el2);
    return { destroy: () => el2.remove() };
  };
  var fragment = root();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(HTML, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent_3 = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: occlusionMesh,
              get castShadow() {
                return $$props.castShadow;
              },
              get receiveShadow() {
                return $$props.receiveShadow;
              },
              children: wrap_snippet(HTML, ($$anchor4, $$slotProps2) => {
                var fragment_3 = root_3();
                var node_3 = first_child(fragment_3);
                {
                  var consequent = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    T(node_4, {
                      get is() {
                        return $$props.geometry;
                      }
                    });
                    append($$anchor5, fragment_4);
                  };
                  var alternate = ($$anchor5) => {
                    var fragment_5 = comment();
                    var node_5 = first_child(fragment_5);
                    component(node_5, () => T.PlaneGeometry, ($$anchor6, $$component) => {
                      $$component($$anchor6, {});
                    });
                    append($$anchor5, fragment_5);
                  };
                  if_block(node_3, ($$render) => {
                    if ($$props.geometry) $$render(consequent);
                    else $$render(alternate, false);
                  });
                }
                var node_6 = sibling(node_3, 2);
                {
                  var consequent_1 = ($$anchor5) => {
                    var fragment_6 = comment();
                    var node_7 = first_child(fragment_6);
                    T(node_7, {
                      get is() {
                        return $$props.material;
                      }
                    });
                    append($$anchor5, fragment_6);
                  };
                  var alternate_2 = ($$anchor5) => {
                    var fragment_7 = comment();
                    var node_8 = first_child(fragment_7);
                    {
                      var consequent_2 = ($$anchor6) => {
                        var fragment_8 = comment();
                        var node_9 = first_child(fragment_8);
                        component(node_9, () => T.ShaderMaterial, ($$anchor7, $$component) => {
                          $$component($$anchor7, {
                            side: DoubleSide,
                            vertexShader: spriteVertex,
                            fragmentShader: logFragment
                          });
                        });
                        append($$anchor6, fragment_8);
                      };
                      var alternate_1 = ($$anchor6) => {
                        var fragment_9 = comment();
                        var node_10 = first_child(fragment_9);
                        component(node_10, () => T.ShaderMaterial, ($$anchor7, $$component) => {
                          $$component($$anchor7, {
                            side: DoubleSide,
                            vertexShader: logVertex,
                            fragmentShader: logFragment
                          });
                        });
                        append($$anchor6, fragment_9);
                      };
                      if_block(
                        node_8,
                        ($$render) => {
                          if (!transform()) $$render(consequent_2);
                          else $$render(alternate_1, false);
                        },
                        true
                      );
                    }
                    append($$anchor5, fragment_7);
                  };
                  if_block(node_6, ($$render) => {
                    if ($$props.material) $$render(consequent_1);
                    else $$render(alternate_2, false);
                  });
                }
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          };
          if_block(node_1, ($$render) => {
            if (occlude() && !get(isRayCastOcclusion)) $$render(consequent_3);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  var node_11 = sibling(node, 2);
  validate_void_dynamic_element(as);
  validate_dynamic_element_tag(as);
  element(
    node_11,
    as,
    false,
    ($$element, $$anchor2) => {
      action($$element, ($$node) => portalAction == null ? void 0 : portalAction($$node));
      bind_this($$element, ($$value) => element2 = $$value, () => element2);
      set_style($$element, "position", "absolute");
      set_style($$element, "top", "0");
      set_style($$element, "left", "0");
      template_effect(() => {
        set_style($$element, "pointer-events", transform() ? "none" : void 0);
        set_style($$element, "overflow", transform() ? "hidden" : void 0);
        set_style($$element, "transform", transform() ? void 0 : `translate3d(${get(pos)[0]}px,${get(pos)[1]}px,0)`);
        set_style($$element, "transform-origin", transform() ? void 0 : "0 0");
      });
      var fragment_10 = comment();
      var node_12 = first_child(fragment_10);
      {
        var consequent_4 = ($$anchor3) => {
          var div = root_11();
          set_style(div, "position", "absolute");
          set_style(div, "top", "0");
          set_style(div, "left", "0");
          set_style(div, "transform-style", "preserve-3d");
          set_style(div, "pointer-events", "none");
          var div_1 = child(div);
          set_style(div_1, "position", "absolute");
          var div_2 = child(div_1);
          var node_13 = child(div_2);
          snippet(node_13, () => $$props.children ?? noop, () => ({ render, startRendering, stopRendering }));
          reset(div_2);
          reset(div_1);
          bind_this(div_1, ($$value) => set(transformInnerRef, $$value), () => get(transformInnerRef));
          reset(div);
          bind_this(div, ($$value) => set(transformOuterRef, $$value), () => get(transformOuterRef));
          template_effect(() => {
            set_style(div, "width", `${get(width)}px`);
            set_style(div, "height", `${get(height)}px`);
            set_style(div_1, "pointer-events", pointerEvents());
            set_class(div_2, clsx($$props.class));
            set_attribute(div_2, "style", $$props.style);
          });
          append($$anchor3, div);
        };
        var alternate_3 = ($$anchor3) => {
          var div_3 = root_122();
          var node_14 = child(div_3);
          snippet(node_14, () => $$props.children ?? noop, () => ({ render, startRendering, stopRendering }));
          reset(div_3);
          template_effect(() => {
            set_attribute(div_3, "style", $$props.style);
            set_class(div_3, clsx($$props.class));
            set_style(div_3, "position", "absolute");
            set_style(div_3, "transform", center() ? "translate3d(-50%,-50%,0)" : "none");
            set_style(div_3, "top", fullscreen() ? `${-get(height) / 2}px` : void 0);
            set_style(div_3, "left", fullscreen() ? `${-get(width) / 2}px` : void 0);
            set_style(div_3, "width", fullscreen() ? `${get(width)}px` : void 0);
            set_style(div_3, "height", fullscreen() ? `${get(height)}px` : void 0);
          });
          append($$anchor3, div_3);
        };
        if_block(node_12, ($$render) => {
          if (transform()) $$render(consequent_4);
          else $$render(alternate_3, false);
        });
      }
      append($$anchor2, fragment_10);
    },
    void 0,
    [241, 0]
  );
  append($$anchor, fragment);
  var $$pop = pop({
    get render() {
      return render;
    },
    get startRendering() {
      return startRendering;
    },
    get stopRendering() {
      return stopRendering;
    },
    ...legacy_api()
  });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  HTML = hmr(HTML, () => HTML[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HTML[HMR].source;
    set(HTML[HMR].source, module.default[HMR].original);
  });
}
var HTML_default = HTML;
mark_module_end(HTML);

// node_modules/@threlte/extras/dist/components/HUD/HUD.svelte
mark_module_start();
HUD[FILENAME] = "node_modules/@threlte/extras/dist/components/HUD/HUD.svelte";
function HUD($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HUD);
  const { scene } = createSceneContext();
  const { camera } = createCameraContext();
  const { renderStage, renderer, toneMapping } = useThrelte();
  let autoRender = prop($$props, "autoRender", 3, true), stage = prop($$props, "stage", 3, renderStage), ref = prop($$props, "ref", 15);
  const key2 = Symbol("threlte-hud-render-stage");
  user_pre_effect(() => {
    if (!autoRender()) {
      return;
    }
    stage().createTask(key2, () => {
      const { autoClear } = renderer;
      renderer.autoClear = false;
      renderer.toneMapping = $$props.toneMapping ?? toneMapping.current;
      renderer.clearDepth();
      renderer.render(scene, camera.current);
      renderer.autoClear = autoClear;
      renderer.toneMapping = toneMapping.current;
    });
    return () => stage().removeTask(key2);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, {
      is: scene,
      attach: false,
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(HUD, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: scene }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HUD = hmr(HUD, () => HUD[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HUD[HMR].source;
    set(HUD[HMR].source, module.default[HMR].original);
  });
}
var HUD_default = HUD;
mark_module_end(HUD);

// node_modules/@threlte/extras/dist/components/Float/Float.svelte
mark_module_start();
Float[FILENAME] = "node_modules/@threlte/extras/dist/components/Float/Float.svelte";
function Float($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Float);
  let speed = prop($$props, "speed", 3, 1), floatIntensity = prop($$props, "floatIntensity", 3, 1), floatingRange = prop($$props, "floatingRange", 19, () => [-0.1, 0.1]), rotationSpeed = prop($$props, "rotationSpeed", 3, 0), rotationIntensity = prop($$props, "rotationIntensity", 3, 0), seed = prop($$props, "seed", 19, () => 1e4 * Math.random()), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "speed",
      "floatIntensity",
      "floatingRange",
      "rotationSpeed",
      "rotationIntensity",
      "seed",
      "ref",
      "children"
    ],
    "props"
  );
  const outerGroup = new Group();
  const group = new Group();
  let t2 = seed();
  const map = MathUtils.mapLinear;
  let fSpeed = derived(() => Array.isArray(speed()) ? speed() : [speed(), speed(), speed()]);
  let fIntensity = derived(() => Array.isArray(floatIntensity()) ? floatIntensity() : [
    floatIntensity(),
    floatIntensity(),
    floatIntensity()
  ]);
  let fRange = derived(() => strict_equals(floatingRange().length, 3) ? floatingRange() : [[0, 0], floatingRange(), [0, 0]]);
  let rSpeed = derived(() => Array.isArray(rotationSpeed()) ? rotationSpeed() : [
    rotationSpeed(),
    rotationSpeed(),
    rotationSpeed()
  ]);
  let rIntensity = derived(() => Array.isArray(rotationIntensity()) ? rotationIntensity() : [
    rotationIntensity(),
    rotationIntensity(),
    rotationIntensity()
  ]);
  useTask((delta) => {
    t2 += delta;
    group.position.x = map(Math.sin(t2 / 4 * get(fSpeed)[0]) / 10, -0.1, 0.1, ...get(fRange)[0]) * get(fIntensity)[0];
    group.position.y = map(Math.sin(t2 / 4 * get(fSpeed)[1]) / 10, -0.1, 0.1, ...get(fRange)[1]) * get(fIntensity)[1];
    group.position.z = map(Math.sin(t2 / 4 * get(fSpeed)[2]) / 10, -0.1, 0.1, ...get(fRange)[2]) * get(fIntensity)[2];
    group.rotation.x = Math.cos(t2 / 4 * get(rSpeed)[0]) / 8 * get(rIntensity)[0];
    group.rotation.y = Math.sin(t2 / 4 * get(rSpeed)[1]) / 8 * get(rIntensity)[1];
    group.rotation.z = Math.sin(t2 / 4 * get(rSpeed)[2]) / 20 * get(rIntensity)[2];
    group.updateMatrix();
  });
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props({ is: outerGroup }, () => props, {
    children: wrap_snippet(Float, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, {
          is: group,
          matrixAutoUpdate: false,
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Float, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: group }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Float = hmr(Float, () => Float[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Float[HMR].source;
    set(Float[HMR].source, module.default[HMR].original);
  });
}
var Float_default = Float;
mark_module_end(Float);

// node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte
mark_module_start();
GLTF[FILENAME] = "node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte";
function GLTF($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GLTF);
  let gltf = prop($$props, "gltf", 15), scene = prop($$props, "scene", 15), animations = prop($$props, "animations", 15), asset = prop($$props, "asset", 15), cameras = prop($$props, "cameras", 15), scenes = prop($$props, "scenes", 15), userData = prop($$props, "userData", 15), parser = prop($$props, "parser", 15), materials = prop($$props, "materials", 15), nodes = prop($$props, "nodes", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "url",
      "dracoLoader",
      "meshoptDecoder",
      "ktx2Loader",
      "gltf",
      "scene",
      "animations",
      "asset",
      "cameras",
      "scenes",
      "userData",
      "parser",
      "materials",
      "nodes",
      "onload",
      "onunload",
      "onerror",
      "children"
    ],
    "props"
  );
  const loader = useGltf({
    dracoLoader: $$props.dracoLoader,
    meshoptDecoder: $$props.meshoptDecoder,
    ktx2Loader: $$props.ktx2Loader
  });
  const onLoad2 = (data) => {
    var _a2, _b2;
    if (gltf()) (_a2 = $$props.onunload) == null ? void 0 : _a2.call($$props);
    gltf(data);
    scene(data.scene);
    animations(data.animations);
    asset(data.asset);
    cameras(data.cameras);
    scenes(data.scenes);
    userData(data.userData);
    parser(data.parser);
    materials(data.materials);
    nodes(data.nodes);
    (_b2 = $$props.onload) == null ? void 0 : _b2.call($$props, gltf());
  };
  const onError2 = (error) => {
    var _a2;
    gltf(void 0);
    scene(void 0);
    animations(void 0);
    asset(void 0);
    cameras(void 0);
    scenes(void 0);
    userData(void 0);
    parser(void 0);
    nodes(void 0);
    materials(void 0);
    (_a2 = $$props.onerror) == null ? void 0 : _a2.call($$props, error);
  };
  const suspend = useSuspense();
  const loadGltf = async (url) => {
    try {
      const model = await suspend(loader.load(url));
      onLoad2(model);
    } catch (error) {
      onError2(error);
    }
  };
  user_pre_effect(() => {
    loadGltf($$props.url);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      T(node_1, spread_props(
        {
          get is() {
            return scene();
          }
        },
        () => props,
        {
          children: wrap_snippet(GLTF, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: scene() }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }
      ));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scene()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GLTF = hmr(GLTF, () => GLTF[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GLTF[HMR].source;
    set(GLTF[HMR].source, module.default[HMR].original);
  });
}
var GLTF_default = GLTF;
mark_module_end(GLTF);

// node_modules/three-viewport-gizmo/dist/three-viewport-gizmo.js
var Qt = Object.defineProperty;
var Jt = (s, e, t2) => e in s ? Qt(s, e, { enumerable: true, configurable: true, writable: true, value: t2 }) : s[e] = t2;
var g3 = (s, e, t2) => Jt(s, typeof e != "symbol" ? e + "" : e, t2);
var Ft2 = (s, e) => {
  const [t2, n2] = e.split("-");
  return Object.assign(s.style, {
    left: n2 === "left" ? "0" : n2 === "center" ? "50%" : "",
    right: n2 === "right" ? "0" : "",
    top: t2 === "top" ? "0" : t2 === "bottom" ? "" : "50%",
    bottom: t2 === "bottom" ? "0" : "",
    transform: `${n2 === "center" ? "translateX(-50%)" : ""} ${t2 === "center" ? "translateY(-50%)" : ""}`
  }), e;
};
var he = ({
  placement: s,
  size: e,
  offset: t2,
  id: n2,
  className: i
}) => {
  const o = document.createElement("div"), { top: l, left: a, right: c, bottom: h } = t2;
  return Object.assign(o.style, {
    id: n2,
    position: "absolute",
    zIndex: "1000",
    height: `${e}px`,
    width: `${e}px`,
    margin: `${l}px ${c}px ${h}px ${a}px`,
    borderRadius: "100%"
  }), Ft2(o, s), n2 && (o.id = n2), i && (o.className = i), o;
};
var fe = (s) => {
  const e = typeof s == "string" ? document.querySelector(s) : s;
  if (!e) throw Error("Invalid DOM element");
  return e;
};
function dt(s, e, t2) {
  return Math.max(e, Math.min(t2, s));
}
var pe = [
  ["x", 0, 3],
  ["y", 1, 4],
  ["z", 2, 5]
];
var xt2 = new Vector3();
function Et({ isSphere: s }, e, t2) {
  s && (xt2.set(0, 0, 1).applyQuaternion(t2.quaternion), pe.forEach(([n2, i, o]) => {
    const l = xt2[n2];
    let a = e[i], c = a.userData.opacity;
    a.material.opacity = dt(l >= 0 ? c : c / 2, 0, 1), a = e[o], c = a.userData.opacity, a.material.opacity = dt(l >= 0 ? c / 2 : c, 0, 1);
  }));
}
var me = (s, e, t2 = 10) => Math.abs(s.clientX - e.x) < t2 && Math.abs(s.clientY - e.y) < t2;
var At = new Raycaster();
var Mt = new Vector2();
var Tt = (s, e, t2, n2) => {
  Mt.set(
    (s.clientX - e.left) / e.width * 2 - 1,
    -((s.clientY - e.top) / e.height) * 2 + 1
  ), At.setFromCamera(Mt, t2);
  const i = At.intersectObjects(
    n2,
    false
  ), o = i.length ? i[0] : null;
  return !o || !o.object.visible ? null : o;
};
var rt = 1e-6;
var ge2 = 2 * Math.PI;
var Wt = ["x", "y", "z"];
var Y = [...Wt, "nx", "ny", "nz"];
var ye = [
  "right",
  "top",
  "front",
  "left",
  "bottom",
  "back"
];
var qt = 1.3;
var Lt = (s, e = true) => {
  const { material: t2, userData: n2 } = s, { color: i, opacity: o } = e ? n2.hover : n2;
  t2.color.set(i), t2.opacity = o;
};
var I2 = (s) => JSON.parse(JSON.stringify(s));
var ve = (s) => {
  const e = s.type || "sphere", t2 = e === "sphere", n2 = s.resolution || t2 ? 64 : 128, { container: i } = s;
  s.container = void 0, s = JSON.parse(JSON.stringify(s)), s.container = i, ye.forEach((c, h) => {
    s[c] && (s[Y[h]] = s[c]);
  });
  const o = {
    enabled: true,
    color: 16777215,
    opacity: 1,
    scale: 0.7,
    labelColor: 2236962,
    line: false,
    border: {
      size: 0,
      color: 14540253
    },
    hover: {
      color: t2 ? 16777215 : 9688043,
      labelColor: 2236962,
      opacity: 1,
      scale: 0.7,
      border: {
        size: 0,
        color: 14540253
      }
    }
  }, l = {
    line: false,
    scale: t2 ? 0.45 : 0.7,
    hover: {
      scale: t2 ? 0.5 : 0.7
    }
  }, a = {
    type: e,
    container: document.body,
    size: 128,
    placement: "top-right",
    resolution: n2,
    lineWidth: 20,
    radius: t2 ? 1 : 0.2,
    smoothness: 18,
    animated: true,
    speed: 1,
    background: {
      enabled: true,
      color: t2 ? 16777215 : 14739180,
      opacity: t2 ? 0 : 1,
      hover: {
        color: t2 ? 16777215 : 14739180,
        opacity: t2 ? 0.2 : 1
      }
    },
    font: {
      family: "sans-serif",
      weight: 900
    },
    offset: {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    },
    corners: {
      enabled: !t2,
      color: t2 ? 15915362 : 16777215,
      opacity: 1,
      scale: t2 ? 0.15 : 0.2,
      radius: 1,
      smoothness: 18,
      hover: {
        color: t2 ? 16777215 : 9688043,
        opacity: 1,
        scale: t2 ? 0.2 : 0.225
      }
    },
    edges: {
      enabled: !t2,
      color: t2 ? 15915362 : 16777215,
      opacity: t2 ? 1 : 0,
      radius: t2 ? 1 : 0.125,
      smoothness: 18,
      scale: t2 ? 0.15 : 1,
      hover: {
        color: t2 ? 16777215 : 9688043,
        opacity: 1,
        scale: t2 ? 0.2 : 1
      }
    },
    x: {
      ...I2(o),
      ...t2 ? {
        label: "X",
        color: 16725587,
        line: true
      } : {
        label: "Right"
      }
    },
    y: {
      ...I2(o),
      ...t2 ? {
        label: "Y",
        color: 9100032,
        line: true
      } : {
        label: "Top"
      }
    },
    z: {
      ...I2(o),
      ...t2 ? {
        label: "Z",
        color: 2920447,
        line: true
      } : {
        label: "Front"
      }
    },
    nx: {
      ...I2(l),
      label: t2 ? "" : "Left"
    },
    ny: {
      ...I2(l),
      label: t2 ? "" : "Bottom"
    },
    nz: {
      ...I2(l),
      label: t2 ? "" : "Back"
    }
  };
  return ut(s, a), Wt.forEach(
    (c) => ut(
      s[`n${c}`],
      I2(s[c])
    )
  ), { ...s, isSphere: t2 };
};
function ut(s, ...e) {
  if (s instanceof HTMLElement || typeof s != "object" || s === null)
    return s;
  for (const t2 of e)
    for (const n2 in t2)
      n2 !== "container" && n2 in t2 && (s[n2] === void 0 ? s[n2] = t2[n2] : typeof t2[n2] == "object" && !Array.isArray(t2[n2]) && (s[n2] = ut(
        s[n2] || {},
        t2[n2]
      )));
  return s;
}
var _e = (s, e = 2) => {
  const t2 = new Color(), n2 = e * 2, { isSphere: i, resolution: o, radius: l, font: a, corners: c, edges: h } = s, r = Y.map((p) => ({ ...s[p], radius: l }));
  i && c.enabled && r.push(c), i && h.enabled && r.push(h);
  const u2 = document.createElement("canvas"), d = u2.getContext("2d");
  u2.width = o * 2 + n2 * 2, u2.height = o * r.length + n2 * r.length;
  const [f, y2] = $(r, o, a);
  r.forEach(
    ({
      radius: p,
      label: S,
      color: k,
      labelColor: b,
      border: w,
      hover: {
        color: H2,
        labelColor: z2,
        border: C3
      }
    }, R2) => {
      const G2 = o * R2 + R2 * n2 + e;
      B3(
        e,
        G2,
        e,
        o,
        p,
        S,
        w,
        k,
        b
      ), B3(
        o + e * 3,
        G2,
        e,
        o,
        p,
        S,
        C3 ?? w,
        H2 ?? k,
        z2 ?? b
      );
    }
  );
  const _ = r.length, v4 = e / (o * 2), m = e / (o * 6), L = 1 / _, x = new CanvasTexture(u2);
  return x.repeat.set(0.5 - 2 * v4, L - 2 * m), x.offset.set(v4, 1 - m), Object.assign(x, {
    colorSpace: SRGBColorSpace,
    wrapS: RepeatWrapping,
    wrapT: RepeatWrapping,
    userData: {
      offsetX: v4,
      offsetY: m,
      cellHeight: L
    }
  }), x;
  function B3(p, S, k, b, w, H2, z2, C3, R2) {
    if (w = w * (b / 2), C3 != null && C3 !== "" && (G2(), d.fillStyle = t2.set(C3).getStyle(), d.fill()), z2 && z2.size) {
      const W2 = z2.size * b / 2;
      p += W2, S += W2, b -= z2.size * b, w = Math.max(0, w - W2), G2(), d.strokeStyle = t2.set(z2.color).getStyle(), d.lineWidth = z2.size * b, d.stroke();
    }
    H2 && U2(
      d,
      p + b / 2,
      S + (b + k) / 2,
      H2,
      t2.set(R2).getStyle()
    );
    function G2() {
      d.beginPath(), d.moveTo(p + w, S), d.lineTo(p + b - w, S), d.arcTo(p + b, S, p + b, S + w, w), d.lineTo(p + b, S + b - w), d.arcTo(p + b, S + b, p + b - w, S + b, w), d.lineTo(p + w, S + b), d.arcTo(p, S + b, p, S + b - w, w), d.lineTo(p, S + w), d.arcTo(p, S, p + w, S, w), d.closePath();
    }
  }
  function $(p, S, k) {
    const w = [...p].sort((J2, Yt2) => {
      var _t2, bt2;
      return (((_t2 = J2.label) == null ? void 0 : _t2.length) || 0) - (((bt2 = Yt2.label) == null ? void 0 : bt2.length) || 0);
    }).pop().label, { family: H2, weight: z2 } = k, C3 = i ? Math.sqrt(Math.pow(S * 0.7, 2) / 2) : S;
    let R2 = C3, G2 = 0, W2 = 0;
    do {
      d.font = `${z2} ${R2}px ${H2}`;
      const J2 = d.measureText(w);
      G2 = J2.width, W2 = J2.fontBoundingBoxDescent, R2--;
    } while (G2 > C3 && R2 > 0);
    const vt2 = C3 / W2, $t2 = Math.min(C3 / G2, vt2), Xt2 = Math.floor(R2 * $t2);
    return [`${z2} ${Xt2}px ${H2}`, vt2];
  }
  function U2(p, S, k, b, w) {
    p.font = f, p.textAlign = "center", p.textBaseline = "middle", p.fillStyle = w, p.fillText(b, S, k + (i ? y2 : 0));
  }
};
var be = (s, e) => s.offset.x = (e ? 0.5 : 0) + s.userData.offsetX;
var mt = (s, e) => {
  const {
    offset: t2,
    userData: { offsetY: n2, cellHeight: i }
  } = s;
  t2.y = 1 - (e + 1) * i + n2;
};
function gt(s, e, t2 = 2, n2 = 2) {
  const i = t2 / 2 - s, o = n2 / 2 - s, l = s / t2, a = (t2 - s) / t2, c = s / n2, h = (n2 - s) / n2, r = [i, o, 0, -i, o, 0, -i, -o, 0, i, -o, 0], u2 = [a, h, l, h, l, c, a, c], d = [
    3 * (e + 1) + 3,
    3 * (e + 1) + 4,
    e + 4,
    e + 5,
    2 * (e + 1) + 4,
    2,
    1,
    2 * (e + 1) + 3,
    3,
    4 * (e + 1) + 3,
    4,
    0
  ], f = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(
    (U2) => d[U2]
  );
  let y2, _, v4, m, L, x, B3, $;
  for (let U2 = 0; U2 < 4; U2++) {
    m = U2 < 1 || U2 > 2 ? i : -i, L = U2 < 2 ? o : -o, x = U2 < 1 || U2 > 2 ? a : l, B3 = U2 < 2 ? h : c;
    for (let p = 0; p <= e; p++)
      y2 = Math.PI / 2 * (U2 + p / e), _ = Math.cos(y2), v4 = Math.sin(y2), r.push(m + s * _, L + s * v4, 0), u2.push(x + l * _, B3 + c * v4), p < e && ($ = (e + 1) * U2 + p + 4, f.push(U2, $, $ + 1));
  }
  return new BufferGeometry().setIndex(new BufferAttribute(new Uint32Array(f), 1)).setAttribute(
    "position",
    new BufferAttribute(new Float32Array(r), 3)
  ).setAttribute("uv", new BufferAttribute(new Float32Array(u2), 2));
}
var we2 = (s, e) => {
  const t2 = new Vector3(), { isSphere: n2, radius: i, smoothness: o } = s, l = gt(i, o);
  return Y.map((a, c) => {
    const h = c < 3, r = Y[c], u2 = c ? e.clone() : e;
    mt(u2, c);
    const { enabled: d, scale: f, opacity: y2, hover: _ } = s[r], v4 = {
      map: u2,
      opacity: y2,
      transparent: true
    }, m = n2 ? new Sprite(new SpriteMaterial(v4)) : new Mesh(l, new MeshBasicMaterial(v4)), L = h ? r : r[1];
    return m.position[L] = (h ? 1 : -1) * (n2 ? qt : 1), n2 || m.lookAt(t2.copy(m.position).multiplyScalar(1.7)), m.scale.setScalar(f), m.renderOrder = 1, m.visible = d, m.userData = {
      scale: f,
      opacity: y2,
      hover: _
    }, m;
  });
};
var Se = (s, e) => {
  const { isSphere: t2, corners: n2 } = s;
  if (!n2.enabled) return [];
  const { color: i, opacity: o, scale: l, radius: a, smoothness: c, hover: h } = n2, r = t2 ? null : gt(a, c), u2 = {
    transparent: true,
    opacity: o
  }, d = [
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1
  ].map((y2) => y2 * 0.85), f = new Vector3();
  return Array(d.length / 3).fill(0).map((y2, _) => {
    if (t2) {
      const L = e.clone();
      mt(L, 6), u2.map = L;
    } else
      u2.color = i;
    const v4 = t2 ? new Sprite(new SpriteMaterial(u2)) : new Mesh(r, new MeshBasicMaterial(u2)), m = _ * 3;
    return v4.position.set(d[m], d[m + 1], d[m + 2]), t2 && v4.position.normalize().multiplyScalar(1.7), v4.scale.setScalar(l), v4.lookAt(f.copy(v4.position).multiplyScalar(2)), v4.renderOrder = 1, v4.userData = {
      color: i,
      opacity: o,
      scale: l,
      hover: h
    }, v4;
  });
};
var xe = (s, e, t2) => {
  const { isSphere: n2, edges: i } = s;
  if (!i.enabled) return [];
  const { color: o, opacity: l, scale: a, hover: c, radius: h, smoothness: r } = i, u2 = n2 ? null : gt(h, r, 1.2, 0.25), d = {
    transparent: true,
    opacity: l
  }, f = [
    0,
    1,
    1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    1,
    0,
    -1,
    -1,
    0
  ].map((_) => _ * 0.925), y2 = new Vector3();
  return Array(f.length / 3).fill(0).map((_, v4) => {
    if (n2) {
      const x = e.clone();
      mt(x, t2), d.map = x;
    } else
      d.color = o;
    const m = n2 ? new Sprite(new SpriteMaterial(d)) : new Mesh(u2, new MeshBasicMaterial(d)), L = v4 * 3;
    return m.position.set(f[L], f[L + 1], f[L + 2]), n2 && m.position.normalize().multiplyScalar(1.7), m.scale.setScalar(a), m.lookAt(y2.copy(m.position).multiplyScalar(2)), !n2 && !m.position.y && (m.rotation.z = Math.PI / 2), m.renderOrder = 1, m.userData = {
      color: o,
      opacity: l,
      scale: a,
      hover: c
    }, m;
  });
};
function Ee(s, e = false) {
  const t2 = s[0].index !== null, n2 = new Set(Object.keys(s[0].attributes)), i = new Set(Object.keys(s[0].morphAttributes)), o = {}, l = {}, a = s[0].morphTargetsRelative, c = new BufferGeometry();
  let h = 0;
  for (let r = 0; r < s.length; ++r) {
    const u2 = s[r];
    let d = 0;
    if (t2 !== (u2.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const f in u2.attributes) {
      if (!n2.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
      o[f] === void 0 && (o[f] = []), o[f].push(u2.attributes[f]), d++;
    }
    if (d !== n2.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". Make sure all geometries have the same number of attributes."), null;
    if (a !== u2.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const f in u2.morphAttributes) {
      if (!i.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ".  .morphAttributes must be consistent throughout all geometries."), null;
      l[f] === void 0 && (l[f] = []), l[f].push(u2.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (t2)
        f = u2.index.count;
      else if (u2.attributes.position !== void 0)
        f = u2.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". The geometry must have either an index or a position attribute"), null;
      c.addGroup(h, f, r), h += f;
    }
  }
  if (t2) {
    let r = 0;
    const u2 = [];
    for (let d = 0; d < s.length; ++d) {
      const f = s[d].index;
      for (let y2 = 0; y2 < f.count; ++y2)
        u2.push(f.getX(y2) + r);
      r += s[d].attributes.position.count;
    }
    c.setIndex(u2);
  }
  for (const r in o) {
    const u2 = Ut(o[r]);
    if (!u2)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " attribute."), null;
    c.setAttribute(r, u2);
  }
  for (const r in l) {
    const u2 = l[r][0].length;
    if (u2 === 0) break;
    c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[r] = [];
    for (let d = 0; d < u2; ++d) {
      const f = [];
      for (let _ = 0; _ < l[r].length; ++_)
        f.push(l[r][_][d]);
      const y2 = Ut(f);
      if (!y2)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " morphAttribute."), null;
      c.morphAttributes[r].push(y2);
    }
  }
  return c;
}
function Ut(s) {
  let e, t2, n2, i = -1, o = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (e === void 0 && (e = r.array.constructor), e !== r.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t2 === void 0 && (t2 = r.itemSize), t2 !== r.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (n2 === void 0 && (n2 = r.normalized), n2 !== r.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (i === -1 && (i = r.gpuType), i !== r.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    o += r.count * t2;
  }
  const l = new e(o), a = new BufferAttribute(l, t2, n2);
  let c = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (r.isInterleavedBufferAttribute) {
      const u2 = c / t2;
      for (let d = 0, f = r.count; d < f; d++)
        for (let y2 = 0; y2 < t2; y2++) {
          const _ = r.getComponent(d, y2);
          a.setComponent(d + u2, y2, _);
        }
    } else
      l.set(r.array, c);
    c += r.count * t2;
  }
  return i !== void 0 && (a.gpuType = i), a;
}
var Ae2 = (s, e) => {
  const {
    isSphere: t2,
    background: { enabled: n2, color: i, opacity: o, hover: l }
  } = e;
  let a;
  const c = new MeshBasicMaterial({
    color: i,
    side: BackSide,
    opacity: o,
    transparent: true,
    depthWrite: false
  });
  if (!n2) return null;
  if (t2)
    a = new Mesh(
      new SphereGeometry(1.8, 64, 64),
      c
    );
  else {
    let h;
    s.forEach((r) => {
      const u2 = r.scale.x;
      r.scale.setScalar(0.9), r.updateMatrix();
      const d = r.geometry.clone();
      d.applyMatrix4(r.matrix), h = h ? Ee([h, d]) : d, r.scale.setScalar(u2);
    }), a = new Mesh(h, c);
  }
  return a.userData = {
    color: i,
    opacity: o,
    hover: l
  }, a;
};
var Bt = new Box3();
var Z = new Vector3();
var Vt = class extends InstancedBufferGeometry {
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t2 = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n2 = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n2), this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("uv", new Float32BufferAttribute(t2, 2));
  }
  applyMatrix4(e) {
    const t2 = this.attributes.instanceStart, n2 = this.attributes.instanceEnd;
    return t2 !== void 0 && (t2.applyMatrix4(e), n2.applyMatrix4(e), t2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t2;
    e instanceof Float32Array ? t2 = e : Array.isArray(e) && (t2 = new Float32Array(e));
    const n2 = new InstancedInterleavedBuffer(t2, 6, 1);
    return this.setAttribute("instanceStart", new InterleavedBufferAttribute(n2, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(n2, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t2;
    e instanceof Float32Array ? t2 = e : Array.isArray(e) && (t2 = new Float32Array(e));
    const n2 = new InstancedInterleavedBuffer(t2, 6, 1);
    return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(n2, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(n2, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new WireframeGeometry(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t2 = e.geometry;
    return this.setPositions(t2.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
    e !== void 0 && t2 !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Bt.setFromBufferAttribute(t2), this.boundingBox.union(Bt));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
    if (e !== void 0 && t2 !== void 0) {
      const n2 = this.boundingSphere.center;
      this.boundingBox.getCenter(n2);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        Z.fromBufferAttribute(e, o), i = Math.max(i, n2.distanceToSquared(Z)), Z.fromBufferAttribute(t2, o), i = Math.max(i, n2.distanceToSquared(Z));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
};
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib.line = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var yt2 = class extends ShaderMaterial {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
      vertexShader: ShaderLib.line.vertexShader,
      fragmentShader: ShaderLib.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === true !== this.dashed && (this.needsUpdate = true), e === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === true !== this.alphaToCoverage && (this.needsUpdate = true), e === true ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = true) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = false));
  }
};
var zt = new Vector3();
var Ct2 = new Vector3();
var E = new Vector4();
var A2 = new Vector4();
var O = new Vector4();
var at = new Vector3();
var ct2 = new Matrix4();
var M = new Line3();
var Ot = new Vector3();
var K = new Box3();
var tt = new Sphere();
var D = new Vector4();
var P;
var F;
function Dt(s, e, t2) {
  return D.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), D.multiplyScalar(1 / D.w), D.x = F / t2.width, D.y = F / t2.height, D.applyMatrix4(s.projectionMatrixInverse), D.multiplyScalar(1 / D.w), Math.abs(Math.max(D.x, D.y));
}
function Me(s, e) {
  const t2 = s.matrixWorld, n2 = s.geometry, i = n2.attributes.instanceStart, o = n2.attributes.instanceEnd, l = Math.min(n2.instanceCount, i.count);
  for (let a = 0, c = l; a < c; a++) {
    M.start.fromBufferAttribute(i, a), M.end.fromBufferAttribute(o, a), M.applyMatrix4(t2);
    const h = new Vector3(), r = new Vector3();
    P.distanceSqToSegment(M.start, M.end, r, h), r.distanceTo(h) < F * 0.5 && e.push({
      point: r,
      pointOnLine: h,
      distance: P.origin.distanceTo(r),
      object: s,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function Te(s, e, t2) {
  const n2 = e.projectionMatrix, o = s.material.resolution, l = s.matrixWorld, a = s.geometry, c = a.attributes.instanceStart, h = a.attributes.instanceEnd, r = Math.min(a.instanceCount, c.count), u2 = -e.near;
  P.at(1, O), O.w = 1, O.applyMatrix4(e.matrixWorldInverse), O.applyMatrix4(n2), O.multiplyScalar(1 / O.w), O.x *= o.x / 2, O.y *= o.y / 2, O.z = 0, at.copy(O), ct2.multiplyMatrices(e.matrixWorldInverse, l);
  for (let d = 0, f = r; d < f; d++) {
    if (E.fromBufferAttribute(c, d), A2.fromBufferAttribute(h, d), E.w = 1, A2.w = 1, E.applyMatrix4(ct2), A2.applyMatrix4(ct2), E.z > u2 && A2.z > u2)
      continue;
    if (E.z > u2) {
      const x = E.z - A2.z, B3 = (E.z - u2) / x;
      E.lerp(A2, B3);
    } else if (A2.z > u2) {
      const x = A2.z - E.z, B3 = (A2.z - u2) / x;
      A2.lerp(E, B3);
    }
    E.applyMatrix4(n2), A2.applyMatrix4(n2), E.multiplyScalar(1 / E.w), A2.multiplyScalar(1 / A2.w), E.x *= o.x / 2, E.y *= o.y / 2, A2.x *= o.x / 2, A2.y *= o.y / 2, M.start.copy(E), M.start.z = 0, M.end.copy(A2), M.end.z = 0;
    const _ = M.closestPointToPointParameter(at, true);
    M.at(_, Ot);
    const v4 = MathUtils.lerp(E.z, A2.z, _), m = v4 >= -1 && v4 <= 1, L = at.distanceTo(Ot) < F * 0.5;
    if (m && L) {
      M.start.fromBufferAttribute(c, d), M.end.fromBufferAttribute(h, d), M.start.applyMatrix4(l), M.end.applyMatrix4(l);
      const x = new Vector3(), B3 = new Vector3();
      P.distanceSqToSegment(M.start, M.end, B3, x), t2.push({
        point: B3,
        pointOnLine: x,
        distance: P.origin.distanceTo(B3),
        object: s,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
var Le = class extends Mesh {
  constructor(e = new Vt(), t2 = new yt2({ color: Math.random() * 16777215 })) {
    super(e, t2), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t2 = e.attributes.instanceStart, n2 = e.attributes.instanceEnd, i = new Float32Array(2 * t2.count);
    for (let l = 0, a = 0, c = t2.count; l < c; l++, a += 2)
      zt.fromBufferAttribute(t2, l), Ct2.fromBufferAttribute(n2, l), i[a] = a === 0 ? 0 : i[a - 1], i[a + 1] = i[a] + zt.distanceTo(Ct2);
    const o = new InstancedInterleavedBuffer(i, 2, 1);
    return e.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(o, 1, 1)), this;
  }
  raycast(e, t2) {
    const n2 = this.material.worldUnits, i = e.camera;
    i === null && !n2 && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    P = e.ray;
    const l = this.matrixWorld, a = this.geometry, c = this.material;
    F = c.linewidth + o, a.boundingSphere === null && a.computeBoundingSphere(), tt.copy(a.boundingSphere).applyMatrix4(l);
    let h;
    if (n2)
      h = F * 0.5;
    else {
      const u2 = Math.max(i.near, tt.distanceToPoint(P.origin));
      h = Dt(i, u2, c.resolution);
    }
    if (tt.radius += h, P.intersectsSphere(tt) === false)
      return;
    a.boundingBox === null && a.computeBoundingBox(), K.copy(a.boundingBox).applyMatrix4(l);
    let r;
    if (n2)
      r = F * 0.5;
    else {
      const u2 = Math.max(i.near, K.distanceToPoint(P.origin));
      r = Dt(i, u2, c.resolution);
    }
    K.expandByScalar(r), P.intersectsBox(K) !== false && (n2 ? Me(this, t2) : Te(this, i, t2));
  }
};
var Nt = class extends Vt {
  constructor() {
    super(), this.isLineGeometry = true, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t2 = e.length - 3, n2 = new Float32Array(2 * t2);
    for (let i = 0; i < t2; i += 3)
      n2[2 * i] = e[i], n2[2 * i + 1] = e[i + 1], n2[2 * i + 2] = e[i + 2], n2[2 * i + 3] = e[i + 3], n2[2 * i + 4] = e[i + 4], n2[2 * i + 5] = e[i + 5];
    return super.setPositions(n2), this;
  }
  setColors(e) {
    const t2 = e.length - 3, n2 = new Float32Array(2 * t2);
    for (let i = 0; i < t2; i += 3)
      n2[2 * i] = e[i], n2[2 * i + 1] = e[i + 1], n2[2 * i + 2] = e[i + 2], n2[2 * i + 3] = e[i + 3], n2[2 * i + 4] = e[i + 4], n2[2 * i + 5] = e[i + 5];
    return super.setColors(n2), this;
  }
  fromLine(e) {
    const t2 = e.geometry;
    return this.setPositions(t2.attributes.position.array), this;
  }
};
var Ue = class extends Le {
  constructor(e = new Nt(), t2 = new yt2({ color: Math.random() * 16777215 })) {
    super(e, t2), this.isLine2 = true, this.type = "Line2";
  }
};
var Be = (s) => {
  const e = new Color(), t2 = [], n2 = [], { isSphere: i } = s;
  if (Y.forEach((a, c) => {
    const { enabled: h, line: r, scale: u2, color: d } = s[a];
    if (!h || !r) return;
    const f = c < 3 ? 1 : -1, _ = (i ? qt - u2 / 2 : 0.975) * f;
    t2.push(
      a.includes("x") ? _ : 0,
      a.includes("y") ? _ : 0,
      a.includes("z") ? _ : 0,
      0,
      0,
      0
    );
    const v4 = e.set(d).toArray();
    n2.push(...v4, ...v4);
  }), !t2.length) return null;
  const o = new Nt().setPositions(t2).setColors(n2), l = new yt2({
    linewidth: s.lineWidth,
    vertexColors: true,
    resolution: new Vector2(window.innerWidth, window.innerHeight)
  });
  return new Ue(o, l).computeLineDistances();
};
var ze = (s) => {
  const { corners: e, edges: t2 } = s, n2 = [], i = _e(s), o = we2(s, i);
  n2.push(...o), e.enabled && n2.push(...Se(s, i)), t2.enabled && n2.push(...xe(s, i, e.enabled ? 7 : 6));
  const l = Ae2(o, s), a = Be(s);
  return [n2, l, a];
};
var X = (s, e = true) => {
  const { material: t2, userData: n2 } = s, { opacity: i, color: o, scale: l } = e ? n2.hover : n2;
  s.scale.setScalar(l), t2.opacity = i, t2.map ? be(t2.map, e) : t2.color.set(o);
};
var q = new Matrix4();
var Ce = new Spherical();
var Pt = new Vector3();
var Oe = new Vector2();
var Re = class extends Object3D {
  /**
   * Creates a new ViewportGizmo instance.
   *
   * @param camera - The camera to be controlled by this gizmo
   * @param renderer - The WebGL renderer used to render the scene
   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.
   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string
   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'
   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128
   * @param options.placement - Position of the gizmo in the viewport
   *    Options include:
   *    - `"top-left"`
   *    - `"top-center"`
   *    - `"top-right"`
   *    - `"center-left"`
   *    - `"center-center"`
   *    - `"center-right"`
   *    - `"bottom-left"`
   *    - `"bottom-center"`
   *    - `"bottom-right"`
   * @param options.offset - Offset of the gizmo from container edges in pixels
   * @param options.offset.left - Offset from the left edge
   * @param options.offset.top - Offset from the top edge
   * @param options.offset.right - Offset from the right edge
   * @param options.offset.bottom - Offset from the bottom edge
   * @param options.animated - Whether view changes should be animated. Defaults to true
   * @param options.speed - Animation speed multiplier. Defaults to 1
   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube
   * @param options.lineWidth - Width of the axes lines in pixels
   * @param options.id - HTML `id` attribute for the gizmo container
   * @param options.className - HTML `class` attribute for the gizmo container
   * @param options.font - Font configuration for axis labels
   * @param options.font.family - Font family for axis labels
   * @param options.font.weight - Font weight for axis labels
   * @param options.background - Configuration for the background sphere/cube
   * @param options.background.enabled - Whether to display the background
   * @param options.background.color - Color of the background in normal state
   * @param options.background.opacity - Opacity of the background in normal state
   * @param options.background.hover.color - Color of the background when hovered
   * @param options.background.hover.opacity - Opacity of the background when hovered
   * @param options.corners - Configuration for corner indicators
   * @param options.corners.enabled - Whether to display corner indicators
   * @param options.corners.color - Base color of corner indicators
   * @param options.corners.opacity - Opacity of corner indicators
   * @param options.corners.scale - Scale multiplier for corner indicators
   * @param options.corners.radius - Radius of corner indicators
   * @param options.corners.smoothness - Smoothness of corner indicators
   * @param options.corners.hover.color - Color of corner indicators when hovered
   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered
   * @param options.corners.hover.scale - Scale of corner indicators when hovered
   * @param options.edges - Configuration for edge indicators
   * @param options.edges.enabled - Whether to display edge indicators
   * @param options.edges.color - Base color of edge indicators
   * @param options.edges.opacity - Opacity of edge indicators
   * @param options.edges.scale - Scale multiplier for edge indicators
   * @param options.edges.radius - Radius of edge indicators
   * @param options.edges.smoothness - Smoothness of edge indicators
   * @param options.edges.hover.color - Color of edge indicators when hovered
   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered
   * @param options.edges.hover.scale - Scale of edge indicators when hovered
   * @param options.x - Configuration for positive X axis/face
   * @param options.y - Configuration for positive Y axis/face
   * @param options.z - Configuration for positive Z axis/face
   * @param options.nx - Configuration for negative X axis/face
   * @param options.ny - Configuration for negative Y axis/face
   * @param options.nz - Configuration for negative Z axis/face
   *
   * @remarks Axis-specific configuration can also use alias names for cube mode:
   * - `right` (same as `x`)
   * - `left` (same as `nx`)
   * - `top` (same as `y`)
   * - `bottom` (same as `ny`)
   * - `front` (same as `z`)
   * - `back` (same as `nz`)
   *
   * For each axis/face configuration, the following options are available:
   * @param options.AXIS.enabled - Whether to draw the axis
   * @param options.AXIS.label - Custom text label for the axis
   * @param options.AXIS.opacity - Axis opacity
   * @param options.AXIS.scale - Scale multiplier for indicator size
   * @param options.AXIS.line - Whether to draw the axis line
   * @param options.AXIS.color - Axis indicator background color
   * @param options.AXIS.labelColor - Axis label color
   * @param options.AXIS.border.size - Border size around the axis indicator
   * @param options.AXIS.border.color - Border color around the axis indicator
   * @param options.AXIS.hover.color - Fill color on hover
   * @param options.AXIS.hover.labelColor - Label text color on hover
   * @param options.AXIS.hover.opacity - Opacity when hovered
   * @param options.AXIS.hover.scale - Indicator scale when hovered
   * @param options.AXIS.hover.border.size - Hover border size
   * @param options.AXIS.hover.border.color - Hover border color
   */
  constructor(t2, n2, i = {}) {
    super();
    g3(this, "type", "ViewportGizmo");
    g3(this, "enabled", true);
    g3(this, "camera");
    g3(this, "renderer");
    g3(this, "options");
    g3(this, "target", new Vector3());
    g3(this, "animated", true);
    g3(this, "speed", 1);
    g3(this, "animating", false);
    g3(this, "_options");
    g3(this, "_intersections");
    g3(this, "_background", null);
    g3(this, "_viewport", new Vector4());
    g3(this, "_originalViewport", new Vector4());
    g3(this, "_originalScissor", new Vector4());
    g3(this, "_camera");
    g3(this, "_container");
    g3(this, "_domElement");
    g3(this, "_domRect");
    g3(this, "_dragging", false);
    g3(this, "_distance", 0);
    g3(this, "_clock", new Clock());
    g3(this, "_targetPosition", new Vector3());
    g3(this, "_targetQuaternion", new Quaternion());
    g3(this, "_quaternionStart", new Quaternion());
    g3(this, "_quaternionEnd", new Quaternion());
    g3(this, "_pointerStart", new Vector2());
    g3(this, "_focus", null);
    g3(this, "_placement");
    g3(this, "_controls");
    g3(this, "_controlsListeners");
    this.camera = t2, this.renderer = n2, this.set(i);
  }
  /** Gets the current placement of the gizmo relative to its container. */
  get placement() {
    return this._placement;
  }
  /**
   * Sets and update the placement of the gizmo relative to its container.
   *
   * @param placement - The new placement position
   */
  set placement(t2) {
    this._placement = Ft2(this._domElement, t2), this.domUpdate();
  }
  /**
   * Regenerates the gizmo with the new options.
   *
   * @remarks
   * - Not recommended for use in real-time rendering or animation loops
   * - Provides a way to completely rebuild the gizmo with new options
   * - Can be computationally expensive, so use sparingly
   */
  set(t2 = {}) {
    this.dispose(), this.options = t2, this._options = ve(t2), this._camera = this._options.isSphere ? new OrthographicCamera(-1.8, 1.8, 1.8, -1.8, 5, 10) : new PerspectiveCamera(26, 1, 5, 10), this._camera.position.set(0, 0, 7);
    const [n2, i, o] = ze(this._options);
    i && this.add(i), o && this.add(o), this.add(...n2), this._background = i, this._intersections = n2;
    const { container: l, animated: a, speed: c } = this._options;
    return this.animated = a, this.speed = c, this._container = l ? fe(l) : document.body, this._domElement = he(this._options), this._domElement.onpointerdown = (h) => this._onPointerDown(h), this._domElement.onpointermove = (h) => this._onPointerMove(h), this._domElement.onpointerleave = () => this._onPointerLeave(), this._container.appendChild(this._domElement), this._controls && this.attachControls(this._controls), this.update(), this;
  }
  /**
   * Renders the gizmo to the screen.
   * This method handles viewport and scissor management to ensure the gizmo
   * renders correctly without affecting the main scene rendering.
   *
   * @returns The gizmo instance for method chaining
   */
  render() {
    this.animating && this._animate();
    const { renderer: t2, _viewport: n2 } = this, i = t2.getScissorTest(), o = t2.autoClear;
    return t2.autoClear = false, t2.setViewport(n2), i && t2.setScissor(n2), t2.clear(false, true, false), t2.render(this, this._camera), t2.setViewport(this._originalViewport), i && t2.setScissor(this._originalScissor), t2.autoClear = o, this;
  }
  /**
   * Updates the gizmo's DOM-related properties based on its current position
   * and size in the document.
   *
   * @returns The gizmo instance for method chaining
   */
  domUpdate() {
    this._domRect = this._domElement.getBoundingClientRect();
    const t2 = this.renderer, n2 = this._domRect, i = t2.domElement.getBoundingClientRect();
    return this._viewport.set(
      n2.left - i.left,
      t2.domElement.clientHeight - (n2.top - i.top + n2.height),
      n2.width,
      n2.height
    ), t2.getViewport(this._originalViewport), t2.getScissorTest() && t2.getScissor(this._originalScissor), this;
  }
  /**
   * Updates the gizmo's orientation to match the current camera orientation.
   *
   * @returns The gizmo instance for method chaining
   */
  cameraUpdate() {
    return this._updateOrientation(), this;
  }
  /**
   * Performs a complete update of the gizmo, including both DOM and camera-related updates.
   *
   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.
   *
   * @returns The gizmo instance for method chaining
   */
  update(t2 = true) {
    return t2 && this._controls && this._controls.update(), this.domUpdate().cameraUpdate();
  }
  /**
   * Connects OrbitControls with the gizmo, handling interaction states and updates.
   * Automatically detaches any previously attached controls.
   *
   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}
   */
  attachControls(t2) {
    return this.detachControls(), this.target = t2.target, this._controlsListeners = {
      start: () => t2.enabled = false,
      end: () => t2.enabled = true,
      change: () => this.update(false)
    }, this.addEventListener("start", this._controlsListeners.start), this.addEventListener("end", this._controlsListeners.end), t2.addEventListener("change", this._controlsListeners.change), this._controls = t2, this;
  }
  /** Removes all control event listeners and references. Safe to call multiple times. */
  detachControls() {
    if (!(!this._controlsListeners || !this._controls))
      return this.target = new Vector3().copy(this._controls.target), this.removeEventListener("start", this._controlsListeners.start), this.removeEventListener("end", this._controlsListeners.end), this._controls.removeEventListener(
        "change",
        this._controlsListeners.change
      ), this._controlsListeners = void 0, this._controls = void 0, this;
  }
  /** Cleans up all resources including geometries, materials, textures, and event listeners. */
  dispose() {
    var t2;
    this.detachControls(), this.children.forEach((n2) => {
      var o, l, a, c;
      this.remove(n2);
      const i = n2;
      (o = i.material) == null || o.dispose(), (a = (l = i.material) == null ? void 0 : l.map) == null || a.dispose(), (c = i.geometry) == null || c.dispose();
    }), (t2 = this._domElement) == null || t2.remove();
  }
  /**
   * Updates the gizmo's orientation either based on the camera or internal state.
   *
   * @private
   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)
   */
  _updateOrientation(t2 = true) {
    t2 && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), Et(this._options, this._intersections, this.camera);
  }
  /**
   * Handles the animation of camera position and orientation changes.
   *
   * @private
   */
  _animate() {
    const { position: t2, quaternion: n2 } = this.camera;
    if (t2.set(0, 0, 1), !this.animated) {
      t2.applyQuaternion(this._quaternionEnd).multiplyScalar(this._distance).add(this.target), n2.copy(this._targetQuaternion), this._updateOrientation(), this.animating = false, this.dispatchEvent({ type: "change" }), this.dispatchEvent({ type: "end" });
      return;
    }
    const o = this._clock.getDelta() * ge2 * this.speed;
    this._quaternionStart.rotateTowards(this._quaternionEnd, o), t2.applyQuaternion(this._quaternionStart).multiplyScalar(this._distance).add(this.target), n2.rotateTowards(this._targetQuaternion, o), this._updateOrientation(), requestAnimationFrame(() => this.dispatchEvent({ type: "change" })), this._quaternionStart.angleTo(this._quaternionEnd) < rt && (this.animating = false, this.dispatchEvent({ type: "end" }));
  }
  /**
   * Sets the camera orientation to look at the target from a specific axis.
   *
   * @private
   * @param position - The axis point position
   */
  _setOrientation(t2) {
    const n2 = this.camera, i = this.target;
    this._targetPosition.copy(t2).multiplyScalar(this._distance), q.setPosition(this._targetPosition).lookAt(this._targetPosition, this.position, this.up), this._targetQuaternion.setFromRotationMatrix(q), this._targetPosition.add(i), q.lookAt(this._targetPosition, i, this.up), this._quaternionEnd.setFromRotationMatrix(q), q.setPosition(n2.position).lookAt(n2.position, i, this.up), this._quaternionStart.setFromRotationMatrix(q), this.animating = true, this._clock.start(), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles the pointer down event for starting drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerDown(t2) {
    if (!this.enabled) return;
    const n2 = (c) => {
      if (!this._dragging) {
        if (me(c, this._pointerStart)) return;
        this._dragging = true;
      }
      const h = Oe.set(c.clientX, c.clientY).sub(this._pointerStart).multiplyScalar(1 / this._domRect.width * Math.PI), r = Ce.setFromVector3(
        Pt.subVectors(this.camera.position, this.target)
      );
      r.theta = l - h.x, r.phi = dt(
        a - h.y,
        rt,
        Math.PI - rt
      ), this.camera.position.setFromSpherical(r).add(this.target), this.camera.lookAt(this.target), this.quaternion.copy(this.camera.quaternion).invert(), this._updateOrientation(false), this.dispatchEvent({ type: "change" });
    }, i = () => {
      if (document.removeEventListener("pointermove", n2, false), document.removeEventListener("pointerup", i, false), !this._dragging) return this._handleClick(t2);
      this._focus && (X(this._focus, false), this._focus = null), this._dragging = false, this.dispatchEvent({ type: "end" });
    };
    if (this.animating) return;
    t2.preventDefault(), this._pointerStart.set(t2.clientX, t2.clientY);
    const o = new Spherical().setFromVector3(
      Pt.subVectors(this.camera.position, this.target)
    ), l = o.theta, a = o.phi;
    this._distance = o.radius, document.addEventListener("pointermove", n2, false), document.addEventListener("pointerup", i, false), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles pointer move events for hover effects and drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerMove(t2) {
    !this.enabled || this._dragging || (this._background && Lt(this._background, true), this._handleHover(t2));
  }
  /**
   * Handles pointer leave events to reset hover states.
   *
   * @private
   */
  _onPointerLeave() {
    !this.enabled || this._dragging || (this._background && Lt(this._background, false), this._focus && X(this._focus, false), this._domElement.style.cursor = "");
  }
  /**
   * Handles click events for axis selection.
   *
   * @private
   * @param e - The pointer event
   */
  _handleClick(t2) {
    const n2 = Tt(
      t2,
      this._domRect,
      this._camera,
      this._intersections
    );
    this._focus && (X(this._focus, false), this._focus = null), n2 && (this._setOrientation(n2.object.position), this.dispatchEvent({ type: "change" }));
  }
  /**
   * Handles hover effects for interactive elements.
   *
   * @private
   * @param e - The pointer event
   */
  _handleHover(t2) {
    const n2 = Tt(
      t2,
      this._domRect,
      this._camera,
      this._intersections
    ), i = (n2 == null ? void 0 : n2.object) || null;
    this._focus !== i && (this._domElement.style.cursor = i ? "pointer" : "", this._focus && X(this._focus, false), (this._focus = i) ? X(i, true) : Et(this._options, this._intersections, this.camera));
  }
};

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray();
var _plane = new Plane();
var _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var _v = new Vector3();
var _twoPI = 2 * Math.PI;
var _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
var _EPS = 1e-6;
var OrbitControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.enabled = true;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.keyRotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect();
    }
    this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position2 = this.object.position;
    _v.copy(position2).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min = this.minAzimuthAngle;
    let max2 = this.maxAzimuthAngle;
    if (isFinite(min) && isFinite(max2)) {
      if (min < -Math.PI) min += _twoPI;
      else if (min > Math.PI) min -= _twoPI;
      if (max2 < -Math.PI) max2 += _twoPI;
      else if (max2 > Math.PI) max2 -= _twoPI;
      if (min <= max2) {
        this._spherical.theta = Math.max(min, Math.min(max2, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min + max2) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max2, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position2.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance);
    this._panOffset.add(_v);
  }
  _panUp(distance, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position2 = this.object.position;
      _v.copy(position2).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y2) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y2 - rect.top;
    const w = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._rotateStart.set(x, y2);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._panStart.set(x, y2);
    }
  }
  _handleTouchStartDolly(event) {
    const position2 = this._getSecondPointerPosition(event);
    const dx = event.pageX - position2.x;
    const dy = event.pageY - position2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._rotateEnd.set(x, y2);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._panEnd.set(x, y2);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position2 = this._getSecondPointerPosition(event);
    const dx = event.pageX - position2.x;
    const dy = event.pageY - position2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position2.x) * 0.5;
    const centerY = (event.pageY + position2.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position2 = this._pointerPositions[event.pointerId];
    if (position2 === void 0) {
      position2 = new Vector2();
      this._pointerPositions[event.pointerId] = position2;
    }
    position2.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
};
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position2 = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position2.x, pageY: position2.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}

// node_modules/three/examples/jsm/controls/TrackballControls.js
var _changeEvent2 = { type: "change" };
var _startEvent2 = { type: "start" };
var _endEvent2 = { type: "end" };
var _EPS2 = 1e-6;
var _STATE2 = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
var _v2 = new Vector2();
var _mouseChange = new Vector2();
var _objectUp = new Vector3();
var _pan = new Vector3();
var _axis = new Vector3();
var _quaternion = new Quaternion();
var _eyeDirection = new Vector3();
var _objectUpDirection = new Vector3();
var _objectSidewaysDirection = new Vector3();
var _moveDirection = new Vector3();
var TrackballControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.enabled = true;
    this.screen = { left: 0, top: 0, width: 0, height: 0 };
    this.rotateSpeed = 1;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;
    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ];
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.state = _STATE2.NONE;
    this.keyState = _STATE2.NONE;
    this.target = new Vector3();
    this._lastPosition = new Vector3();
    this._lastZoom = 1;
    this._touchZoomDistanceStart = 0;
    this._touchZoomDistanceEnd = 0;
    this._lastAngle = 0;
    this._eye = new Vector3();
    this._movePrev = new Vector2();
    this._moveCurr = new Vector2();
    this._lastAxis = new Vector3();
    this._zoomStart = new Vector2();
    this._zoomEnd = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._pointers = [];
    this._pointerPositions = {};
    this._onPointerMove = onPointerMove2.bind(this);
    this._onPointerDown = onPointerDown2.bind(this);
    this._onPointerUp = onPointerUp2.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu2.bind(this);
    this._onMouseWheel = onMouseWheel2.bind(this);
    this._onKeyDown = onKeyDown2.bind(this);
    this._onKeyUp = onKeyUp.bind(this);
    this._onTouchStart = onTouchStart2.bind(this);
    this._onTouchMove = onTouchMove2.bind(this);
    this._onTouchEnd = onTouchEnd.bind(this);
    this._onMouseDown = onMouseDown2.bind(this);
    this._onMouseMove = onMouseMove2.bind(this);
    this._onMouseUp = onMouseUp.bind(this);
    this._target0 = this.target.clone();
    this._position0 = this.object.position.clone();
    this._up0 = this.object.up.clone();
    this._zoom0 = this.object.zoom;
    if (domElement !== null) {
      this.connect();
      this.handleResize();
    }
    this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const box = this.domElement.getBoundingClientRect();
    const d = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target);
    if (!this.noRotate) {
      this._rotateCamera();
    }
    if (!this.noZoom) {
      this._zoomCamera();
    }
    if (!this.noPan) {
      this._panCamera();
    }
    this.object.position.addVectors(this.target, this._eye);
    if (this.object.isPerspectiveCamera) {
      this._checkDistances();
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS2) {
        this.dispatchEvent(_changeEvent2);
        this._lastPosition.copy(this.object.position);
      }
    } else if (this.object.isOrthographicCamera) {
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS2 || this._lastZoom !== this.object.zoom) {
        this.dispatchEvent(_changeEvent2);
        this._lastPosition.copy(this.object.position);
        this._lastZoom = this.object.zoom;
      }
    } else {
      console.warn("THREE.TrackballControls: Unsupported camera type.");
    }
  }
  reset() {
    this.state = _STATE2.NONE;
    this.keyState = _STATE2.NONE;
    this.target.copy(this._target0);
    this.object.position.copy(this._position0);
    this.object.up.copy(this._up0);
    this.object.zoom = this._zoom0;
    this.object.updateProjectionMatrix();
    this._eye.subVectors(this.object.position, this.target);
    this.object.lookAt(this.target);
    this.dispatchEvent(_changeEvent2);
    this._lastPosition.copy(this.object.position);
    this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    _mouseChange.copy(this._panEnd).sub(this._panStart);
    if (_mouseChange.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;
        const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        _mouseChange.x *= scale_x;
        _mouseChange.y *= scale_y;
      }
      _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
      _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);
      _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));
      this.object.position.add(_pan);
      this.target.add(_pan);
      if (this.staticMoving) {
        this._panStart.copy(this._panEnd);
      } else {
        this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
      }
    }
  }
  _rotateCamera() {
    _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let angle = _moveDirection.length();
    if (angle) {
      this._eye.copy(this.object.position).sub(this.target);
      _eyeDirection.copy(this._eye).normalize();
      _objectUpDirection.copy(this.object.up).normalize();
      _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();
      _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
      _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
      _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));
      _axis.crossVectors(_moveDirection, this._eye).normalize();
      angle *= this.rotateSpeed;
      _quaternion.setFromAxisAngle(_axis, angle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
      this._lastAxis.copy(_axis);
      this._lastAngle = angle;
    } else if (!this.staticMoving && this._lastAngle) {
      this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor);
      this._eye.copy(this.object.position).sub(this.target);
      _quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
    }
    this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let factor;
    if (this.state === _STATE2.TOUCH_ZOOM_PAN) {
      factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
      this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
      if (this.object.isPerspectiveCamera) {
        this._eye.multiplyScalar(factor);
      } else if (this.object.isOrthographicCamera) {
        this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
        if (this._lastZoom !== this.object.zoom) {
          this.object.updateProjectionMatrix();
        }
      } else {
        console.warn("THREE.TrackballControls: Unsupported camera type");
      }
    } else {
      factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
      if (factor !== 1 && factor > 0) {
        if (this.object.isPerspectiveCamera) {
          this._eye.multiplyScalar(factor);
        } else if (this.object.isOrthographicCamera) {
          this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
          if (this._lastZoom !== this.object.zoom) {
            this.object.updateProjectionMatrix();
          }
        } else {
          console.warn("THREE.TrackballControls: Unsupported camera type");
        }
      }
      if (this.staticMoving) {
        this._zoomStart.copy(this._zoomEnd);
      } else {
        this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
      }
    }
  }
  _getMouseOnScreen(pageX, pageY) {
    _v2.set(
      (pageX - this.screen.left) / this.screen.width,
      (pageY - this.screen.top) / this.screen.height
    );
    return _v2;
  }
  _getMouseOnCircle(pageX, pageY) {
    _v2.set(
      (pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width
      // screen.width intentional
    );
    return _v2;
  }
  _addPointer(event) {
    this._pointers.push(event);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i].pointerId == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _trackPointer(event) {
    let position2 = this._pointerPositions[event.pointerId];
    if (position2 === void 0) {
      position2 = new Vector2();
      this._pointerPositions[event.pointerId] = position2;
    }
    position2.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointer.pointerId];
  }
  _checkDistances() {
    if (!this.noZoom || !this.noPan) {
      if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
      if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
    }
  }
};
function onPointerDown2(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove2(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp2(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchEnd(event);
  } else {
    this._onMouseUp();
  }
  this._removePointer(event);
  if (this._pointers.length === 0) {
    this.domElement.releasePointerCapture(event.pointerId);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
  }
}
function onPointerCancel(event) {
  this._removePointer(event);
}
function onKeyUp() {
  if (this.enabled === false) return;
  this.keyState = _STATE2.NONE;
  window.addEventListener("keydown", this._onKeyDown);
}
function onKeyDown2(event) {
  if (this.enabled === false) return;
  window.removeEventListener("keydown", this._onKeyDown);
  if (this.keyState !== _STATE2.NONE) {
    return;
  } else if (event.code === this.keys[_STATE2.ROTATE] && !this.noRotate) {
    this.keyState = _STATE2.ROTATE;
  } else if (event.code === this.keys[_STATE2.ZOOM] && !this.noZoom) {
    this.keyState = _STATE2.ZOOM;
  } else if (event.code === this.keys[_STATE2.PAN] && !this.noPan) {
    this.keyState = _STATE2.PAN;
  }
}
function onMouseDown2(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      this.state = _STATE2.ZOOM;
      break;
    case MOUSE.ROTATE:
      this.state = _STATE2.ROTATE;
      break;
    case MOUSE.PAN:
      this.state = _STATE2.PAN;
      break;
    default:
      this.state = _STATE2.NONE;
  }
  const state2 = this.keyState !== _STATE2.NONE ? this.keyState : this.state;
  if (state2 === _STATE2.ROTATE && !this.noRotate) {
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
    this._movePrev.copy(this._moveCurr);
  } else if (state2 === _STATE2.ZOOM && !this.noZoom) {
    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._zoomEnd.copy(this._zoomStart);
  } else if (state2 === _STATE2.PAN && !this.noPan) {
    this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._panEnd.copy(this._panStart);
  }
  this.dispatchEvent(_startEvent2);
}
function onMouseMove2(event) {
  const state2 = this.keyState !== _STATE2.NONE ? this.keyState : this.state;
  if (state2 === _STATE2.ROTATE && !this.noRotate) {
    this._movePrev.copy(this._moveCurr);
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
  } else if (state2 === _STATE2.ZOOM && !this.noZoom) {
    this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  } else if (state2 === _STATE2.PAN && !this.noPan) {
    this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  }
}
function onMouseUp() {
  this.state = _STATE2.NONE;
  this.dispatchEvent(_endEvent2);
}
function onMouseWheel2(event) {
  if (this.enabled === false) return;
  if (this.noZoom === true) return;
  event.preventDefault();
  switch (event.deltaMode) {
    case 2:
      this._zoomStart.y -= event.deltaY * 0.025;
      break;
    case 1:
      this._zoomStart.y -= event.deltaY * 0.01;
      break;
    default:
      this._zoomStart.y -= event.deltaY * 25e-5;
      break;
  }
  this.dispatchEvent(_startEvent2);
  this.dispatchEvent(_endEvent2);
}
function onContextMenu2(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function onTouchStart2(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this.state = _STATE2.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = _STATE2.TOUCH_ZOOM_PAN;
      const dx = this._pointers[0].pageX - this._pointers[1].pageX;
      const dy = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
      const x = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;
      const y2 = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(x, y2));
      this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(_startEvent2);
}
function onTouchMove2(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr);
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      break;
    default:
      const position2 = this._getSecondPointerPosition(event);
      const dx = event.pageX - position2.x;
      const dy = event.pageY - position2.y;
      this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
      const x = (event.pageX + position2.x) / 2;
      const y2 = (event.pageY + position2.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(x, y2));
      break;
  }
}
function onTouchEnd(event) {
  switch (this._pointers.length) {
    case 0:
      this.state = _STATE2.NONE;
      break;
    case 1:
      this.state = _STATE2.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = _STATE2.TOUCH_ZOOM_PAN;
      for (let i = 0; i < this._pointers.length; i++) {
        if (this._pointers[i].pointerId !== event.pointerId) {
          const position2 = this._pointerPositions[this._pointers[i].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(position2.x, position2.y));
          this._movePrev.copy(this._moveCurr);
          break;
        }
      }
      break;
  }
  this.dispatchEvent(_endEvent2);
}

// node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte
mark_module_start();
Gizmo[FILENAME] = "node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte";
function Gizmo($$anchor, $$props) {
  var _a2;
  check_target(new.target);
  push($$props, true, Gizmo);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  let ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "controls",
      "renderTask",
      "ref",
      "onstart",
      "onchange",
      "onend"
    ],
    "rest"
  );
  const parent = useParent();
  const {
    camera,
    renderer,
    dom,
    autoRenderTask,
    shouldRender,
    size,
    invalidate
  } = useThrelte();
  ref(new Re(camera.current, renderer));
  const viewport = new Vector4();
  const cameraControls = derived(() => $$props.controls ?? $parent());
  useTask(
    ((_a2 = $$props.renderTask) == null ? void 0 : _a2.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      if (shouldRender()) {
        const toneMapping = renderer.toneMapping;
        renderer.getViewport(viewport);
        renderer.toneMapping = NoToneMapping;
        ref().render();
        renderer.setViewport(viewport);
        renderer.toneMapping = toneMapping;
      }
    },
    {
      autoInvalidate: false,
      ...$$props.renderTask ?? { after: autoRenderTask }
    }
  );
  user_pre_effect(() => {
    ref(ref().camera = $camera(), true);
  });
  user_effect(() => {
    if (!get(cameraControls)) return;
    if (get(cameraControls) instanceof OrbitControls || get(cameraControls) instanceof TrackballControls) {
      ref(ref().target = get(cameraControls).target, true);
      const handleChange = () => {
        ref().update(false);
      };
      get(cameraControls).addEventListener("change", handleChange);
      return () => get(cameraControls).removeEventListener("change", handleChange);
    } else {
      const handleUpdate = () => {
        if ("getTarget" in get(cameraControls) && equals(typeof get(cameraControls).getTarget, "function")) {
          get(cameraControls).getTarget(ref().target);
          ref().update();
        }
      };
      const handleChange = () => {
        get(cameraControls).setPosition(...camera.current.position.toArray());
      };
      ref().addEventListener("change", handleChange);
      get(cameraControls).addEventListener("update", handleUpdate);
      return () => {
        ref().removeEventListener("change", handleChange);
        get(cameraControls).removeEventListener("update", handleUpdate);
      };
    }
  });
  user_effect(() => {
    const handleStart = (event) => {
      var _a3;
      get(cameraControls).enabled = false;
      (_a3 = $$props.onstart) == null ? void 0 : _a3.call($$props, event);
    };
    ref().addEventListener("start", handleStart);
    return () => ref().removeEventListener("start", handleStart);
  });
  user_effect(() => {
    const handleChange = (event) => {
      var _a3;
      invalidate();
      (_a3 = $$props.onchange) == null ? void 0 : _a3.call($$props, event);
    };
    ref().addEventListener("change", handleChange);
    return () => ref().removeEventListener("change", handleChange);
  });
  user_effect(() => {
    const handleEnd = (event) => {
      var _a3;
      get(cameraControls).enabled = true;
      (_a3 = $$props.onend) == null ? void 0 : _a3.call($$props, event);
    };
    ref().addEventListener("end", handleEnd);
    return () => ref().removeEventListener("end", handleEnd);
  });
  user_pre_effect(() => {
    if (dom) {
      ref().dispose();
      ref(new Re(camera.current, renderer, {
        container: dom,
        placement: "bottom-left",
        size: 86,
        ...rest
      }));
      invalidate();
    }
  });
  user_effect(() => {
    $size();
    ref().update();
    invalidate();
  });
  user_effect(() => {
    return () => ref().dispose();
  });
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Gizmo = hmr(Gizmo, () => Gizmo[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Gizmo[HMR].source;
    set(Gizmo[HMR].source, module.default[HMR].original);
  });
}
var Gizmo_default = Gizmo;
mark_module_end(Gizmo);

// node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  name: "HorizontalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "h": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  name: "VerticalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "v": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte
mark_module_start();
ContactShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte";
var root_2 = add_locations(template(`<!> <!> <!>`, 1), ContactShadows[FILENAME], []);
function ContactShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ContactShadows);
  let opacity = prop($$props, "opacity", 3, 1), width = prop($$props, "width", 3, 1), height = prop($$props, "height", 3, 1), blur = prop($$props, "blur", 3, 1), far = prop($$props, "far", 3, 10), smooth = prop($$props, "smooth", 3, true), resolution = prop($$props, "resolution", 3, 512), frames = prop($$props, "frames", 3, Infinity), scale = prop($$props, "scale", 3, 10), color2 = prop($$props, "color", 3, "#000000"), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "width",
      "height",
      "blur",
      "far",
      "smooth",
      "resolution",
      "frames",
      "scale",
      "color",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const { scene, renderer } = useThrelte();
  const group = new Group();
  const scaledWidth = derived(() => width() * (Array.isArray(scale()) ? scale()[0] : scale() || 1));
  const scaledHeight = derived(() => height() * (Array.isArray(scale()) ? scale()[1] : scale() || 1));
  const renderTarget = derived(() => {
    const rt3 = new WebGLRenderTarget(resolution(), resolution());
    rt3.texture.generateMipmaps = false;
    rt3.texture.colorSpace = renderer.outputColorSpace;
    return rt3;
  });
  const renderTargetBlur = derived(() => {
    const rt3 = new WebGLRenderTarget(resolution(), resolution());
    rt3.texture.generateMipmaps = false;
    return rt3;
  });
  const planeGeometry = derived(() => new PlaneGeometry(get(scaledWidth), get(scaledHeight)).rotateX(Math.PI / 2));
  const blurPlane = derived(() => new Mesh(get(planeGeometry)));
  const depthMaterial = derived(() => {
    const dm = new MeshDepthMaterial({ depthTest: false, depthWrite: false });
    dm.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        uColor: {
          value: new Color(color2()).convertSRGBToLinear()
        }
      };
      shader.fragmentShader = `uniform vec3 uColor;
${shader.fragmentShader}`;
      shader.fragmentShader = shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );");
      shader.fragmentShader = shader.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    };
    return dm;
  });
  const horizontalBlurMaterial = new ShaderMaterial({ ...HorizontalBlurShader, depthTest: false });
  const verticalBlurMaterial = new ShaderMaterial({ ...VerticalBlurShader, depthTest: false });
  const shadowCamera = derived(() => new OrthographicCamera(-get(scaledWidth) / 2, get(scaledWidth) / 2, get(scaledHeight) / 2, -get(scaledHeight) / 2, 0, far()));
  user_pre_effect(() => get(shadowCamera).updateProjectionMatrix());
  const shadowMaterial = derived(() => new MeshBasicMaterial({
    map: get(renderTarget).texture,
    transparent: true,
    opacity: opacity(),
    depthWrite: depthWrite()
  }));
  const blurShadows = (blur2) => {
    get(blurPlane).visible = true;
    get(blurPlane).material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = get(renderTarget).texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTargetBlur));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = get(renderTargetBlur).texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).visible = false;
  };
  const renderShadows = () => {
    const initialBackground = scene.background;
    scene.background = null;
    const initialOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = get(depthMaterial);
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(scene, get(shadowCamera));
    scene.overrideMaterial = initialOverrideMaterial;
    blurShadows(blur());
    if (smooth()) blurShadows(blur() * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    renderer.setClearAlpha(initialClearAlpha);
  };
  const refresh = () => {
    renderShadows();
  };
  const task = useTask(
    () => {
      renderShadows();
    },
    { autoStart: false }
  );
  let count = 0;
  const countTask = useTask(
    () => {
      renderShadows();
      count += 1;
      if (count >= frames()) countTask.stop();
    },
    { autoStart: false }
  );
  user_pre_effect(() => {
    if (strict_equals(frames(), Number.POSITIVE_INFINITY)) {
      task.start();
    } else if (count < frames()) {
      countTask.start();
    }
  });
  onDestroy(() => {
    get(renderTarget).dispose();
    get(renderTargetBlur).dispose();
    get(planeGeometry).dispose();
    get(depthMaterial).dispose();
    horizontalBlurMaterial.dispose();
    verticalBlurMaterial.dispose();
    get(shadowMaterial).dispose();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(ContactShadows, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        component(node_1, () => T.Group, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            "rotation.x": Math.PI / 2,
            children: wrap_snippet(ContactShadows, ($$anchor4, $$slotProps2) => {
              var fragment_2 = root_2();
              var node_2 = first_child(fragment_2);
              component(node_2, () => T.Mesh, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  "scale.y": -1,
                  "rotation.x": -Math.PI / 2,
                  get material() {
                    return get(shadowMaterial);
                  },
                  get geometry() {
                    return get(planeGeometry);
                  }
                });
              });
              var node_3 = sibling(node_2, 2);
              T(node_3, {
                get is() {
                  return get(shadowCamera);
                },
                manual: true
              });
              var node_4 = sibling(node_3, 2);
              snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group }));
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          });
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get refresh() {
      return refresh;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ContactShadows = hmr(ContactShadows, () => ContactShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContactShadows[HMR].source;
    set(ContactShadows[HMR].source, module.default[HMR].original);
  });
}
var ContactShadows_default = ContactShadows;
mark_module_end(ContactShadows);

// node_modules/three/examples/jsm/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(buffer) {
    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
        case rgbe_write_error:
          throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
        case rgbe_format_error:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
        default:
        case rgbe_memory_error:
          throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
      }
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      }
      if (-1 < i) {
        if (false !== consume) buffer2.pos += len + i + 1;
        return s + chunk.slice(0, i);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let line, match;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line.match(magic_token_re))) {
        rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (false === line) break;
        header.string += line + "\n";
        if ("#" === line.charAt(0)) {
          header.comments += line + "\n";
          continue;
        }
        if (match = line.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
      const scanline_width = w2;
      if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
        (2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128)
      ) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w2 * h2);
      if (!data_rgba.length) {
        rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h2;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun) count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i = 0; i < count; i++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i = 0; i < l; i++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
    let data, type;
    let numElements;
    switch (this.type) {
      case FloatType:
        numElements = image_rgba_data.length / 4;
        const floatArray = new Float32Array(numElements * 4);
        for (let j2 = 0; j2 < numElements; j2++) {
          RGBEByteToRGBFloat(image_rgba_data, j2 * 4, floatArray, j2 * 4);
        }
        data = floatArray;
        type = FloatType;
        break;
      case HalfFloatType:
        numElements = image_rgba_data.length / 4;
        const halfArray = new Uint16Array(numElements * 4);
        for (let j2 = 0; j2 < numElements; j2++) {
          RGBEByteToRGBHalf(image_rgba_data, j2 * 4, halfArray, j2 * 4);
        }
        data = halfArray;
        type = HalfFloatType;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
        break;
    }
    return {
      width: w,
      height: h,
      data,
      header: rgbe_header_info.string,
      gamma: rgbe_header_info.gamma,
      exposure: rgbe_header_info.exposure,
      type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad2, onProgress, onError2) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
        case HalfFloatType:
          texture.colorSpace = LinearSRGBColorSpace;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad2) onLoad2(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError2);
  }
};

// node_modules/three/examples/jsm/loaders/HDRCubeTextureLoader.js
var HDRCubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.hdrLoader = new RGBELoader();
    this.type = HalfFloatType;
  }
  load(urls, onLoad2, onProgress, onError2) {
    const texture = new CubeTexture();
    texture.type = this.type;
    switch (texture.type) {
      case FloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
      case HalfFloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
    }
    const scope = this;
    let loaded = 0;
    function loadHDRData(i, onLoad3, onProgress2, onError3) {
      new FileLoader(scope.manager).setPath(scope.path).setResponseType("arraybuffer").setWithCredentials(scope.withCredentials).load(urls[i], function(buffer) {
        loaded++;
        const texData = scope.hdrLoader.parse(buffer);
        if (!texData) return;
        if (texData.data !== void 0) {
          const dataTexture = new DataTexture(texData.data, texData.width, texData.height);
          dataTexture.type = texture.type;
          dataTexture.colorSpace = texture.colorSpace;
          dataTexture.format = texture.format;
          dataTexture.minFilter = texture.minFilter;
          dataTexture.magFilter = texture.magFilter;
          dataTexture.generateMipmaps = texture.generateMipmaps;
          texture.images[i] = dataTexture;
        }
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad3) onLoad3(texture);
        }
      }, onProgress2, onError3);
    }
    for (let i = 0; i < urls.length; i++) {
      loadHDRData(i, onLoad2, onProgress, onError2);
    }
    return texture;
  }
  setDataType(value) {
    this.type = value;
    this.hdrLoader.setDataType(value);
    return this;
  }
};

// node_modules/@threlte/extras/dist/components/environment/utils/useEnvironment.svelte.js
var useEnvironment = (options) => {
  const { invalidate } = useThrelte();
  observe(() => [options.scene], ([scene]) => {
    const background2 = scene.background;
    const environment2 = scene.environment;
    return () => {
      scene.background = background2;
      scene.environment = environment2;
    };
  });
  let background = state(void 0);
  let environment = state(void 0);
  observe(() => [options.scene], ([scene]) => {
    set(background, proxy(scene.background, null, background));
    set(environment, proxy(scene.environment, null, environment));
  });
  user_effect(() => {
    if (options.isBackground && strict_equals(options.texture, void 0, false)) {
      options.scene.background = options.texture;
      invalidate();
      return () => {
        if (strict_equals(get(background), void 0, false)) {
          options.scene.background = get(background);
          invalidate();
        }
      };
    }
  });
  user_effect(() => {
    if (strict_equals(options.texture, void 0, false)) {
      options.scene.environment = options.texture;
      invalidate();
      return () => {
        if (strict_equals(get(environment), void 0, false)) {
          options.scene.environment = get(environment);
          invalidate();
        }
      };
    }
  });
};

// node_modules/@threlte/extras/dist/components/environment/CubeEnvironment/CubeEnvironment.svelte
mark_module_start();
CubeEnvironment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/CubeEnvironment/CubeEnvironment.svelte";
var loaders = {};
function CubeEnvironment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CubeEnvironment);
  const ctx = useThrelte();
  let isBackground = prop($$props, "isBackground", 3, false), scene = prop($$props, "scene", 19, () => ctx.scene), texture = prop($$props, "texture", 15);
  const cache = useCache();
  const suspend = useSuspense();
  useEnvironment({
    get scene() {
      return scene();
    },
    get isBackground() {
      return isBackground();
    },
    get texture() {
      return texture();
    }
  });
  const first3 = derived(() => {
    var _a2;
    return (_a2 = $$props.urls) == null ? void 0 : _a2[0];
  });
  const firstIsHDR = derived(() => {
    var _a2;
    return ((_a2 = get(first3)) == null ? void 0 : _a2.endsWith("hdr")) ?? false;
  });
  const loader = derived(() => {
    if (strict_equals($$props.urls, void 0)) return;
    if (get(firstIsHDR)) {
      loaders.hdr ?? (loaders.hdr = new HDRCubeTextureLoader());
      return loaders.hdr;
    }
    loaders.tex ?? (loaders.tex = new CubeTextureLoader());
    return loaders.tex;
  });
  user_effect(() => {
    if (strict_equals($$props.urls, void 0, false) && strict_equals(get(loader), void 0, false)) {
      const suspendedTexture = suspend(cache.remember(
        () => {
          return get(loader).loadAsync($$props.urls);
        },
        $$props.urls
      ));
      suspendedTexture.then((t2) => {
        texture(t2);
      });
      return () => {
        suspendedTexture.then((texture2) => {
          texture2.dispose();
        });
      };
    }
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CubeEnvironment = hmr(CubeEnvironment, () => CubeEnvironment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubeEnvironment[HMR].source;
    set(CubeEnvironment[HMR].source, module.default[HMR].original);
  });
}
var CubeEnvironment_default = CubeEnvironment;
mark_module_end(CubeEnvironment);

// node_modules/three/examples/jsm/libs/fflate.module.js
var ch2 = {};
var wk = function(c, id, msg, transfer, cb) {
  var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j2 = b[i]; j2 < b[i + 1]; ++j2) {
      r[j2] = j2 - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le2 = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le2[i] = le2[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v4 = le2[cd[i] - 1]++ << r_1;
        for (var m = v4 | (1 << r_1) - 1; v4 <= m; ++v4) {
          co[rev[v4] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le2[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v4, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v4.length)
    e = v4.length;
  return new u8(v4.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt2) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt2)
    throw e;
  return e;
};
var inflt = function(dat, st2, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st2.i != 2;
  var noSt = st2.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + l);
        buf.set(dat.subarray(s, t2), bt2);
        st2.b = bt2 += l, st2.p = pos = t2 * 8, st2.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n2 = 0;
            if (s == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i++] = c;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt3 = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt3);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt3, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt3 = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt3 += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        if (bt2 < dt3) {
          var shift = dl - dt3, dend = Math.min(dt3, end);
          if (shift + bt2 < 0)
            err(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift + bt2];
        }
        for (; bt2 < end; ++bt2)
          buf[bt2] = buf[bt2 - dt3];
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 != buf.length && noBuf ? slc(buf, 0, bt2) : buf.subarray(0, bt2);
};
var wbits = function(d, p, v4) {
  v4 <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v4;
  d[o + 1] |= v4 >> 8;
};
var wbits16 = function(d, p, v4) {
  v4 <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v4;
  d[o + 1] |= v4 >> 8;
  d[o + 2] |= v4 >> 16;
};
var hTree = function(d, mb) {
  var t2 = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t2.push({ s: i, f: d[i] });
  }
  var s = t2.length;
  var t22 = t2.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v4 = new u8(t2[0].s + 1);
    v4[t2[0].s] = 1;
    return { t: v4, l: 1 };
  }
  t2.sort(function(a, b) {
    return a.f - b.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l = t2[0], r = t2[1], i0 = 0, i1 = 1, i2 = 2;
  t2[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t2[t2[i0].f < t2[i2].f ? i0++ : i2++];
    r = t2[i0 != i1 && t2[i0].f < t2[i2].f ? i0++ : i2++];
    t2[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t22[0].s;
  for (var i = 1; i < s; ++i) {
    if (t22[i].s > maxSym)
      maxSym = t22[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt3 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t22[i].s;
      if (tr[i2_1] > mb) {
        dt3 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt3 >>= lft;
    while (dt3 > 0) {
      var i2_2 = t22[i].s;
      if (tr[i2_2] < mb)
        dt3 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt3; --i) {
      var i2_3 = t22[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt3;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n2, l, d) {
  return n2.s == -1 ? Math.max(ln(n2.l, l, d + 1), ln(n2.r, l, d + 1)) : l[n2.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v4) {
    cl[cli++] = v4;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e2 = hTree(lcfreq, 7), lct = _e2.t, mlcb = _e2.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it3 = 0; it3 < 2; ++it3) {
      var clct = lcts[it3];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st2) {
  var s = st2.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st2.l;
  var pos = (st2.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st2.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st2.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st2.h = head, st2.p = prev, st2.i = i, st2.w = wi;
    }
  } else {
    for (var i = st2.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st2.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t2 = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t2[i] = c;
  }
  return t2;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n2 = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n2 += d[i];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n2, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  if (!st2) {
    st2 = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st2.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt3 = fn();
  var st2 = fn.toString();
  var ks = st2.slice(st2.indexOf("[") + 1, st2.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt3.length; ++i) {
    var v4 = dt3[i], k = ks[i];
    if (typeof v4 == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v4.toString();
      if (v4.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v4.prototype)
            fnStr += ";" + k + ".prototype." + t2 + "=" + v4.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v4;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v4) {
  var tl = [];
  for (var k in v4) {
    if (v4[k].buffer) {
      tl.push((v4[k] = new v4[k].constructor(v4[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init2, id, cb) {
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      fnStr = wcln(fns[i], fnStr, td_1);
    ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id].e);
  return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init2.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o) {
  return o && {
    out: o.size && new u8(o.size),
    dictionary: o.dictionary
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init2, id, flush, ext) {
  var t2;
  var w = wrkr(fns, init2, id, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d, f) {
    if (!strm.ondata)
      err(5);
    if (t2)
      strm.ondata(err(4, 0, 1), null, !!f);
    strm.queuedSize += d.length;
    w.postMessage([d, t2 = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w.postMessage([]);
    };
  }
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v4) {
  for (; v4; ++b)
    d[b] = v4, v4 >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i = 0; i <= fn.length; ++i)
      c[i + 10] = fn.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st2 = 10;
  if (flg & 4)
    st2 += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st2++])
    ;
  return st2 + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename ? o.filename.length + 1 : 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h = adler();
    h.p(o.dictionary);
    wbytes(c, 2, h.d());
  }
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, this.s), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split = this.b.length - this.s.z;
      this.b.set(chunk.subarray(0, split), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk.subarray(split), 32768);
      this.s.z = chunk.length - split + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk, this.s.z);
      this.s.z += chunk.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n2 = new u8(this.p.length + c.length);
      n2.set(this.p), n2.set(c, this.p.length), this.p = n2;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt3 = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt3, bts, this.s.b), this.d);
    this.o = slc(dt3, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    this.l += chunk.length;
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
}();
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
}();
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n2 = new u8(this.p.length + chunk.length);
        n2.set(this.p), n2.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size) {
      _this.queuedSize -= size;
      if (_this.ondrain)
        _this.ondrain(size);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk, final) {
    this.queuedSize += chunk.length;
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var te2 = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (final) {
      if (r.length)
        err(8);
      this.p = null;
    } else
      this.p = r;
    this.ondata(s, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te2)
    return te2.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v4) {
    ar[ai++] = v4;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n2 = new u8(ai + 8 + (l - i << 1));
      n2.set(ar);
      ar = n2;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le2 = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le2 += l + 4;
    }
  }
  return le2;
};
var wzh = function(d, b, f, fn, u2, c, ce2, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce2 != null ? 33639248 : 67324752), b += 4;
  if (ce2 != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u2 && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt3 = new Date(f.mtime == null ? Date.now() : f.mtime), y2 = dt3.getFullYear() - 1980;
  if (y2 < 0 || y2 > 119)
    err(10);
  wbytes(d, b, y2 << 25 | dt3.getMonth() + 1 << 21 | dt3.getDate() << 16 | dt3.getHours() << 11 | dt3.getMinutes() << 5 | dt3.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce2 != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce2), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f = strToU8(file.filename), fl_1 = f.length;
      var com = file.comment, o = com && strToU8(com);
      var u2 = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f, u2, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f,
        u: u2,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt2 = 0, l = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt2, f, f.f, f.u, -f.c - 2, l, f.o);
      bt2 += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt2, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u2 = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u2);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();

// node_modules/three/examples/jsm/loaders/EXRLoader.js
var EXRLoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer) {
    const USHORT_RANGE = 1 << 16;
    const BITMAP_SIZE = USHORT_RANGE >> 3;
    const HUF_ENCBITS = 16;
    const HUF_DECBITS = 14;
    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
    const HUF_DECSIZE = 1 << HUF_DECBITS;
    const HUF_DECMASK = HUF_DECSIZE - 1;
    const NBITS = 16;
    const A_OFFSET = 1 << NBITS - 1;
    const MOD_MASK = (1 << NBITS) - 1;
    const SHORT_ZEROCODE_RUN = 59;
    const LONG_ZEROCODE_RUN = 63;
    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
    const ULONG_SIZE = 8;
    const FLOAT32_SIZE = 4;
    const INT32_SIZE = 4;
    const INT16_SIZE = 2;
    const INT8_SIZE = 1;
    const STATIC_HUFFMAN = 0;
    const DEFLATE = 1;
    const UNKNOWN = 0;
    const LOSSY_DCT = 1;
    const RLE = 2;
    const logBase = Math.pow(2.7182818, 2.2);
    function reverseLutFromBitmap(bitmap, lut) {
      let k = 0;
      for (let i = 0; i < USHORT_RANGE; ++i) {
        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {
          lut[k++] = i;
        }
      }
      const n2 = k - 1;
      while (k < USHORT_RANGE) lut[k++] = 0;
      return n2;
    }
    function hufClearDecTable(hdec) {
      for (let i = 0; i < HUF_DECSIZE; i++) {
        hdec[i] = {};
        hdec[i].len = 0;
        hdec[i].lit = 0;
        hdec[i].p = null;
      }
    }
    const getBitsReturn = { l: 0, c: 0, lc: 0 };
    function getBits(nBits, c, lc2, uInt8Array2, inOffset) {
      while (lc2 < nBits) {
        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
        lc2 += 8;
      }
      lc2 -= nBits;
      getBitsReturn.l = c >> lc2 & (1 << nBits) - 1;
      getBitsReturn.c = c;
      getBitsReturn.lc = lc2;
    }
    const hufTableBuffer = new Array(59);
    function hufCanonicalCodeTable(hcode) {
      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;
      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;
      let c = 0;
      for (let i = 58; i > 0; --i) {
        const nc = c + hufTableBuffer[i] >> 1;
        hufTableBuffer[i] = c;
        c = nc;
      }
      for (let i = 0; i < HUF_ENCSIZE; ++i) {
        const l = hcode[i];
        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
      }
    }
    function hufUnpackEncTable(uInt8Array2, inOffset, ni, im, iM, hcode) {
      const p = inOffset;
      let c = 0;
      let lc2 = 0;
      for (; im <= iM; im++) {
        if (p.value - inOffset.value > ni) return false;
        getBits(6, c, lc2, uInt8Array2, p);
        const l = getBitsReturn.l;
        c = getBitsReturn.c;
        lc2 = getBitsReturn.lc;
        hcode[im] = l;
        if (l == LONG_ZEROCODE_RUN) {
          if (p.value - inOffset.value > ni) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          getBits(8, c, lc2, uInt8Array2, p);
          let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
          c = getBitsReturn.c;
          lc2 = getBitsReturn.lc;
          if (im + zerun > iM + 1) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          while (zerun--) hcode[im++] = 0;
          im--;
        } else if (l >= SHORT_ZEROCODE_RUN) {
          let zerun = l - SHORT_ZEROCODE_RUN + 2;
          if (im + zerun > iM + 1) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          while (zerun--) hcode[im++] = 0;
          im--;
        }
      }
      hufCanonicalCodeTable(hcode);
    }
    function hufLength(code) {
      return code & 63;
    }
    function hufCode(code) {
      return code >> 6;
    }
    function hufBuildDecTable(hcode, im, iM, hdecod) {
      for (; im <= iM; im++) {
        const c = hufCode(hcode[im]);
        const l = hufLength(hcode[im]);
        if (c >> l) {
          throw new Error("Invalid table entry");
        }
        if (l > HUF_DECBITS) {
          const pl = hdecod[c >> l - HUF_DECBITS];
          if (pl.len) {
            throw new Error("Invalid table entry");
          }
          pl.lit++;
          if (pl.p) {
            const p = pl.p;
            pl.p = new Array(pl.lit);
            for (let i = 0; i < pl.lit - 1; ++i) {
              pl.p[i] = p[i];
            }
          } else {
            pl.p = new Array(1);
          }
          pl.p[pl.lit - 1] = im;
        } else if (l) {
          let plOffset = 0;
          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {
            const pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
            if (pl.len || pl.p) {
              throw new Error("Invalid table entry");
            }
            pl.len = l;
            pl.lit = im;
            plOffset++;
          }
        }
      }
      return true;
    }
    const getCharReturn = { c: 0, lc: 0 };
    function getChar(c, lc2, uInt8Array2, inOffset) {
      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
      lc2 += 8;
      getCharReturn.c = c;
      getCharReturn.lc = lc2;
    }
    const getCodeReturn = { c: 0, lc: 0 };
    function getCode(po, rlc, c, lc2, uInt8Array2, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
      if (po == rlc) {
        if (lc2 < 8) {
          getChar(c, lc2, uInt8Array2, inOffset);
          c = getCharReturn.c;
          lc2 = getCharReturn.lc;
        }
        lc2 -= 8;
        let cs = c >> lc2;
        cs = new Uint8Array([cs])[0];
        if (outBufferOffset.value + cs > outBufferEndOffset) {
          return false;
        }
        const s = outBuffer[outBufferOffset.value - 1];
        while (cs-- > 0) {
          outBuffer[outBufferOffset.value++] = s;
        }
      } else if (outBufferOffset.value < outBufferEndOffset) {
        outBuffer[outBufferOffset.value++] = po;
      } else {
        return false;
      }
      getCodeReturn.c = c;
      getCodeReturn.lc = lc2;
    }
    function UInt16(value) {
      return value & 65535;
    }
    function Int16(value) {
      const ref = UInt16(value);
      return ref > 32767 ? ref - 65536 : ref;
    }
    const wdec14Return = { a: 0, b: 0 };
    function wdec14(l, h) {
      const ls = Int16(l);
      const hs = Int16(h);
      const hi = hs;
      const ai = ls + (hi & 1) + (hi >> 1);
      const as = ai;
      const bs = ai - hi;
      wdec14Return.a = as;
      wdec14Return.b = bs;
    }
    function wdec16(l, h) {
      const m = UInt16(l);
      const d = UInt16(h);
      const bb = m - (d >> 1) & MOD_MASK;
      const aa = d + bb - A_OFFSET & MOD_MASK;
      wdec14Return.a = aa;
      wdec14Return.b = bb;
    }
    function wav2Decode(buffer2, j2, nx, ox, ny, oy, mx) {
      const w14 = mx < 1 << 14;
      const n2 = nx > ny ? ny : nx;
      let p = 1;
      let p2;
      let py;
      while (p <= n2) p <<= 1;
      p >>= 1;
      p2 = p;
      p >>= 1;
      while (p >= 1) {
        py = 0;
        const ey = py + oy * (ny - p2);
        const oy1 = oy * p;
        const oy2 = oy * p2;
        const ox1 = ox * p;
        const ox2 = ox * p2;
        let i00, i01, i10, i11;
        for (; py <= ey; py += oy2) {
          let px = py;
          const ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            const p01 = px + ox1;
            const p10 = px + oy1;
            const p11 = p10 + ox1;
            if (w14) {
              wdec14(buffer2[px + j2], buffer2[p10 + j2]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec14(buffer2[p01 + j2], buffer2[p11 + j2]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec14(i00, i01);
              buffer2[px + j2] = wdec14Return.a;
              buffer2[p01 + j2] = wdec14Return.b;
              wdec14(i10, i11);
              buffer2[p10 + j2] = wdec14Return.a;
              buffer2[p11 + j2] = wdec14Return.b;
            } else {
              wdec16(buffer2[px + j2], buffer2[p10 + j2]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec16(buffer2[p01 + j2], buffer2[p11 + j2]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec16(i00, i01);
              buffer2[px + j2] = wdec14Return.a;
              buffer2[p01 + j2] = wdec14Return.b;
              wdec16(i10, i11);
              buffer2[p10 + j2] = wdec14Return.a;
              buffer2[p11 + j2] = wdec14Return.b;
            }
          }
          if (nx & p) {
            const p10 = px + oy1;
            if (w14)
              wdec14(buffer2[px + j2], buffer2[p10 + j2]);
            else
              wdec16(buffer2[px + j2], buffer2[p10 + j2]);
            i00 = wdec14Return.a;
            buffer2[p10 + j2] = wdec14Return.b;
            buffer2[px + j2] = i00;
          }
        }
        if (ny & p) {
          let px = py;
          const ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            const p01 = px + ox1;
            if (w14)
              wdec14(buffer2[px + j2], buffer2[p01 + j2]);
            else
              wdec16(buffer2[px + j2], buffer2[p01 + j2]);
            i00 = wdec14Return.a;
            buffer2[p01 + j2] = wdec14Return.b;
            buffer2[px + j2] = i00;
          }
        }
        p2 = p;
        p >>= 1;
      }
      return py;
    }
    function hufDecode(encodingTable, decodingTable, uInt8Array2, inOffset, ni, rlc, no, outBuffer, outOffset) {
      let c = 0;
      let lc2 = 0;
      const outBufferEndOffset = no;
      const inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
      while (inOffset.value < inOffsetEnd) {
        getChar(c, lc2, uInt8Array2, inOffset);
        c = getCharReturn.c;
        lc2 = getCharReturn.lc;
        while (lc2 >= HUF_DECBITS) {
          const index = c >> lc2 - HUF_DECBITS & HUF_DECMASK;
          const pl = decodingTable[index];
          if (pl.len) {
            lc2 -= pl.len;
            getCode(pl.lit, rlc, c, lc2, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
            c = getCodeReturn.c;
            lc2 = getCodeReturn.lc;
          } else {
            if (!pl.p) {
              throw new Error("hufDecode issues");
            }
            let j2;
            for (j2 = 0; j2 < pl.lit; j2++) {
              const l = hufLength(encodingTable[pl.p[j2]]);
              while (lc2 < l && inOffset.value < inOffsetEnd) {
                getChar(c, lc2, uInt8Array2, inOffset);
                c = getCharReturn.c;
                lc2 = getCharReturn.lc;
              }
              if (lc2 >= l) {
                if (hufCode(encodingTable[pl.p[j2]]) == (c >> lc2 - l & (1 << l) - 1)) {
                  lc2 -= l;
                  getCode(pl.p[j2], rlc, c, lc2, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
                  c = getCodeReturn.c;
                  lc2 = getCodeReturn.lc;
                  break;
                }
              }
            }
            if (j2 == pl.lit) {
              throw new Error("hufDecode issues");
            }
          }
        }
      }
      const i = 8 - ni & 7;
      c >>= i;
      lc2 -= i;
      while (lc2 > 0) {
        const pl = decodingTable[c << HUF_DECBITS - lc2 & HUF_DECMASK];
        if (pl.len) {
          lc2 -= pl.len;
          getCode(pl.lit, rlc, c, lc2, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
          c = getCodeReturn.c;
          lc2 = getCodeReturn.lc;
        } else {
          throw new Error("hufDecode issues");
        }
      }
      return true;
    }
    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
      const outOffset = { value: 0 };
      const initialInOffset = inOffset.value;
      const im = parseUint32(inDataView, inOffset);
      const iM = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      const nBits = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
        throw new Error("Something wrong with HUF_ENCSIZE");
      }
      const freq = new Array(HUF_ENCSIZE);
      const hdec = new Array(HUF_DECSIZE);
      hufClearDecTable(hdec);
      const ni = nCompressed - (inOffset.value - initialInOffset);
      hufUnpackEncTable(uInt8Array2, inOffset, ni, im, iM, freq);
      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
        throw new Error("Something wrong with hufUncompress");
      }
      hufBuildDecTable(freq, im, iM, hdec);
      hufDecode(freq, hdec, uInt8Array2, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
    }
    function applyLut(lut, data, nData) {
      for (let i = 0; i < nData; ++i) {
        data[i] = lut[data[i]];
      }
    }
    function predictor(source) {
      for (let t2 = 1; t2 < source.length; t2++) {
        const d = source[t2 - 1] + source[t2] - 128;
        source[t2] = d;
      }
    }
    function interleaveScalar(source, out) {
      let t1 = 0;
      let t2 = Math.floor((source.length + 1) / 2);
      let s = 0;
      const stop = source.length - 1;
      while (true) {
        if (s > stop) break;
        out[s++] = source[t1++];
        if (s > stop) break;
        out[s++] = source[t2++];
      }
    }
    function decodeRunLength(source) {
      let size = source.byteLength;
      const out = new Array();
      let p = 0;
      const reader = new DataView(source);
      while (size > 0) {
        const l = reader.getInt8(p++);
        if (l < 0) {
          const count = -l;
          size -= count + 1;
          for (let i = 0; i < count; i++) {
            out.push(reader.getUint8(p++));
          }
        } else {
          const count = l;
          size -= 2;
          const value = reader.getUint8(p++);
          for (let i = 0; i < count + 1; i++) {
            out.push(value);
          }
        }
      }
      return out;
    }
    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
      let dataView = new DataView(outBuffer.buffer);
      const width = channelData[cscSet.idx[0]].width;
      const height = channelData[cscSet.idx[0]].height;
      const numComp = 3;
      const numFullBlocksX = Math.floor(width / 8);
      const numBlocksX = Math.ceil(width / 8);
      const numBlocksY = Math.ceil(height / 8);
      const leftoverX = width - (numBlocksX - 1) * 8;
      const leftoverY = height - (numBlocksY - 1) * 8;
      const currAcComp = { value: 0 };
      const currDcComp = new Array(numComp);
      const dctData = new Array(numComp);
      const halfZigBlock = new Array(numComp);
      const rowBlock = new Array(numComp);
      const rowOffsets = new Array(numComp);
      for (let comp = 0; comp < numComp; ++comp) {
        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];
        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;
        dctData[comp] = new Float32Array(64);
        halfZigBlock[comp] = new Uint16Array(64);
        rowBlock[comp] = new Uint16Array(numBlocksX * 64);
      }
      for (let blocky = 0; blocky < numBlocksY; ++blocky) {
        let maxY = 8;
        if (blocky == numBlocksY - 1)
          maxY = leftoverY;
        let maxX = 8;
        for (let blockx = 0; blockx < numBlocksX; ++blockx) {
          if (blockx == numBlocksX - 1)
            maxX = leftoverX;
          for (let comp = 0; comp < numComp; ++comp) {
            halfZigBlock[comp].fill(0);
            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++];
            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]);
            unZigZag(halfZigBlock[comp], dctData[comp]);
            dctInverse(dctData[comp]);
          }
          if (numComp == 3) {
            csc709Inverse(dctData);
          }
          for (let comp = 0; comp < numComp; ++comp) {
            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);
          }
        }
        let offset2 = 0;
        for (let comp = 0; comp < numComp; ++comp) {
          const type = channelData[cscSet.idx[comp]].type;
          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
            offset2 = rowOffsets[comp][y2];
            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {
              const src = blockx * 64 + (y2 & 7) * 8;
              dataView.setUint16(offset2 + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);
              dataView.setUint16(offset2 + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);
              dataView.setUint16(offset2 + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);
              dataView.setUint16(offset2 + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);
              dataView.setUint16(offset2 + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);
              dataView.setUint16(offset2 + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);
              dataView.setUint16(offset2 + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);
              dataView.setUint16(offset2 + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);
              offset2 += 8 * INT16_SIZE * type;
            }
          }
          if (numFullBlocksX != numBlocksX) {
            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
              const offset3 = rowOffsets[comp][y2] + 8 * numFullBlocksX * INT16_SIZE * type;
              const src = numFullBlocksX * 64 + (y2 & 7) * 8;
              for (let x = 0; x < maxX; ++x) {
                dataView.setUint16(offset3 + x * INT16_SIZE * type, rowBlock[comp][src + x], true);
              }
            }
          }
        }
      }
      const halfRow = new Uint16Array(width);
      dataView = new DataView(outBuffer.buffer);
      for (let comp = 0; comp < numComp; ++comp) {
        channelData[cscSet.idx[comp]].decoded = true;
        const type = channelData[cscSet.idx[comp]].type;
        if (channelData[comp].type != 2) continue;
        for (let y2 = 0; y2 < height; ++y2) {
          const offset2 = rowOffsets[comp][y2];
          for (let x = 0; x < width; ++x) {
            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);
          }
          for (let x = 0; x < width; ++x) {
            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);
          }
        }
      }
    }
    function unRleAC(currAcComp, acBuffer, halfZigBlock) {
      let acValue;
      let dctComp = 1;
      while (dctComp < 64) {
        acValue = acBuffer[currAcComp.value];
        if (acValue == 65280) {
          dctComp = 64;
        } else if (acValue >> 8 == 255) {
          dctComp += acValue & 255;
        } else {
          halfZigBlock[dctComp] = acValue;
          dctComp++;
        }
        currAcComp.value++;
      }
    }
    function unZigZag(src, dst) {
      dst[0] = decodeFloat16(src[0]);
      dst[1] = decodeFloat16(src[1]);
      dst[2] = decodeFloat16(src[5]);
      dst[3] = decodeFloat16(src[6]);
      dst[4] = decodeFloat16(src[14]);
      dst[5] = decodeFloat16(src[15]);
      dst[6] = decodeFloat16(src[27]);
      dst[7] = decodeFloat16(src[28]);
      dst[8] = decodeFloat16(src[2]);
      dst[9] = decodeFloat16(src[4]);
      dst[10] = decodeFloat16(src[7]);
      dst[11] = decodeFloat16(src[13]);
      dst[12] = decodeFloat16(src[16]);
      dst[13] = decodeFloat16(src[26]);
      dst[14] = decodeFloat16(src[29]);
      dst[15] = decodeFloat16(src[42]);
      dst[16] = decodeFloat16(src[3]);
      dst[17] = decodeFloat16(src[8]);
      dst[18] = decodeFloat16(src[12]);
      dst[19] = decodeFloat16(src[17]);
      dst[20] = decodeFloat16(src[25]);
      dst[21] = decodeFloat16(src[30]);
      dst[22] = decodeFloat16(src[41]);
      dst[23] = decodeFloat16(src[43]);
      dst[24] = decodeFloat16(src[9]);
      dst[25] = decodeFloat16(src[11]);
      dst[26] = decodeFloat16(src[18]);
      dst[27] = decodeFloat16(src[24]);
      dst[28] = decodeFloat16(src[31]);
      dst[29] = decodeFloat16(src[40]);
      dst[30] = decodeFloat16(src[44]);
      dst[31] = decodeFloat16(src[53]);
      dst[32] = decodeFloat16(src[10]);
      dst[33] = decodeFloat16(src[19]);
      dst[34] = decodeFloat16(src[23]);
      dst[35] = decodeFloat16(src[32]);
      dst[36] = decodeFloat16(src[39]);
      dst[37] = decodeFloat16(src[45]);
      dst[38] = decodeFloat16(src[52]);
      dst[39] = decodeFloat16(src[54]);
      dst[40] = decodeFloat16(src[20]);
      dst[41] = decodeFloat16(src[22]);
      dst[42] = decodeFloat16(src[33]);
      dst[43] = decodeFloat16(src[38]);
      dst[44] = decodeFloat16(src[46]);
      dst[45] = decodeFloat16(src[51]);
      dst[46] = decodeFloat16(src[55]);
      dst[47] = decodeFloat16(src[60]);
      dst[48] = decodeFloat16(src[21]);
      dst[49] = decodeFloat16(src[34]);
      dst[50] = decodeFloat16(src[37]);
      dst[51] = decodeFloat16(src[47]);
      dst[52] = decodeFloat16(src[50]);
      dst[53] = decodeFloat16(src[56]);
      dst[54] = decodeFloat16(src[59]);
      dst[55] = decodeFloat16(src[61]);
      dst[56] = decodeFloat16(src[35]);
      dst[57] = decodeFloat16(src[36]);
      dst[58] = decodeFloat16(src[48]);
      dst[59] = decodeFloat16(src[49]);
      dst[60] = decodeFloat16(src[57]);
      dst[61] = decodeFloat16(src[58]);
      dst[62] = decodeFloat16(src[62]);
      dst[63] = decodeFloat16(src[63]);
    }
    function dctInverse(data) {
      const a = 0.5 * Math.cos(3.14159 / 4);
      const b = 0.5 * Math.cos(3.14159 / 16);
      const c = 0.5 * Math.cos(3.14159 / 8);
      const d = 0.5 * Math.cos(3 * 3.14159 / 16);
      const e = 0.5 * Math.cos(5 * 3.14159 / 16);
      const f = 0.5 * Math.cos(3 * 3.14159 / 8);
      const g4 = 0.5 * Math.cos(7 * 3.14159 / 16);
      const alpha = new Array(4);
      const beta = new Array(4);
      const theta = new Array(4);
      const gamma = new Array(4);
      for (let row = 0; row < 8; ++row) {
        const rowPtr = row * 8;
        alpha[0] = c * data[rowPtr + 2];
        alpha[1] = f * data[rowPtr + 2];
        alpha[2] = c * data[rowPtr + 6];
        alpha[3] = f * data[rowPtr + 6];
        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g4 * data[rowPtr + 7];
        beta[1] = d * data[rowPtr + 1] - g4 * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];
        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g4 * data[rowPtr + 5] + d * data[rowPtr + 7];
        beta[3] = g4 * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];
        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);
        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[rowPtr + 0] = gamma[0] + beta[0];
        data[rowPtr + 1] = gamma[1] + beta[1];
        data[rowPtr + 2] = gamma[2] + beta[2];
        data[rowPtr + 3] = gamma[3] + beta[3];
        data[rowPtr + 4] = gamma[3] - beta[3];
        data[rowPtr + 5] = gamma[2] - beta[2];
        data[rowPtr + 6] = gamma[1] - beta[1];
        data[rowPtr + 7] = gamma[0] - beta[0];
      }
      for (let column = 0; column < 8; ++column) {
        alpha[0] = c * data[16 + column];
        alpha[1] = f * data[16 + column];
        alpha[2] = c * data[48 + column];
        alpha[3] = f * data[48 + column];
        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g4 * data[56 + column];
        beta[1] = d * data[8 + column] - g4 * data[24 + column] - b * data[40 + column] - e * data[56 + column];
        beta[2] = e * data[8 + column] - b * data[24 + column] + g4 * data[40 + column] + d * data[56 + column];
        beta[3] = g4 * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];
        theta[0] = a * (data[column] + data[32 + column]);
        theta[3] = a * (data[column] - data[32 + column]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[0 + column] = gamma[0] + beta[0];
        data[8 + column] = gamma[1] + beta[1];
        data[16 + column] = gamma[2] + beta[2];
        data[24 + column] = gamma[3] + beta[3];
        data[32 + column] = gamma[3] - beta[3];
        data[40 + column] = gamma[2] - beta[2];
        data[48 + column] = gamma[1] - beta[1];
        data[56 + column] = gamma[0] - beta[0];
      }
    }
    function csc709Inverse(data) {
      for (let i = 0; i < 64; ++i) {
        const y2 = data[0][i];
        const cb = data[1][i];
        const cr = data[2][i];
        data[0][i] = y2 + 1.5747 * cr;
        data[1][i] = y2 - 0.1873 * cb - 0.4682 * cr;
        data[2][i] = y2 + 1.8556 * cb;
      }
    }
    function convertToHalf(src, dst, idx) {
      for (let i = 0; i < 64; ++i) {
        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));
      }
    }
    function toLinear(float) {
      if (float <= 1) {
        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);
      } else {
        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);
      }
    }
    function uncompressRAW(info) {
      return new DataView(info.array.buffer, info.offset.value, info.size);
    }
    function uncompressRLE(info) {
      const compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = new Uint8Array(decodeRunLength(compressed));
      const tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressZIP(info) {
      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = unzlibSync(compressed);
      const tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPIZ(info) {
      const inDataView = info.viewer;
      const inOffset = { value: info.offset.value };
      const outBuffer = new Uint16Array(info.columns * info.lines * (info.inputChannels.length * info.type));
      const bitmap = new Uint8Array(BITMAP_SIZE);
      let outBufferEnd = 0;
      const pizChannelData = new Array(info.inputChannels.length);
      for (let i = 0, il = info.inputChannels.length; i < il; i++) {
        pizChannelData[i] = {};
        pizChannelData[i]["start"] = outBufferEnd;
        pizChannelData[i]["end"] = pizChannelData[i]["start"];
        pizChannelData[i]["nx"] = info.columns;
        pizChannelData[i]["ny"] = info.lines;
        pizChannelData[i]["size"] = info.type;
        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
      }
      const minNonZero = parseUint16(inDataView, inOffset);
      const maxNonZero = parseUint16(inDataView, inOffset);
      if (maxNonZero >= BITMAP_SIZE) {
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      }
      if (minNonZero <= maxNonZero) {
        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {
          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
        }
      }
      const lut = new Uint16Array(USHORT_RANGE);
      const maxValue = reverseLutFromBitmap(bitmap, lut);
      const length = parseUint32(inDataView, inOffset);
      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
      for (let i = 0; i < info.inputChannels.length; ++i) {
        const cd = pizChannelData[i];
        for (let j2 = 0; j2 < pizChannelData[i].size; ++j2) {
          wav2Decode(
            outBuffer,
            cd.start + j2,
            cd.nx,
            cd.size,
            cd.ny,
            cd.nx * cd.size,
            maxValue
          );
        }
      }
      applyLut(lut, outBuffer, outBufferEnd);
      let tmpOffset = 0;
      const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
      for (let y2 = 0; y2 < info.lines; y2++) {
        for (let c = 0; c < info.inputChannels.length; c++) {
          const cd = pizChannelData[c];
          const n2 = cd.nx * cd.size;
          const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n2 * INT16_SIZE);
          tmpBuffer.set(cp, tmpOffset);
          tmpOffset += n2 * INT16_SIZE;
          cd.end += n2;
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPXR(info) {
      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = unzlibSync(compressed);
      const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;
      const tmpBuffer = new ArrayBuffer(byteSize);
      const viewer = new DataView(tmpBuffer);
      let tmpBufferEnd = 0;
      let writePtr = 0;
      const ptr = new Array(4);
      for (let y2 = 0; y2 < info.lines; y2++) {
        for (let c = 0; c < info.inputChannels.length; c++) {
          let pixel = 0;
          const type = info.inputChannels[c].pixelType;
          switch (type) {
            case 1:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.columns;
              tmpBufferEnd = ptr[1] + info.columns;
              for (let j2 = 0; j2 < info.columns; ++j2) {
                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                pixel += diff;
                viewer.setUint16(writePtr, pixel, true);
                writePtr += 2;
              }
              break;
            case 2:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.columns;
              ptr[2] = ptr[1] + info.columns;
              tmpBufferEnd = ptr[2] + info.columns;
              for (let j2 = 0; j2 < info.columns; ++j2) {
                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                pixel += diff;
                viewer.setUint32(writePtr, pixel, true);
                writePtr += 4;
              }
              break;
          }
        }
      }
      return viewer;
    }
    function uncompressDWA(info) {
      const inDataView = info.viewer;
      const inOffset = { value: info.offset.value };
      const outBuffer = new Uint8Array(info.columns * info.lines * (info.inputChannels.length * info.type * INT16_SIZE));
      const dwaHeader = {
        version: parseInt64(inDataView, inOffset),
        unknownUncompressedSize: parseInt64(inDataView, inOffset),
        unknownCompressedSize: parseInt64(inDataView, inOffset),
        acCompressedSize: parseInt64(inDataView, inOffset),
        dcCompressedSize: parseInt64(inDataView, inOffset),
        rleCompressedSize: parseInt64(inDataView, inOffset),
        rleUncompressedSize: parseInt64(inDataView, inOffset),
        rleRawSize: parseInt64(inDataView, inOffset),
        totalAcUncompressedCount: parseInt64(inDataView, inOffset),
        totalDcUncompressedCount: parseInt64(inDataView, inOffset),
        acCompression: parseInt64(inDataView, inOffset)
      };
      if (dwaHeader.version < 2)
        throw new Error("EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported");
      const channelRules = new Array();
      let ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
      while (ruleSize > 0) {
        const name = parseNullTerminatedString(inDataView.buffer, inOffset);
        const value = parseUint8(inDataView, inOffset);
        const compression = value >> 2 & 3;
        const csc = (value >> 4) - 1;
        const index = new Int8Array([csc])[0];
        const type = parseUint8(inDataView, inOffset);
        channelRules.push({
          name,
          index,
          type,
          compression
        });
        ruleSize -= name.length + 3;
      }
      const channels = EXRHeader.channels;
      const channelData = new Array(info.inputChannels.length);
      for (let i = 0; i < info.inputChannels.length; ++i) {
        const cd = channelData[i] = {};
        const channel = channels[i];
        cd.name = channel.name;
        cd.compression = UNKNOWN;
        cd.decoded = false;
        cd.type = channel.pixelType;
        cd.pLinear = channel.pLinear;
        cd.width = info.columns;
        cd.height = info.lines;
      }
      const cscSet = {
        idx: new Array(3)
      };
      for (let offset2 = 0; offset2 < info.inputChannels.length; ++offset2) {
        const cd = channelData[offset2];
        for (let i = 0; i < channelRules.length; ++i) {
          const rule = channelRules[i];
          if (cd.name == rule.name) {
            cd.compression = rule.compression;
            if (rule.index >= 0) {
              cscSet.idx[rule.index] = offset2;
            }
            cd.offset = offset2;
          }
        }
      }
      let acBuffer, dcBuffer, rleBuffer;
      if (dwaHeader.acCompressedSize > 0) {
        switch (dwaHeader.acCompression) {
          case STATIC_HUFFMAN:
            acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
            break;
          case DEFLATE:
            const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
            const data = unzlibSync(compressed);
            acBuffer = new Uint16Array(data.buffer);
            inOffset.value += dwaHeader.totalAcUncompressedCount;
            break;
        }
      }
      if (dwaHeader.dcCompressedSize > 0) {
        const zlibInfo = {
          array: info.array,
          offset: inOffset,
          size: dwaHeader.dcCompressedSize
        };
        dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
        inOffset.value += dwaHeader.dcCompressedSize;
      }
      if (dwaHeader.rleRawSize > 0) {
        const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
        const data = unzlibSync(compressed);
        rleBuffer = decodeRunLength(data.buffer);
        inOffset.value += dwaHeader.rleCompressedSize;
      }
      let outBufferEnd = 0;
      const rowOffsets = new Array(channelData.length);
      for (let i = 0; i < rowOffsets.length; ++i) {
        rowOffsets[i] = new Array();
      }
      for (let y2 = 0; y2 < info.lines; ++y2) {
        for (let chan = 0; chan < channelData.length; ++chan) {
          rowOffsets[chan].push(outBufferEnd);
          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
        }
      }
      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
      for (let i = 0; i < channelData.length; ++i) {
        const cd = channelData[i];
        if (cd.decoded) continue;
        switch (cd.compression) {
          case RLE:
            let row = 0;
            let rleOffset = 0;
            for (let y2 = 0; y2 < info.lines; ++y2) {
              let rowOffsetBytes = rowOffsets[i][row];
              for (let x = 0; x < cd.width; ++x) {
                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {
                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                }
                rleOffset++;
              }
              row++;
            }
            break;
          case LOSSY_DCT:
          default:
            throw new Error("EXRLoader.parse: unsupported channel compression");
        }
      }
      return new DataView(outBuffer.buffer);
    }
    function parseNullTerminatedString(buffer2, offset2) {
      const uintBuffer = new Uint8Array(buffer2);
      let endOffset = 0;
      while (uintBuffer[offset2.value + endOffset] != 0) {
        endOffset += 1;
      }
      const stringValue = new TextDecoder().decode(
        uintBuffer.slice(offset2.value, offset2.value + endOffset)
      );
      offset2.value = offset2.value + endOffset + 1;
      return stringValue;
    }
    function parseFixedLengthString(buffer2, offset2, size) {
      const stringValue = new TextDecoder().decode(
        new Uint8Array(buffer2).slice(offset2.value, offset2.value + size)
      );
      offset2.value = offset2.value + size;
      return stringValue;
    }
    function parseRational(dataView, offset2) {
      const x = parseInt32(dataView, offset2);
      const y2 = parseUint32(dataView, offset2);
      return [x, y2];
    }
    function parseTimecode(dataView, offset2) {
      const x = parseUint32(dataView, offset2);
      const y2 = parseUint32(dataView, offset2);
      return [x, y2];
    }
    function parseInt32(dataView, offset2) {
      const Int32 = dataView.getInt32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Int32;
    }
    function parseUint32(dataView, offset2) {
      const Uint32 = dataView.getUint32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Uint32;
    }
    function parseUint8Array(uInt8Array2, offset2) {
      const Uint8 = uInt8Array2[offset2.value];
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    function parseUint8(dataView, offset2) {
      const Uint8 = dataView.getUint8(offset2.value);
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    const parseInt64 = function(dataView, offset2) {
      let int;
      if ("getBigInt64" in DataView.prototype) {
        int = Number(dataView.getBigInt64(offset2.value, true));
      } else {
        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
      }
      offset2.value += ULONG_SIZE;
      return int;
    };
    function parseFloat32(dataView, offset2) {
      const float = dataView.getFloat32(offset2.value, true);
      offset2.value += FLOAT32_SIZE;
      return float;
    }
    function decodeFloat32(dataView, offset2) {
      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));
    }
    function decodeFloat16(binary) {
      const exponent = (binary & 31744) >> 10, fraction = binary & 1023;
      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
    }
    function parseUint16(dataView, offset2) {
      const Uint16 = dataView.getUint16(offset2.value, true);
      offset2.value += INT16_SIZE;
      return Uint16;
    }
    function parseFloat16(buffer2, offset2) {
      return decodeFloat16(parseUint16(buffer2, offset2));
    }
    function parseChlist(dataView, buffer2, offset2, size) {
      const startOffset = offset2.value;
      const channels = [];
      while (offset2.value < startOffset + size - 1) {
        const name = parseNullTerminatedString(buffer2, offset2);
        const pixelType = parseInt32(dataView, offset2);
        const pLinear = parseUint8(dataView, offset2);
        offset2.value += 3;
        const xSampling = parseInt32(dataView, offset2);
        const ySampling = parseInt32(dataView, offset2);
        channels.push({
          name,
          pixelType,
          pLinear,
          xSampling,
          ySampling
        });
      }
      offset2.value += 1;
      return channels;
    }
    function parseChromaticities(dataView, offset2) {
      const redX = parseFloat32(dataView, offset2);
      const redY = parseFloat32(dataView, offset2);
      const greenX = parseFloat32(dataView, offset2);
      const greenY = parseFloat32(dataView, offset2);
      const blueX = parseFloat32(dataView, offset2);
      const blueY = parseFloat32(dataView, offset2);
      const whiteX = parseFloat32(dataView, offset2);
      const whiteY = parseFloat32(dataView, offset2);
      return { redX, redY, greenX, greenY, blueX, blueY, whiteX, whiteY };
    }
    function parseCompression(dataView, offset2) {
      const compressionCodes = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ];
      const compression = parseUint8(dataView, offset2);
      return compressionCodes[compression];
    }
    function parseBox2i(dataView, offset2) {
      const xMin = parseInt32(dataView, offset2);
      const yMin = parseInt32(dataView, offset2);
      const xMax = parseInt32(dataView, offset2);
      const yMax = parseInt32(dataView, offset2);
      return { xMin, yMin, xMax, yMax };
    }
    function parseLineOrder(dataView, offset2) {
      const lineOrders = [
        "INCREASING_Y",
        "DECREASING_Y",
        "RANDOM_Y"
      ];
      const lineOrder = parseUint8(dataView, offset2);
      return lineOrders[lineOrder];
    }
    function parseEnvmap(dataView, offset2) {
      const envmaps = [
        "ENVMAP_LATLONG",
        "ENVMAP_CUBE"
      ];
      const envmap = parseUint8(dataView, offset2);
      return envmaps[envmap];
    }
    function parseTiledesc(dataView, offset2) {
      const levelModes = [
        "ONE_LEVEL",
        "MIPMAP_LEVELS",
        "RIPMAP_LEVELS"
      ];
      const roundingModes = [
        "ROUND_DOWN",
        "ROUND_UP"
      ];
      const xSize = parseUint32(dataView, offset2);
      const ySize = parseUint32(dataView, offset2);
      const modes = parseUint8(dataView, offset2);
      return {
        xSize,
        ySize,
        levelMode: levelModes[modes & 15],
        roundingMode: roundingModes[modes >> 4]
      };
    }
    function parseV2f(dataView, offset2) {
      const x = parseFloat32(dataView, offset2);
      const y2 = parseFloat32(dataView, offset2);
      return [x, y2];
    }
    function parseV3f(dataView, offset2) {
      const x = parseFloat32(dataView, offset2);
      const y2 = parseFloat32(dataView, offset2);
      const z2 = parseFloat32(dataView, offset2);
      return [x, y2, z2];
    }
    function parseValue(dataView, buffer2, offset2, type, size) {
      if (type === "string" || type === "stringvector" || type === "iccProfile") {
        return parseFixedLengthString(buffer2, offset2, size);
      } else if (type === "chlist") {
        return parseChlist(dataView, buffer2, offset2, size);
      } else if (type === "chromaticities") {
        return parseChromaticities(dataView, offset2);
      } else if (type === "compression") {
        return parseCompression(dataView, offset2);
      } else if (type === "box2i") {
        return parseBox2i(dataView, offset2);
      } else if (type === "envmap") {
        return parseEnvmap(dataView, offset2);
      } else if (type === "tiledesc") {
        return parseTiledesc(dataView, offset2);
      } else if (type === "lineOrder") {
        return parseLineOrder(dataView, offset2);
      } else if (type === "float") {
        return parseFloat32(dataView, offset2);
      } else if (type === "v2f") {
        return parseV2f(dataView, offset2);
      } else if (type === "v3f") {
        return parseV3f(dataView, offset2);
      } else if (type === "int") {
        return parseInt32(dataView, offset2);
      } else if (type === "rational") {
        return parseRational(dataView, offset2);
      } else if (type === "timecode") {
        return parseTimecode(dataView, offset2);
      } else if (type === "preview") {
        offset2.value += size;
        return "skipped";
      } else {
        offset2.value += size;
        return void 0;
      }
    }
    function roundLog2(x, mode) {
      const log2 = Math.log2(x);
      return mode == "ROUND_DOWN" ? Math.floor(log2) : Math.ceil(log2);
    }
    function calculateTileLevels(tiledesc, w, h) {
      let num = 0;
      switch (tiledesc.levelMode) {
        case "ONE_LEVEL":
          num = 1;
          break;
        case "MIPMAP_LEVELS":
          num = roundLog2(Math.max(w, h), tiledesc.roundingMode) + 1;
          break;
        case "RIPMAP_LEVELS":
          throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.");
      }
      return num;
    }
    function calculateTiles(count, dataSize, size, roundingMode) {
      const tiles = new Array(count);
      for (let i = 0; i < count; i++) {
        const b = 1 << i;
        let s = dataSize / b | 0;
        if (roundingMode == "ROUND_UP" && s * b < dataSize) s += 1;
        const l = Math.max(s, 1);
        tiles[i] = (l + size - 1) / size | 0;
      }
      return tiles;
    }
    function parseTiles() {
      const EXRDecoder2 = this;
      const offset2 = EXRDecoder2.offset;
      const tmpOffset = { value: 0 };
      for (let tile = 0; tile < EXRDecoder2.tileCount; tile++) {
        const tileX = parseInt32(EXRDecoder2.viewer, offset2);
        const tileY = parseInt32(EXRDecoder2.viewer, offset2);
        offset2.value += 8;
        EXRDecoder2.size = parseUint32(EXRDecoder2.viewer, offset2);
        const startX = tileX * EXRDecoder2.blockWidth;
        const startY = tileY * EXRDecoder2.blockHeight;
        EXRDecoder2.columns = startX + EXRDecoder2.blockWidth > EXRDecoder2.width ? EXRDecoder2.width - startX : EXRDecoder2.blockWidth;
        EXRDecoder2.lines = startY + EXRDecoder2.blockHeight > EXRDecoder2.height ? EXRDecoder2.height - startY : EXRDecoder2.blockHeight;
        const bytesBlockLine = EXRDecoder2.columns * EXRDecoder2.totalBytes;
        const isCompressed = EXRDecoder2.size < EXRDecoder2.lines * bytesBlockLine;
        const viewer = isCompressed ? EXRDecoder2.uncompress(EXRDecoder2) : uncompressRAW(EXRDecoder2);
        offset2.value += EXRDecoder2.size;
        for (let line = 0; line < EXRDecoder2.lines; line++) {
          const lineOffset = line * EXRDecoder2.columns * EXRDecoder2.totalBytes;
          for (let channelID = 0; channelID < EXRDecoder2.inputChannels.length; channelID++) {
            const name = EXRHeader.channels[channelID].name;
            const lOff = EXRDecoder2.channelByteOffsets[name] * EXRDecoder2.columns;
            const cOff = EXRDecoder2.decodeChannels[name];
            if (cOff === void 0) continue;
            tmpOffset.value = lineOffset + lOff;
            const outLineOffset = (EXRDecoder2.height - (1 + startY + line)) * EXRDecoder2.outLineWidth;
            for (let x = 0; x < EXRDecoder2.columns; x++) {
              const outIndex = outLineOffset + (x + startX) * EXRDecoder2.outputChannels + cOff;
              EXRDecoder2.byteArray[outIndex] = EXRDecoder2.getter(viewer, tmpOffset);
            }
          }
        }
      }
    }
    function parseScanline() {
      const EXRDecoder2 = this;
      const offset2 = EXRDecoder2.offset;
      const tmpOffset = { value: 0 };
      for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder2.height / EXRDecoder2.blockHeight; scanlineBlockIdx++) {
        const line = parseInt32(EXRDecoder2.viewer, offset2) - EXRHeader.dataWindow.yMin;
        EXRDecoder2.size = parseUint32(EXRDecoder2.viewer, offset2);
        EXRDecoder2.lines = line + EXRDecoder2.blockHeight > EXRDecoder2.height ? EXRDecoder2.height - line : EXRDecoder2.blockHeight;
        const bytesPerLine = EXRDecoder2.columns * EXRDecoder2.totalBytes;
        const isCompressed = EXRDecoder2.size < EXRDecoder2.lines * bytesPerLine;
        const viewer = isCompressed ? EXRDecoder2.uncompress(EXRDecoder2) : uncompressRAW(EXRDecoder2);
        offset2.value += EXRDecoder2.size;
        for (let line_y = 0; line_y < EXRDecoder2.blockHeight; line_y++) {
          const scan_y = scanlineBlockIdx * EXRDecoder2.blockHeight;
          const true_y = line_y + EXRDecoder2.scanOrder(scan_y);
          if (true_y >= EXRDecoder2.height) continue;
          const lineOffset = line_y * bytesPerLine;
          const outLineOffset = (EXRDecoder2.height - 1 - true_y) * EXRDecoder2.outLineWidth;
          for (let channelID = 0; channelID < EXRDecoder2.inputChannels.length; channelID++) {
            const name = EXRHeader.channels[channelID].name;
            const lOff = EXRDecoder2.channelByteOffsets[name] * EXRDecoder2.columns;
            const cOff = EXRDecoder2.decodeChannels[name];
            if (cOff === void 0) continue;
            tmpOffset.value = lineOffset + lOff;
            for (let x = 0; x < EXRDecoder2.columns; x++) {
              const outIndex = outLineOffset + x * EXRDecoder2.outputChannels + cOff;
              EXRDecoder2.byteArray[outIndex] = EXRDecoder2.getter(viewer, tmpOffset);
            }
          }
        }
      }
    }
    function parseHeader(dataView, buffer2, offset2) {
      const EXRHeader2 = {};
      if (dataView.getUint32(0, true) != 20000630) {
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      }
      EXRHeader2.version = dataView.getUint8(4);
      const spec = dataView.getUint8(5);
      EXRHeader2.spec = {
        singleTile: !!(spec & 2),
        longName: !!(spec & 4),
        deepFormat: !!(spec & 8),
        multiPart: !!(spec & 16)
      };
      offset2.value = 8;
      let keepReading = true;
      while (keepReading) {
        const attributeName = parseNullTerminatedString(buffer2, offset2);
        if (attributeName == 0) {
          keepReading = false;
        } else {
          const attributeType = parseNullTerminatedString(buffer2, offset2);
          const attributeSize = parseUint32(dataView, offset2);
          const attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
          if (attributeValue === void 0) {
            console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${attributeType}'.`);
          } else {
            EXRHeader2[attributeName] = attributeValue;
          }
        }
      }
      if ((spec & ~6) != 0) {
        console.error("THREE.EXRHeader:", EXRHeader2);
        throw new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      }
      return EXRHeader2;
    }
    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
      const EXRDecoder2 = {
        size: 0,
        viewer: dataView,
        array: uInt8Array2,
        offset: offset2,
        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
        inputChannels: EXRHeader2.channels,
        channelByteOffsets: {},
        scanOrder: null,
        totalBytes: null,
        columns: null,
        lines: null,
        type: null,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: LinearSRGBColorSpace
      };
      switch (EXRHeader2.compression) {
        case "NO_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressRAW;
          break;
        case "RLE_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressRLE;
          break;
        case "ZIPS_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "ZIP_COMPRESSION":
          EXRDecoder2.blockHeight = 16;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "PIZ_COMPRESSION":
          EXRDecoder2.blockHeight = 32;
          EXRDecoder2.uncompress = uncompressPIZ;
          break;
        case "PXR24_COMPRESSION":
          EXRDecoder2.blockHeight = 16;
          EXRDecoder2.uncompress = uncompressPXR;
          break;
        case "DWAA_COMPRESSION":
          EXRDecoder2.blockHeight = 32;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        case "DWAB_COMPRESSION":
          EXRDecoder2.blockHeight = 256;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        default:
          throw new Error("EXRLoader.parse: " + EXRHeader2.compression + " is unsupported");
      }
      const channels = {};
      for (const channel of EXRHeader2.channels) {
        switch (channel.name) {
          case "Y":
          case "R":
          case "G":
          case "B":
          case "A":
            channels[channel.name] = true;
            EXRDecoder2.type = channel.pixelType;
        }
      }
      let fillAlpha = false;
      if (channels.R && channels.G && channels.B) {
        fillAlpha = !channels.A;
        EXRDecoder2.outputChannels = 4;
        EXRDecoder2.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
      } else if (channels.Y) {
        EXRDecoder2.outputChannels = 1;
        EXRDecoder2.decodeChannels = { Y: 0 };
      } else {
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
      }
      if (EXRDecoder2.type == 1) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat16;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = parseUint16;
            break;
        }
      } else if (EXRDecoder2.type == 2) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat32;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = decodeFloat32;
        }
      } else {
        throw new Error("EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".");
      }
      EXRDecoder2.columns = EXRDecoder2.width;
      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
      switch (outputType) {
        case FloatType:
          EXRDecoder2.byteArray = new Float32Array(size);
          if (fillAlpha)
            EXRDecoder2.byteArray.fill(1, 0, size);
          break;
        case HalfFloatType:
          EXRDecoder2.byteArray = new Uint16Array(size);
          if (fillAlpha)
            EXRDecoder2.byteArray.fill(15360, 0, size);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", outputType);
          break;
      }
      let byteOffset = 0;
      for (const channel of EXRHeader2.channels) {
        if (EXRDecoder2.decodeChannels[channel.name] !== void 0) {
          EXRDecoder2.channelByteOffsets[channel.name] = byteOffset;
        }
        byteOffset += channel.pixelType * 2;
      }
      EXRDecoder2.totalBytes = byteOffset;
      EXRDecoder2.outLineWidth = EXRDecoder2.width * EXRDecoder2.outputChannels;
      if (EXRHeader2.lineOrder === "INCREASING_Y") {
        EXRDecoder2.scanOrder = (y2) => y2;
      } else {
        EXRDecoder2.scanOrder = (y2) => EXRDecoder2.height - 1 - y2;
      }
      if (EXRDecoder2.outputChannels == 4) {
        EXRDecoder2.format = RGBAFormat;
        EXRDecoder2.colorSpace = LinearSRGBColorSpace;
      } else {
        EXRDecoder2.format = RedFormat;
        EXRDecoder2.colorSpace = NoColorSpace;
      }
      if (EXRHeader2.spec.singleTile) {
        EXRDecoder2.blockHeight = EXRHeader2.tiles.ySize;
        EXRDecoder2.blockWidth = EXRHeader2.tiles.xSize;
        const numXLevels = calculateTileLevels(EXRHeader2.tiles, EXRDecoder2.width, EXRDecoder2.height);
        const numXTiles = calculateTiles(numXLevels, EXRDecoder2.width, EXRHeader2.tiles.xSize, EXRHeader2.tiles.roundingMode);
        const numYTiles = calculateTiles(numXLevels, EXRDecoder2.height, EXRHeader2.tiles.ySize, EXRHeader2.tiles.roundingMode);
        EXRDecoder2.tileCount = numXTiles[0] * numYTiles[0];
        for (let l = 0; l < numXLevels; l++)
          for (let y2 = 0; y2 < numYTiles[l]; y2++)
            for (let x = 0; x < numXTiles[l]; x++)
              parseInt64(dataView, offset2);
        EXRDecoder2.decode = parseTiles.bind(EXRDecoder2);
      } else {
        EXRDecoder2.blockWidth = EXRDecoder2.width;
        const blockCount = Math.ceil(EXRDecoder2.height / EXRDecoder2.blockHeight);
        for (let i = 0; i < blockCount; i++)
          parseInt64(dataView, offset2);
        EXRDecoder2.decode = parseScanline.bind(EXRDecoder2);
      }
      return EXRDecoder2;
    }
    const offset = { value: 0 };
    const bufferDataView = new DataView(buffer);
    const uInt8Array = new Uint8Array(buffer);
    const EXRHeader = parseHeader(bufferDataView, buffer, offset);
    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
    EXRDecoder.decode();
    return {
      header: EXRHeader,
      width: EXRDecoder.width,
      height: EXRDecoder.height,
      data: EXRDecoder.byteArray,
      format: EXRDecoder.format,
      colorSpace: EXRDecoder.colorSpace,
      type: this.type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad2, onProgress, onError2) {
    function onLoadCallback(texture, texData) {
      texture.colorSpace = texData.colorSpace;
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.flipY = false;
      if (onLoad2) onLoad2(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError2);
  }
};

// node_modules/three/examples/jsm/objects/GroundedSkybox.js
var GroundedSkybox = class extends Mesh {
  constructor(map, height, radius, resolution = 128) {
    if (height <= 0 || radius <= 0 || resolution <= 0) {
      throw new Error("GroundedSkybox height, radius, and resolution must be positive.");
    }
    const geometry = new SphereGeometry(radius, 2 * resolution, resolution);
    geometry.scale(1, 1, -1);
    const pos = geometry.getAttribute("position");
    const tmp = new Vector3();
    for (let i = 0; i < pos.count; ++i) {
      tmp.fromBufferAttribute(pos, i);
      if (tmp.y < 0) {
        const y1 = -height * 3 / 2;
        const f = tmp.y < y1 ? -height / tmp.y : 1 - tmp.y * tmp.y / (3 * y1 * y1);
        tmp.multiplyScalar(f);
        tmp.toArray(pos.array, 3 * i);
      }
    }
    pos.needsUpdate = true;
    super(geometry, new MeshBasicMaterial({ map, depthWrite: false }));
  }
};

// node_modules/@threlte/extras/dist/components/environment/Environment/Environment.svelte
mark_module_start();
Environment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/Environment/Environment.svelte";
var loaders2 = {};
function Environment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Environment);
  const ctx = useThrelte();
  let skybox = prop($$props, "skybox", 15), texture = prop($$props, "texture", 15), ground = prop($$props, "ground", 3, false), isBackground = prop($$props, "isBackground", 3, false), scene = prop($$props, "scene", 19, () => ctx.scene);
  const suspend = useSuspense();
  const cache = useCache();
  useEnvironment({
    get scene() {
      return scene();
    },
    get isBackground() {
      return isBackground();
    },
    get texture() {
      return texture();
    }
  });
  const isEXR = derived(() => {
    var _a2;
    return ((_a2 = $$props.url) == null ? void 0 : _a2.endsWith("exr")) ?? false;
  });
  const isHDR = derived(() => {
    var _a2;
    return ((_a2 = $$props.url) == null ? void 0 : _a2.endsWith("hdr")) ?? false;
  });
  const loader = derived(() => {
    if (strict_equals($$props.url, void 0)) return;
    if (get(isEXR)) {
      loaders2.exr ?? (loaders2.exr = new EXRLoader());
      return loaders2.exr;
    } else if (get(isHDR)) {
      loaders2.hdr ?? (loaders2.hdr = new RGBELoader());
      return loaders2.hdr;
    }
    loaders2.tex ?? (loaders2.tex = new TextureLoader());
    return loaders2.tex;
  });
  user_effect(() => {
    if (strict_equals($$props.url, void 0, false) && strict_equals(get(loader), void 0, false)) {
      const suspendedTexture = suspend(cache.remember(
        () => {
          return get(loader).loadAsync($$props.url);
        },
        [$$props.url]
      ));
      suspendedTexture.then((t2) => {
        t2.mapping = EquirectangularReflectionMapping;
        texture(t2);
      });
      return () => {
        suspendedTexture.then((texture2) => {
          texture2.dispose();
        });
      };
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      const options = derived(() => strict_equals(ground(), true) ? {} : ground());
      get(options);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var args = derived(() => [
            texture(),
            get(options).height ?? 1,
            get(options).radius ?? 1,
            get(options).resolution ?? 128
          ]);
          {
            add_owner_effect(skybox, T);
            T(node_2, {
              is: GroundedSkybox,
              oncreate: () => {
                return () => {
                  skybox(void 0);
                };
              },
              get args() {
                return get(args);
              },
              get ref() {
                return skybox();
              },
              set ref($$value) {
                skybox($$value);
              }
            });
          }
          append($$anchor3, fragment_2);
        };
        if_block(node_1, ($$render) => {
          if (texture()) $$render(consequent);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (ground()) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Environment = hmr(Environment, () => Environment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Environment[HMR].source;
    set(Environment[HMR].source, module.default[HMR].original);
  });
}
var Environment_default = Environment;
mark_module_end(Environment);

// node_modules/@threlte/extras/dist/hooks/useCubeCamera.svelte.js
var DEFAULT_NEAR = 1;
var DEFAULT_FAR = 1e3;
var DEFAULT_RESOLUTION = 256;
var useCubeCamera = (near = () => DEFAULT_FAR, far = () => DEFAULT_FAR, resolution = () => DEFAULT_RESOLUTION) => {
  const renderTarget = new WebGLCubeRenderTarget(resolution());
  const camera = new CubeCamera(DEFAULT_NEAR, DEFAULT_FAR, renderTarget);
  user_effect(() => {
    const _resolution = resolution();
    renderTarget.setSize(_resolution, _resolution);
  });
  user_effect(() => {
    const _near = near();
    for (const child2 of camera.children) {
      if (isInstanceOf(child2, "PerspectiveCamera")) {
        child2.near = _near;
        child2.updateProjectionMatrix();
      }
    }
  });
  user_effect(() => {
    const _far = far();
    for (const child2 of camera.children) {
      if (isInstanceOf(child2, "PerspectiveCamera")) {
        child2.far = _far;
        child2.updateProjectionMatrix();
      }
    }
  });
  user_effect(() => {
    return () => {
      renderTarget.dispose();
    };
  });
  return { camera, renderTarget };
};

// node_modules/@threlte/extras/dist/components/environment/VirtualEnvironment/VirtualEnvironment.svelte
mark_module_start();
VirtualEnvironment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/VirtualEnvironment/VirtualEnvironment.svelte";
var root_13 = add_locations(template(`<!> <!>`, 1), VirtualEnvironment[FILENAME], []);
function VirtualEnvironment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, VirtualEnvironment);
  const [$$stores, $$cleanup] = setup_stores();
  const $started = () => (validate_store(started, "started"), store_get(started, "$started", $$stores));
  const ctx = useThrelte();
  let far = prop($$props, "far", 3, 1e3), frames = prop($$props, "frames", 3, Infinity), near = prop($$props, "near", 3, 0.1), resolution = prop($$props, "resolution", 3, 256), parentScene = prop($$props, "scene", 19, () => ctx.scene);
  const { scene } = createSceneContext();
  const { camera, renderTarget } = useCubeCamera(() => near(), () => far(), () => resolution());
  useEnvironment({
    texture: renderTarget.texture,
    get scene() {
      return parentScene();
    },
    get isBackground() {
      return $$props.isBackground;
    }
  });
  const update = () => {
    camera.update(ctx.renderer, scene);
  };
  let count = 0;
  const { start, stop, started } = useTask(
    () => {
      var _a2;
      if (count < frames()) {
        update();
        count += 1;
      } else {
        stop();
        (_a2 = $$props.onupdatestop) == null ? void 0 : _a2.call($$props);
      }
    },
    { autoStart: false }
  );
  const restart = () => {
    var _a2, _b2;
    if ($started()) {
      stop();
      (_a2 = $$props.onupdatestop) == null ? void 0 : _a2.call($$props);
    }
    count = 0;
    start();
    (_b2 = $$props.onupdatestart) == null ? void 0 : _b2.call($$props);
  };
  observe(
    () => [
      far(),
      near(),
      frames(),
      resolution()
    ],
    restart
  );
  var fragment = comment();
  var node = first_child(fragment);
  var attach = derived(() => $$props.visible ? void 0 : false);
  T(node, {
    is: scene,
    get attach() {
      return get(attach);
    },
    children: wrap_snippet(VirtualEnvironment, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_13();
      var node_1 = first_child(fragment_1);
      T(node_1, { is: camera });
      var node_2 = sibling(node_1, 2);
      snippet(node_2, () => $$props.children ?? noop, () => ({ camera, renderTarget, restart, update }));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  var $$pop = pop({
    get camera() {
      return camera;
    },
    get renderTarget() {
      return renderTarget;
    },
    get update() {
      return update;
    },
    get restart() {
      return restart;
    },
    ...legacy_api()
  });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  VirtualEnvironment = hmr(VirtualEnvironment, () => VirtualEnvironment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VirtualEnvironment[HMR].source;
    set(VirtualEnvironment[HMR].source, module.default[HMR].original);
  });
}
var VirtualEnvironment_default = VirtualEnvironment;
mark_module_end(VirtualEnvironment);

// node_modules/@threlte/extras/dist/lib/revision.js
var revision2 = Number.parseInt(REVISION.replace("dev", ""));

// node_modules/@threlte/extras/dist/components/ImageMaterial/shaders.js
var vertexShader = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
);
var fragmentShader = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
);

// node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte
mark_module_start();
ImageMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte";
function ImageMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ImageMaterial);
  const [$$stores, $$cleanup] = setup_stores();
  const $textureStore = () => (validate_store(textureStore, "textureStore"), store_get(textureStore, "$textureStore", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  let color2 = prop($$props, "color", 3, "white"), zoom = prop($$props, "zoom", 3, 1), radius = prop($$props, "radius", 3, 0), alphaThreshold = prop($$props, "alphaThreshold", 3, 0), alphaSmoothing = prop($$props, "alphaSmoothing", 3, 0.1), brightness = prop($$props, "brightness", 3, 0), contrast = prop($$props, "contrast", 3, 0), hue = prop($$props, "hue", 3, 0), saturation = prop($$props, "saturation", 3, 0), lightness = prop($$props, "lightness", 3, 0), negative = prop($$props, "negative", 3, false), opacity = prop($$props, "opacity", 3, 1), toneMapped = prop($$props, "toneMapped", 3, true), transparent = prop($$props, "transparent", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "zoom",
      "radius",
      "alphaThreshold",
      "alphaSmoothing",
      "brightness",
      "contrast",
      "hue",
      "saturation",
      "lightness",
      "negative",
      "opacity",
      "toneMapped",
      "transparent",
      "texture",
      "monochromeColor",
      "monochromeStrength",
      "colorProcessingTexture",
      "side",
      "url",
      "ref",
      "children"
    ],
    "props"
  );
  const material = new ShaderMaterial();
  const suspend = useSuspense();
  let textureStore = asyncWritable(Promise.resolve(void 0));
  user_pre_effect(() => {
    textureStore = suspend($$props.url ? useTexture($$props.url) : asyncWritable(Promise.resolve($$props.texture)));
  });
  let { size } = useThrelte();
  const parent = useParent();
  const uniforms = {
    color: { value: new Color(color2()) },
    scale: { value: new Vector2() },
    imageBounds: { value: new Vector2(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: zoom() },
    radius: { value: radius() },
    alphaThreshold: { value: alphaThreshold() },
    alphaSmoothing: { value: alphaSmoothing() },
    brightness: { value: brightness() },
    contrast: { value: contrast() },
    monochromeColor: { value: new Color($$props.monochromeColor) },
    monochromeStrength: { value: $$props.monochromeStrength ?? 0 },
    negative: { value: negative() ? 1 : 0 },
    opacity: { value: opacity() },
    hsl: { value: new Vector3(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  user_pre_effect(() => {
    uniforms.color.value.set(color2());
  });
  user_pre_effect(() => {
    var _a2, _b2;
    uniforms.imageBounds.value.set(((_a2 = $textureStore()) == null ? void 0 : _a2.image.width) ?? 0, ((_b2 = $textureStore()) == null ? void 0 : _b2.image.height) ?? 0);
  });
  user_pre_effect(() => {
    uniforms.resolution.value = Math.max($size().width, $size().height);
  });
  user_pre_effect(() => {
    uniforms.zoom.value = zoom();
  });
  user_pre_effect(() => {
    uniforms.radius.value = radius();
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    uniforms.alphaThreshold.value = alphaThreshold();
  });
  user_pre_effect(() => {
    uniforms.alphaSmoothing.value = alphaSmoothing();
  });
  user_pre_effect(() => {
    uniforms.brightness.value = brightness();
  });
  user_pre_effect(() => {
    uniforms.contrast.value = contrast();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.x = hue();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.z = lightness();
  });
  user_pre_effect(() => {
    uniforms.negative.value = negative() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.map.value = $textureStore() ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProccessingTexture.value = $$props.colorProcessingTexture ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProcessingTextureOverride.value = $$props.colorProcessingTexture ? 1 : 0;
  });
  user_pre_effect(() => {
    if (strict_equals($$props.monochromeColor, void 0, false)) {
      uniforms.monochromeColor.value.set($$props.monochromeColor);
      uniforms.monochromeStrength.value = $$props.monochromeStrength ?? 1;
    } else {
      uniforms.monochromeStrength.value = 0;
    }
  });
  user_pre_effect(() => {
    let colorProcessingEnabled = 0;
    const monochromeCheck = ($$props.monochromeColor ? 1 : 0) * (strict_equals($$props.monochromeStrength, void 0) ? 1 : $$props.monochromeStrength);
    for (const value of [
      brightness(),
      contrast(),
      hue(),
      saturation(),
      lightness(),
      monochromeCheck,
      $$props.colorProcessingTexture ? 1 : 0
    ]) {
      if (strict_equals(value, 0, false)) {
        colorProcessingEnabled = 1;
        break;
      }
    }
    uniforms.colorProcessingEnabled.value = colorProcessingEnabled;
  });
  useTask(() => {
    const mesh = $parent();
    if (!isInstanceOf(mesh, "Mesh")) return;
    uniforms.scale.value.set(mesh.scale.x, mesh.scale.y);
    const geometry = mesh.geometry;
    if (strict_equals(geometry, void 0, false) && "parameters" in geometry) {
      const { width, height } = geometry.parameters;
      uniforms.scale.value.set(uniforms.scale.value.x * width, uniforms.scale.value.y * height);
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: material,
        uniforms,
        get toneMapped() {
          return toneMapped();
        },
        get transparent() {
          return transparent();
        },
        get side() {
          return $$props.side;
        },
        vertexShader,
        fragmentShader
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(ImageMaterial, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ImageMaterial = hmr(ImageMaterial, () => ImageMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageMaterial[HMR].source;
    set(ImageMaterial[HMR].source, module.default[HMR].original);
  });
}
var ImageMaterial_default = ImageMaterial;
mark_module_end(ImageMaterial);

// node_modules/@threlte/extras/dist/components/Grid/gridShaders.js
var vertexShader2 = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
);
var fragmentShader2 = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>
	}
`
);

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
mark_module_start();
Grid[FILENAME] = "node_modules/@threlte/extras/dist/components/Grid/Grid.svelte";
var root_14 = add_locations(template(`<!> <!>`, 1), Grid[FILENAME], []);
function Grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Grid);
  let cellColor = prop($$props, "cellColor", 3, "#000000"), sectionColor = prop($$props, "sectionColor", 3, "#0000ee"), cellSize = prop($$props, "cellSize", 3, 1), backgroundColor = prop($$props, "backgroundColor", 3, "#dadada"), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0), sectionSize = prop($$props, "sectionSize", 3, 10), plane = prop($$props, "plane", 3, "xz"), gridSize = prop($$props, "gridSize", 19, () => [20, 20]), followCamera = prop($$props, "followCamera", 3, false), infiniteGrid = prop($$props, "infiniteGrid", 3, false), fadeDistance = prop($$props, "fadeDistance", 3, 100), fadeStrength = prop($$props, "fadeStrength", 3, 1), cellThickness = prop($$props, "cellThickness", 3, 1), sectionThickness = prop($$props, "sectionThickness", 3, 2), side = prop($$props, "side", 3, DoubleSide), type = prop($$props, "type", 3, "grid"), axis = prop($$props, "axis", 3, "x"), maxRadius = prop($$props, "maxRadius", 3, 0), cellDividers = prop($$props, "cellDividers", 3, 6), sectionDividers = prop($$props, "sectionDividers", 3, 2), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cellColor",
      "sectionColor",
      "cellSize",
      "backgroundColor",
      "backgroundOpacity",
      "sectionSize",
      "plane",
      "gridSize",
      "followCamera",
      "infiniteGrid",
      "fadeDistance",
      "fadeStrength",
      "cellThickness",
      "sectionThickness",
      "side",
      "type",
      "axis",
      "maxRadius",
      "cellDividers",
      "sectionDividers",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh();
  const { invalidate, camera } = useThrelte();
  const gridPlane = new Plane();
  const upVector = new Vector3(0, 1, 0);
  const zeroVector = new Vector3(0, 0, 0);
  const axisToInt = { x: 0, y: 1, z: 2 };
  const planeToAxes = { xz: "xzy", xy: "xyz", zy: "zyx" };
  const gridType = { grid: 0, lines: 1, circular: 2, polar: 3 };
  const uniforms = {
    cellSize: { value: cellSize() },
    sectionSize: { value: sectionSize() },
    cellColor: { value: new Color(cellColor()) },
    sectionColor: { value: new Color(sectionColor()) },
    backgroundColor: { value: new Color(backgroundColor()) },
    backgroundOpacity: { value: backgroundOpacity() },
    fadeDistance: { value: fadeDistance() },
    fadeStrength: { value: fadeStrength() },
    cellThickness: { value: cellThickness() },
    sectionThickness: { value: sectionThickness() },
    infiniteGrid: { value: infiniteGrid() },
    followCamera: { value: followCamera() },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: gridType.grid },
    lineGridCoord: { value: axisToInt[axis()] },
    circleGridMaxRadius: { value: maxRadius() },
    polarCellDividers: { value: cellDividers() },
    polarSectionDividers: { value: sectionDividers() },
    worldCamProjPosition: { value: new Vector3() },
    worldPlanePosition: { value: new Vector3() }
  };
  user_pre_effect(() => {
    const axes = planeToAxes[plane()];
    const c0 = axes.charAt(0);
    const c1 = axes.charAt(1);
    const c2 = axes.charAt(2);
    uniforms.coord0.value = axisToInt[c0];
    uniforms.coord1.value = axisToInt[c1];
    uniforms.coord2.value = axisToInt[c2];
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellSize.value = cellSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionSize.value = sectionSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellColor.value.set(cellColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionColor.value.set(sectionColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundColor.value.set(backgroundColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundOpacity.value = backgroundOpacity();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeDistance.value = fadeDistance();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeStrength.value = fadeStrength();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellThickness.value = cellThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionThickness.value = sectionThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.followCamera.value = followCamera();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.infiniteGrid.value = infiniteGrid();
    invalidate();
  });
  user_pre_effect(() => {
    switch (type()) {
      case "grid": {
        uniforms.gridType.value = gridType.grid;
        break;
      }
      case "lines": {
        uniforms.gridType.value = gridType.lines;
        uniforms.lineGridCoord.value = axisToInt[axis()];
        break;
      }
      case "circular": {
        uniforms.gridType.value = gridType.circular;
        uniforms.circleGridMaxRadius.value = maxRadius();
        break;
      }
      case "polar": {
        uniforms.gridType.value = gridType.polar;
        uniforms.circleGridMaxRadius.value = maxRadius();
        uniforms.polarCellDividers.value = cellDividers();
        uniforms.polarSectionDividers.value = sectionDividers();
        break;
      }
    }
    invalidate();
  });
  useTask(
    () => {
      gridPlane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(mesh.matrixWorld);
      const material = mesh.material;
      const worldCamProjPosition = material.uniforms.worldCamProjPosition;
      const worldPlanePosition = material.uniforms.worldPlanePosition;
      gridPlane.projectPoint(camera.current.position, worldCamProjPosition.value);
      worldPlanePosition.value.set(0, 0, 0).applyMatrix4(mesh.matrixWorld);
    },
    { autoInvalidate: false }
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: mesh, frustumCulled: false }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Grid, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_14();
        var node_1 = first_child(fragment_1);
        component(node_1, () => T.ShaderMaterial, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            fragmentShader: fragmentShader2,
            vertexShader: vertexShader2,
            uniforms,
            transparent: true,
            get side() {
              return side();
            }
          });
        });
        var node_2 = sibling(node_1, 2);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children, () => ({ ref: mesh }));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var fragment_3 = comment();
            var node_4 = first_child(fragment_3);
            var args = derived(() => equals(typeof gridSize(), "number") ? [gridSize(), gridSize()] : gridSize());
            component(node_4, () => T.PlaneGeometry, ($$anchor4, $$component) => {
              $$component($$anchor4, {
                get args() {
                  return get(args);
                }
              });
            });
            append($$anchor3, fragment_3);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Grid = hmr(Grid, () => Grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Grid[HMR].source;
    set(Grid[HMR].source, module.default[HMR].original);
  });
}
var Grid_default = Grid;
mark_module_end(Grid);

// node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte
mark_module_start();
RoundedBoxGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte";
function RoundedBoxGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RoundedBoxGeometry);
  let args = prop($$props, "args", 19, () => []), radius = prop($$props, "radius", 3, 0.05), smoothness = prop($$props, "smoothness", 3, 4), creaseAngle = prop($$props, "creaseAngle", 3, 0.4), steps = prop($$props, "steps", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "args",
      "radius",
      "smoothness",
      "creaseAngle",
      "steps",
      "ref",
      "children"
    ],
    "props"
  );
  const eps = 1e-5;
  const createShape = (width2, height2, radius0) => {
    const shape2 = new Shape();
    const radius2 = radius0 - eps;
    shape2.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
    shape2.absarc(eps, height2 - radius2 * 2, eps, Math.PI, Math.PI / 2, true);
    shape2.absarc(width2 - radius2 * 2, height2 - radius2 * 2, eps, Math.PI / 2, 0, true);
    shape2.absarc(width2 - radius2 * 2, eps, eps, 0, -Math.PI / 2, true);
    return shape2;
  };
  let width = derived(() => args()[0] ?? 1);
  let height = derived(() => args()[1] ?? 1);
  let depth = derived(() => args()[2] ?? 1);
  let shape = derived(() => createShape(get(width), get(height), radius()));
  let params = derived(() => ({
    depth: get(depth) - radius() * 2,
    bevelEnabled: true,
    bevelSegments: smoothness() * 2,
    steps: steps(),
    bevelSize: radius() - eps,
    bevelThickness: radius(),
    curveSegments: smoothness()
  }));
  let geometry = derived(() => new ExtrudeGeometry(get(shape), get(params)));
  user_pre_effect(() => {
    get(geometry).center();
    toCreasedNormals(get(geometry), creaseAngle());
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        get is() {
          return get(geometry);
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(RoundedBoxGeometry, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: get(geometry) }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RoundedBoxGeometry = hmr(RoundedBoxGeometry, () => RoundedBoxGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RoundedBoxGeometry[HMR].source;
    set(RoundedBoxGeometry[HMR].source, module.default[HMR].original);
  });
}
var RoundedBoxGeometry_default = RoundedBoxGeometry;
mark_module_end(RoundedBoxGeometry);

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent3 = { type: "change" };
var _mouseDownEvent = { type: "mouseDown", mode: null };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Controls {
  constructor(camera, domElement = null) {
    super(void 0, domElement);
    const root6 = new TransformControlsRoot(this);
    this._root = root6;
    const gizmo = new TransformControlsGizmo();
    this._gizmo = gizmo;
    root6.add(gizmo);
    const plane = new TransformControlsPlane();
    this._plane = plane;
    root6.add(plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            plane[propName] = value;
            gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent3);
          }
        }
      });
      scope[propName] = defaultValue;
      plane[propName] = defaultValue;
      gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    defineProperty("minX", -Infinity);
    defineProperty("maxX", Infinity);
    defineProperty("minY", -Infinity);
    defineProperty("maxY", Infinity);
    defineProperty("minZ", -Infinity);
    defineProperty("maxZ", Infinity);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown3.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove3.bind(this);
    this._onPointerUp = onPointerUp3.bind(this);
    if (domElement !== null) {
      this.connect();
    }
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true) return;
    if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0) return;
    if (this.axis !== null) {
      if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1) return;
    if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect) return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1) this._offset.x = 0;
      if (axis.indexOf("Y") === -1) this._offset.y = 0;
      if (axis.indexOf("Z") === -1) this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
      object.position.x = Math.max(this.minX, Math.min(this.maxX, object.position.x));
      object.position.y = Math.max(this.minY, Math.min(this.maxY, object.position.y));
      object.position.z = Math.max(this.minZ, Math.min(this.maxZ, object.position.z));
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0) d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap) this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent3);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer !== null && pointer.button !== 0) return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.disconnect();
    this._root.dispose();
  }
  // Set current object
  attach(object) {
    this.object = object;
    this._root.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.axis = null;
    this._root.visible = false;
    return this;
  }
  reset() {
    if (!this.enabled) return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent3);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space) {
    this.space = space;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled) return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown3(event) {
  if (!this.enabled) return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove3(event) {
  if (!this.enabled) return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp3(event) {
  if (!this.enabled) return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v22 = new Vector3();
var _v3 = new Vector3();
var TransformControlsRoot = class extends Object3D {
  constructor(controls) {
    super();
    this.isTransformControlsRoot = true;
    this.controls = controls;
    this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(force) {
    const controls = this.controls;
    if (controls.object !== void 0) {
      controls.object.updateMatrixWorld();
      if (controls.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        controls.object.parent.matrixWorld.decompose(controls._parentPosition, controls._parentQuaternion, controls._parentScale);
      }
      controls.object.matrixWorld.decompose(controls.worldPosition, controls.worldQuaternion, controls._worldScale);
      controls._parentQuaternionInv.copy(controls._parentQuaternion).invert();
      controls._worldQuaternionInv.copy(controls.worldQuaternion).invert();
    }
    controls.camera.updateMatrixWorld();
    controls.camera.matrixWorld.decompose(controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale);
    if (controls.camera.isOrthographicCamera) {
      controls.camera.getWorldDirection(controls.eye).negate();
    } else {
      controls.eye.copy(controls.cameraPosition).sub(controls.worldPosition).normalize();
    }
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.traverse(function(child2) {
      if (child2.geometry) child2.geometry.dispose();
      if (child2.material) child2.material.dispose();
    });
  }
};
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position2 = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position2) {
            object.position.set(position2[0], position2[1], position2[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale") space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v22.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v22);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v22);
            _dirVector.copy(_v22).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v22);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@threlte/extras/dist/components/controls/useControlsContext.js
var useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0),
    trackballControls: writable(void 0)
  });
};

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
mark_module_start();
TransformControls_1[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte";
var root2 = add_locations(template(`<!> <!>`, 1), TransformControls_1[FILENAME], []);
function TransformControls_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TransformControls_1);
  const [$$stores, $$cleanup] = setup_stores();
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  let autoPauseOrbitControls = prop($$props, "autoPauseOrbitControls", 3, true), autoPauseTrackballControls = prop($$props, "autoPauseTrackballControls", 3, true), controls = prop($$props, "controls", 15), group = prop($$props, "group", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoPauseOrbitControls",
      "autoPauseTrackballControls",
      "object",
      "controls",
      "group",
      "children"
    ],
    "props"
  );
  const { camera, dom, invalidate, scene } = useThrelte();
  const { orbitControls, trackballControls } = useControlsContext();
  const isDragging = currentWritable(false);
  const useAutoPauseOrbitControls = writable(autoPauseOrbitControls() ?? true);
  user_pre_effect(() => useAutoPauseOrbitControls.set(autoPauseOrbitControls() ?? true));
  const useAutoPauseTrackballControls = writable(autoPauseTrackballControls() ?? true);
  user_pre_effect(() => useAutoPauseTrackballControls.set(autoPauseTrackballControls() ?? true));
  watch(
    [
      orbitControls,
      isDragging,
      useAutoPauseOrbitControls
    ],
    ([
      orbitControls2,
      isDragging2,
      useAutoPauseOrbitControls2
    ]) => {
      if (!orbitControls2 || !orbitControls2.enabled && isDragging2) return;
      orbitControls2.enabled = !(isDragging2 && useAutoPauseOrbitControls2);
      return () => {
        orbitControls2.enabled = true;
      };
    }
  );
  watch(
    [
      trackballControls,
      isDragging,
      useAutoPauseTrackballControls
    ],
    ([
      trackballControls2,
      isDragging2,
      useAutoPausetrackballControls
    ]) => {
      if (!trackballControls2 || !trackballControls2.enabled && isDragging2) return;
      trackballControls2.enabled = !(isDragging2 && useAutoPausetrackballControls);
      return () => {
        trackballControls2.enabled = true;
      };
    }
  );
  const attachGroup = new Group();
  let transformControls = derived(() => new TransformControls($camera(), dom));
  user_pre_effect(() => {
    var _a2;
    (_a2 = get(transformControls)) == null ? void 0 : _a2.attach($$props.object ?? attachGroup);
    return () => {
      var _a3;
      return (_a3 = get(transformControls)) == null ? void 0 : _a3.detach();
    };
  });
  const transformOnlyPropNames = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible",
    "onmouseDown",
    "onmouseUp",
    "onobjectChange"
  ];
  let transformProps = state(proxy({}));
  let objectProps = state(proxy({}));
  user_pre_effect(() => {
    set(transformProps, proxy({}, null, transformProps));
    set(objectProps, proxy({}, null, objectProps));
    Object.keys(props).forEach((key2) => {
      user_pre_effect(() => {
        if (transformOnlyPropNames.includes(key2)) {
          get(transformProps)[key2] = props[key2];
        } else {
          get(objectProps)[key2] = props[key2];
        }
      });
    });
  });
  const onchange = (event) => {
    var _a2;
    invalidate();
    if (get(transformControls).dragging && !isDragging.current) {
      isDragging.set(true);
    } else if (!get(transformControls).dragging && isDragging.current) {
      isDragging.set(false);
    }
    (_a2 = $$props.onchange) == null ? void 0 : _a2.call($$props, event);
  };
  var fragment = root2();
  var node = first_child(fragment);
  {
    add_owner_effect(controls, T);
    T(node, spread_props(
      {
        get is() {
          return get(transformControls);
        },
        onchange
      },
      () => get(transformProps),
      {
        attach: ({ ref }) => {
          const helper = ref.getHelper();
          scene.add(helper);
          return () => {
            scene.remove(helper);
          };
        },
        dispose: false,
        oncreate: (ref) => {
          return () => ref.dispose();
        },
        get ref() {
          return controls();
        },
        set ref($$value) {
          controls($$value);
        }
      }
    ));
  }
  var node_1 = sibling(node, 2);
  {
    add_owner_effect(group, T);
    T(node_1, spread_props({ is: attachGroup }, () => get(objectProps), {
      get ref() {
        return group();
      },
      set ref($$value) {
        group($$value);
      },
      children: wrap_snippet(TransformControls_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children, () => ({ ref: attachGroup }));
            append($$anchor3, fragment_2);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TransformControls_1 = hmr(TransformControls_1, () => TransformControls_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TransformControls_1[HMR].source;
    set(TransformControls_1[HMR].source, module.default[HMR].original);
  });
}
var TransformControls_default = TransformControls_1;
mark_module_end(TransformControls_1);

// node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte
mark_module_start();
OrbitControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte";
function OrbitControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, OrbitControls2);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = useParent();
  const { dom, invalidate } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const controls = new OrbitControls($parent(), dom);
  const { orbitControls } = useControlsContext();
  const { start, stop } = useTask(
    () => {
      controls.update();
    },
    { autoStart: false, autoInvalidate: false }
  );
  user_pre_effect(() => {
    if ($$props.autoRotate || $$props.enableDamping) {
      start();
    } else {
      stop();
    }
  });
  user_pre_effect(() => {
    const handleChange = (event) => {
      var _a2;
      invalidate();
      (_a2 = $$props.onchange) == null ? void 0 : _a2.call($$props, event);
    };
    orbitControls.set(controls);
    controls.addEventListener("change", handleChange);
    return () => {
      orbitControls.set(void 0);
      controls.removeEventListener("change", handleChange);
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: controls }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(OrbitControls2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  OrbitControls2 = hmr(OrbitControls2, () => OrbitControls2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OrbitControls2[HMR].source;
    set(OrbitControls2[HMR].source, module.default[HMR].original);
  });
}
var OrbitControls_default = OrbitControls2;
mark_module_end(OrbitControls2);

// node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte
mark_module_start();
TrackballControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte";
function TrackballControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TrackballControls2);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = useParent();
  const { dom, invalidate } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  }
  const controls = new TrackballControls($parent(), dom);
  const { trackballControls } = useControlsContext();
  useTask(
    () => {
      controls.update();
    },
    { autoInvalidate: false }
  );
  user_effect(() => {
    const handleChange = (event) => {
      var _a2;
      invalidate();
      (_a2 = $$props.onchange) == null ? void 0 : _a2.call($$props, event);
    };
    trackballControls.set(controls);
    controls.addEventListener("change", handleChange);
    return () => {
      trackballControls.set(void 0);
      controls.removeEventListener("change", handleChange);
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: controls }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(TrackballControls2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TrackballControls2 = hmr(TrackballControls2, () => TrackballControls2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackballControls2[HMR].source;
    set(TrackballControls2[HMR].source, module.default[HMR].original);
  });
}
var TrackballControls_default = TrackballControls2;
mark_module_end(TrackballControls2);

// node_modules/@threlte/extras/dist/components/Instancing/api.js
var getContextId = (instancedMeshId) => `threlte-instanced-mesh-${instancedMeshId}`;
var createApi = (instancedMesh, instancedMeshId) => {
  const api = {
    instancedMesh: currentWritable(instancedMesh),
    addInstance(instance) {
      api.instances.update((arr) => {
        arr.push(instance);
        return arr;
      });
    },
    removeInstance(instance) {
      api.instances.update((arr) => {
        const index = arr.indexOf(instance);
        if (index > -1)
          arr.splice(index, 1);
        return arr;
      });
    },
    instances: currentWritable([])
  };
  setContext(getContextId(instancedMeshId), api);
  return api;
};
var useApi = (instancedMeshId) => {
  const context = getContext(getContextId(instancedMeshId));
  if (!context)
    throw new Error(`No <InstancedMesh> component found for id ${instancedMeshId}`);
  return context;
};

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
mark_module_start();
Api[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Api.svelte";
var root3 = add_locations(template(`<!> <!> <!>`, 1), Api[FILENAME], []);
function Api($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Api);
  const [$$stores, $$cleanup] = setup_stores();
  const $instances = () => (validate_store(instances, "instances"), store_get(instances, "$instances", $$stores));
  let instancedMesh = prop($$props, "instancedMesh", 7);
  const { instances } = createApi(instancedMesh(), $$props.id);
  const tempMatrix3 = new Matrix4();
  const matrices = new Float32Array($$props.limit * 16);
  for (let i = 0; i < $$props.limit; i++) tempMatrix3.identity().toArray(matrices, i * 16);
  const colors = new Float32Array($$props.limit * 3).fill(1);
  const parentMatrix = new Matrix4();
  const instanceMatrix = new Matrix4();
  const translation = new Vector3();
  const rotation = new Quaternion();
  const scale = new Vector3();
  let initialUpdateDone = false;
  useTask(() => {
    instancedMesh().updateMatrix();
    if ($$props.update || !initialUpdateDone) {
      instancedMesh().updateMatrixWorld();
      parentMatrix.copy(instancedMesh().matrixWorld).invert();
      if (instancedMesh().instanceColor) {
        instancedMesh().instanceColor.needsUpdate = true;
      }
      instancedMesh().instanceMatrix.needsUpdate = true;
      for (let i = 0, l = instances.current.length; i < l; i++) {
        const instance = instances.current[i];
        instance.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);
        instanceMatrix.toArray(matrices, i * 16);
        instance.color.toArray(colors, i * 3);
      }
      initialUpdateDone = true;
    }
  });
  user_pre_effect(() => {
    const updateRange = Math.min($$props.limit, strict_equals($$props.range, void 0, false) ? $$props.range : $$props.limit, $instances().length);
    instancedMesh().count = updateRange;
    if (revision >= 159) {
      instancedMesh().instanceMatrix.clearUpdateRanges();
      instancedMesh().instanceMatrix.addUpdateRange(0, updateRange * 16);
    } else {
      instancedMesh().instanceMatrix.updateRange.count = updateRange * 16;
    }
    if (instancedMesh().instanceColor) {
      if (revision >= 159) {
        instancedMesh().instanceColor.clearUpdateRanges();
        instancedMesh().instanceColor.addUpdateRange(0, updateRange * 3);
      } else {
        instancedMesh().instanceColor.updateRange.count = updateRange * 3;
      }
    }
  });
  var fragment = root3();
  var node = first_child(fragment);
  var count = derived(() => matrices.length / 16);
  component(node, () => T.InstancedBufferAttribute, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      attach: "instanceMatrix",
      get count() {
        return get(count);
      },
      array: matrices,
      itemSize: 16,
      usage: DynamicDrawUsage
    });
  });
  var node_1 = sibling(node, 2);
  var count_1 = derived(() => colors.length / 3);
  component(node_1, () => T.InstancedBufferAttribute, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      attach: "instanceColor",
      get count() {
        return get(count_1);
      },
      array: colors,
      itemSize: 3,
      usage: DynamicDrawUsage
    });
  });
  var node_2 = sibling(node_1, 2);
  snippet(node_2, () => $$props.children ?? noop);
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Api = hmr(Api, () => Api[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Api[HMR].source;
    set(Api[HMR].source, module.default[HMR].original);
  });
}
var Api_default = Api;
mark_module_end(Api);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
mark_module_start();
InstancedMesh_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte";
function InstancedMesh_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMesh_1);
  let id = prop($$props, "id", 3, "default"), limit = prop($$props, "limit", 3, 1e3), range = prop($$props, "range", 3, 1e3), update = prop($$props, "update", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "limit",
      "range",
      "update",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new InstancedMesh(null, null, 0);
  const args = [null, null, 0];
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: mesh,
        raycast: () => null,
        matrixAutoUpdate: false,
        args
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(InstancedMesh_1, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          Api_default(node_1, {
            instancedMesh: mesh,
            get id() {
              return id();
            },
            get limit() {
              return limit();
            },
            get range() {
              return range();
            },
            get update() {
              return update();
            },
            children: wrap_snippet(InstancedMesh_1, ($$anchor3, $$slotProps2) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              snippet(node_2, () => $$props.children ?? noop, () => ({ ref: mesh }));
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          });
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedMesh_1 = hmr(InstancedMesh_1, () => InstancedMesh_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedMesh_1[HMR].source;
    set(InstancedMesh_1[HMR].source, module.default[HMR].original);
  });
}
var InstancedMesh_default = InstancedMesh_1;
mark_module_end(InstancedMesh_1);

// node_modules/@threlte/extras/dist/components/Instancing/PositionMesh.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var PositionMesh = class extends Group {
  constructor(instancedMesh, instances) {
    super();
    __publicField(this, "color");
    __publicField(this, "instancedMesh");
    __publicField(this, "instances");
    this.color = new Color("white");
    this.instancedMesh = instancedMesh;
    this.instances = instances;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _a2;
    return (_a2 = this.instancedMesh.current) == null ? void 0 : _a2.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    var _a2;
    const parent = this.instancedMesh.current;
    if (parent === void 0)
      return;
    if (parent.geometry === void 0 || parent.material === void 0)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    const instanceId = this.instances.current.indexOf(this);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (isInstanceOf(parent.material, "Material")) {
      _mesh.material.side = parent.material.side;
    } else {
      _mesh.material.side = ((_a2 = parent.material[0]) == null ? void 0 : _a2.side) ?? FrontSide;
    }
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
      const intersect = _instanceIntersects[i];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@threlte/extras/dist/components/Instancing/useInstanceId.js
var key = Symbol("threlte-instance-id");
var createInstanceIdContext = (uuid) => {
  setContext(key, uuid);
};
var useInstanceId = () => {
  return getContext(key) ?? "default";
};

// node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte
mark_module_start();
Instance[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte";
function Instance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Instance);
  let id = prop($$props, "id", 19, useInstanceId), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children"
    ],
    "props"
  );
  const {
    addInstance,
    removeInstance,
    instancedMesh,
    instances
  } = useApi(id());
  const mesh = new PositionMesh(instancedMesh, instances);
  addInstance(mesh);
  onDestroy(() => {
    removeInstance(mesh);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: mesh }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Instance, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Instance = hmr(Instance, () => Instance[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Instance[HMR].source;
    set(Instance[HMR].source, module.default[HMR].original);
  });
}
var Instance_default = Instance;
mark_module_end(Instance);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte
mark_module_start();
InnerInstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte";
function InnerInstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InnerInstancedMeshes);
  let index = prop($$props, "index", 19, () => $$props.meshes.length - 1), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "meshes",
      "index",
      "children"
    ],
    "props"
  );
  const mesh = $$props.meshes[index()];
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      InstancedMesh_default(node_1, spread_props(
        {
          get geometry() {
            return mesh.geometry;
          },
          get material() {
            return mesh.material;
          },
          get id() {
            return mesh.uuid;
          }
        },
        () => props,
        {
          children: wrap_snippet(InnerInstancedMeshes, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            var index_1 = derived(() => index() - 1);
            InnerInstancedMeshes_default(node_2, spread_props(
              {
                get meshes() {
                  return $$props.meshes;
                },
                get index() {
                  return get(index_1);
                }
              },
              () => props,
              {
                children: wrap_snippet(InnerInstancedMeshes, ($$anchor4, $$slotProps2) => {
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  snippet(node_3, () => $$props.children ?? noop);
                  append($$anchor4, fragment_3);
                }),
                $$slots: { default: true }
              }
            ));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_4 = comment();
      var node_4 = first_child(fragment_4);
      snippet(node_4, () => $$props.children ?? noop);
      append($$anchor2, fragment_4);
    };
    if_block(node, ($$render) => {
      if (index() > -1) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InnerInstancedMeshes = hmr(InnerInstancedMeshes, () => InnerInstancedMeshes[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InnerInstancedMeshes[HMR].source;
    set(InnerInstancedMeshes[HMR].source, module.default[HMR].original);
  });
}
var InnerInstancedMeshes_default = InnerInstancedMeshes;
mark_module_end(InnerInstancedMeshes);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte
mark_module_start();
InstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte";
function InstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMeshes);
  let props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "meshes",
      "children"
    ],
    "props"
  );
  const getInstance = (id) => {
    return (...args) => {
      createInstanceIdContext(id);
      return Instance_default(...args);
    };
  };
  const getInstanceComponentsArray = (meshes) => {
    return meshes.filter((mesh) => mesh.isMesh).map((mesh) => getInstance(mesh.uuid));
  };
  const getInstanceComponentsObject = (meshes) => {
    return Object.entries(meshes).reduce(
      (acc, [id, mesh]) => {
        if (!mesh.isMesh) return acc;
        acc[id] = getInstance(mesh.uuid);
        return acc;
      },
      {}
    );
  };
  let components = derived(() => Array.isArray($$props.meshes) ? getInstanceComponentsArray($$props.meshes) : getInstanceComponentsObject($$props.meshes));
  let meshesArray = derived(() => Array.isArray($$props.meshes) ? $$props.meshes : Object.values($$props.meshes));
  let filteredMeshesArray = derived(() => get(meshesArray).filter((mesh) => mesh.isMesh));
  var fragment = comment();
  var node = first_child(fragment);
  InnerInstancedMeshes_default(node, spread_props(
    {
      get meshes() {
        return get(filteredMeshesArray);
      }
    },
    () => props,
    {
      children: wrap_snippet(InstancedMeshes, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ components: get(components) }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedMeshes = hmr(InstancedMeshes, () => InstancedMeshes[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedMeshes[HMR].source;
    set(InstancedMeshes[HMR].source, module.default[HMR].original);
  });
}
var InstancedMeshes_default = InstancedMeshes;
mark_module_end(InstancedMeshes);

// node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte
mark_module_start();
SoftShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte";
function SoftShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SoftShadows);
  const { renderer, camera, scene } = useThrelte();
  let size = prop($$props, "size", 3, 25), focus = prop($$props, "focus", 3, 0), samples = prop($$props, "samples", 3, 10);
  const original = ShaderChunk.shadowmap_pars_fragment;
  let pcss = derived(() => `
		#define PENUMBRA_FILTER_SIZE float(${size()})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${focus()});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${samples()}; i ++) {
				offset = (vogelDiskSample(j, ${samples()}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${samples()}; i++) {
				vogelSample = vogelDiskSample(j, ${samples()}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${size()}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${samples()}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`);
  const recompile = () => {
    scene.traverse((o) => {
      var _a2, _b2;
      const object = o;
      if (object.material) {
        renderer == null ? void 0 : renderer.properties.remove(object.material);
        (_b2 = (_a2 = object.material).dispose) == null ? void 0 : _b2.call(_a2);
      }
    });
    if (renderer == null ? void 0 : renderer.info.programs) renderer.info.programs.length = 0;
    renderer == null ? void 0 : renderer.compile(scene, camera.current);
  };
  user_pre_effect(() => {
    ShaderChunk.shadowmap_pars_fragment = original.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
${get(pcss)}`).replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    recompile();
  });
  onDestroy(() => {
    ShaderChunk.shadowmap_pars_fragment = original;
    recompile();
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SoftShadows = hmr(SoftShadows, () => SoftShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SoftShadows[HMR].source;
    set(SoftShadows[HMR].source, module.default[HMR].original);
  });
}
var SoftShadows_default = SoftShadows;
mark_module_end(SoftShadows);

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte
mark_module_start();
MeshLineGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte";
function MeshLineGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineGeometry);
  let points = prop($$props, "points", 19, () => []), shape = prop($$props, "shape", 3, "none"), shapeFunction = prop($$props, "shapeFunction", 7, () => 1), ref = prop($$props, "ref", 15);
  let pointCount = points().length;
  const { invalidate } = useThrelte();
  const positions = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const previous = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const next = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const counters = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const side = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const width = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const uv = new BufferAttribute(new Float32Array(pointCount * 4), 2);
  const indices = new BufferAttribute(new Uint16Array(pointCount * 6), 1);
  if (strict_equals(shape(), "taper")) {
    shapeFunction((p) => 1 * Math.pow(4 * p * (1 - p), 1));
  }
  for (let i = 0, i2 = 0, i3 = 0, i4 = 0; i < pointCount; i += 1, i2 += 2, i3 += 4, i4 += 6) {
    counters.setX(i2, i / points().length);
    counters.setX(i2 + 1, i / points().length);
    side.setX(i2, 1);
    side.setX(i2 + 1, -1);
    const w = strict_equals(shape(), "none") ? 1 : shapeFunction()(i / (pointCount - 1));
    width.setX(i2, w);
    width.setX(i2 + 1, w);
    uv.setXYZW(i2, i / (pointCount - 1), 0, i / (pointCount - 1), 1);
    if (i < pointCount - 1) {
      const n2 = i * 2;
      indices.setX(i4 + 0, n2 + 0);
      indices.setX(i4 + 1, n2 + 1);
      indices.setX(i4 + 2, n2 + 2);
      indices.setX(i4 + 3, n2 + 2);
      indices.setX(i4 + 4, n2 + 1);
      indices.setX(i4 + 5, n2 + 3);
    }
  }
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("previous", previous);
  geometry.setAttribute("next", next);
  geometry.setAttribute("counters", counters);
  geometry.setAttribute("side", side);
  geometry.setAttribute("width", width);
  geometry.setAttribute("uv", uv);
  geometry.setIndex(indices);
  const setPoints = (points2) => {
    if (strict_equals(points2.length, 0)) return;
    if (strict_equals(points2.length, pointCount, false)) return;
    let positionIndex = 0;
    let previousIndex = 0;
    let nextIndex = 0;
    const p1 = points2[0];
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    for (let i = 0; i < pointCount; i++) {
      const p = points2[i];
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      if (i < pointCount - 1) {
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
      }
      if (i > 0 && i + 1 <= pointCount) {
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
      }
    }
    const p2 = points2[pointCount - 1];
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    positions.needsUpdate = true;
    previous.needsUpdate = true;
    next.needsUpdate = true;
    geometry.computeBoundingSphere();
    invalidate();
  };
  user_pre_effect(() => setPoints(points()));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: geometry }, () => $$props.props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(MeshLineGeometry, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: geometry }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshLineGeometry = hmr(MeshLineGeometry, () => MeshLineGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshLineGeometry[HMR].source;
    set(MeshLineGeometry[HMR].source, module.default[HMR].original);
  });
}
var MeshLineGeometry_default = MeshLineGeometry;
mark_module_end(MeshLineGeometry);

// node_modules/@threlte/extras/dist/components/MeshLine/fragment.js
var fragmentShader3 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

vec4 CustomLinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

void main()	{
	#include <logdepthbuf_fragment>
	#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = CustomLinearTosRGB(c);
}
`;

// node_modules/@threlte/extras/dist/components/MeshLine/vertex.js
var vertexShader3 = `
    #include <common>
    ${ShaderChunk.logdepthbuf_pars_vertex}
    ${ShaderChunk.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${ShaderChunk.logdepthbuf_vertex}
        ${ShaderChunk.fog_vertex}
    }
`;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte
mark_module_start();
MeshLineMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte";
function MeshLineMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineMaterial);
  const [$$stores, $$cleanup] = setup_stores();
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  let opacity = prop($$props, "opacity", 3, 1), color2 = prop($$props, "color", 3, "#ffffff"), dashOffset = prop($$props, "dashOffset", 3, 0), dashArray = prop($$props, "dashArray", 3, 0), dashRatio = prop($$props, "dashRatio", 3, 0), attenuate = prop($$props, "attenuate", 3, true), width = prop($$props, "width", 3, 1), scaleDown = prop($$props, "scaleDown", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "color",
      "dashOffset",
      "dashArray",
      "dashRatio",
      "attenuate",
      "width",
      "scaleDown",
      "alphaMap",
      "ref",
      "children"
    ],
    "props"
  );
  let { invalidate, size } = useThrelte();
  const uniforms = {
    lineWidth: { value: width() },
    color: { value: new Color(color2()) },
    opacity: { value: opacity() },
    resolution: { value: new Vector2(1, 1) },
    sizeAttenuation: { value: attenuate() ? 1 : 0 },
    dashArray: { value: dashArray() },
    dashOffset: { value: dashOffset() },
    dashRatio: { value: dashRatio() },
    useDash: { value: dashArray() > 0 ? 1 : 0 },
    scaleDown: { value: scaleDown() / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: $$props.alphaMap },
    useAlphaMap: { value: $$props.alphaMap ? 1 : 0 }
  };
  const material = new ShaderMaterial({ uniforms });
  user_pre_effect(() => {
    uniforms.resolution.value.set($size().width, $size().height);
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.dashRatio.value = dashRatio();
    uniforms.dashArray.value = dashArray();
    uniforms.dashOffset.value = dashOffset();
    uniforms.lineWidth.value = width();
    uniforms.opacity.value = opacity();
    uniforms.color.value.set(color2());
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: material, fragmentShader: fragmentShader3, vertexShader: vertexShader3 }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(MeshLineMaterial, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MeshLineMaterial = hmr(MeshLineMaterial, () => MeshLineMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshLineMaterial[HMR].source;
    set(MeshLineMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshLineMaterial_default = MeshLineMaterial;
mark_module_end(MeshLineMaterial);

// node_modules/three/examples/jsm/objects/Sky.js
var Sky = class _Sky extends Mesh {
  constructor() {
    const shader = _Sky.SkyShader;
    const material = new ShaderMaterial({
      name: shader.name,
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      depthWrite: false
    });
    super(new BoxGeometry(1, 1, 1), material);
    this.isSky = true;
  }
};
Sky.SkyShader = {
  name: "SkyShader",
  uniforms: {
    "turbidity": { value: 2 },
    "rayleigh": { value: 1 },
    "mieCoefficient": { value: 5e-3 },
    "mieDirectionalG": { value: 0.8 },
    "sunPosition": { value: new Vector3() },
    "up": { value: new Vector3(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};

// node_modules/@threlte/extras/dist/components/Sky/Sky.svelte
mark_module_start();
Sky_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Sky/Sky.svelte";
function Sky_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Sky_1);
  let scale = prop($$props, "scale", 3, 1e3), turbidity = prop($$props, "turbidity", 3, 10), rayleigh = prop($$props, "rayleigh", 3, 3), mieCoefficient = prop($$props, "mieCoefficient", 3, 5e-3), mieDirectionalG = prop($$props, "mieDirectionalG", 3, 0.7), elevation = prop($$props, "elevation", 3, 2), azimuth = prop($$props, "azimuth", 3, 180), setEnvironment = prop($$props, "setEnvironment", 3, true), cubeMapSize = prop($$props, "cubeMapSize", 3, 128), webGLRenderTargetOptions = prop($$props, "webGLRenderTargetOptions", 19, () => ({})), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "scale",
      "turbidity",
      "rayleigh",
      "mieCoefficient",
      "mieDirectionalG",
      "elevation",
      "azimuth",
      "setEnvironment",
      "cubeMapSize",
      "webGLRenderTargetOptions",
      "ref",
      "children"
    ],
    "props"
  );
  const sky = new Sky();
  const sunPosition = new Vector3();
  const { uniforms } = sky.material;
  const { renderer, scene, invalidate } = useThrelte();
  let renderTarget = state(void 0);
  let cubeCamera;
  const init2 = () => {
    set(renderTarget, proxy(
      new WebGLCubeRenderTarget(cubeMapSize(), {
        type: HalfFloatType,
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter,
        ...webGLRenderTargetOptions()
      }),
      null,
      renderTarget
    ));
    cubeCamera = new CubeCamera(1, 1.1, get(renderTarget));
  };
  const originalEnvironment = scene.environment;
  user_pre_effect(() => {
    if (setEnvironment() && get(renderTarget)) {
      scene.environment = get(renderTarget).texture;
      invalidate();
    } else if (!setEnvironment()) {
      scene.environment = originalEnvironment;
      invalidate();
    }
  });
  const { start: scheduleUpdate, stop } = useTask(
    () => {
      sky.scale.setScalar(scale());
      uniforms.turbidity.value = turbidity();
      uniforms.rayleigh.value = rayleigh();
      uniforms.mieCoefficient.value = mieCoefficient();
      uniforms.mieDirectionalG.value = mieDirectionalG();
      const phi = MathUtils.degToRad(90 - elevation());
      const theta = MathUtils.degToRad(azimuth());
      sunPosition.setFromSphericalCoords(1, phi, theta);
      uniforms.sunPosition.value.copy(sunPosition);
      if (setEnvironment()) {
        if (!get(renderTarget) || !cubeCamera) init2();
        cubeCamera == null ? void 0 : cubeCamera.update(renderer, sky);
      }
      invalidate();
      stop();
    },
    { autoStart: false, autoInvalidate: false }
  );
  user_pre_effect(() => {
    scale();
    turbidity();
    rayleigh();
    mieCoefficient();
    mieDirectionalG();
    elevation();
    azimuth();
    scheduleUpdate();
  });
  onDestroy(() => {
    var _a2;
    sky.material.dispose();
    scene.environment = originalEnvironment;
    try {
      (_a2 = get(renderTarget)) == null ? void 0 : _a2.dispose();
    } catch (error) {
      console.warn(...log_if_contains_state("warn", "Could not dispose renderTarget:", error));
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: sky }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Sky_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({
          ref: sky,
          sunPosition,
          renderTarget: get(renderTarget)
        }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Sky_1 = hmr(Sky_1, () => Sky_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Sky_1[HMR].source;
    set(Sky_1[HMR].source, module.default[HMR].original);
  });
}
var Sky_default = Sky_1;
mark_module_end(Sky_1);

// node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte
mark_module_start();
InjectPlugin[FILENAME] = "node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte";
function InjectPlugin($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InjectPlugin);
  injectPlugin($$props.name, $$props.plugin);
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InjectPlugin = hmr(InjectPlugin, () => InjectPlugin[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InjectPlugin[HMR].source;
    set(InjectPlugin[HMR].source, module.default[HMR].original);
  });
}
var InjectPlugin_default = InjectPlugin;
mark_module_end(InjectPlugin);

// node_modules/@threlte/extras/dist/components/Align/Align.svelte
mark_module_start();
Align[FILENAME] = "node_modules/@threlte/extras/dist/components/Align/Align.svelte";
function Align($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Align);
  const { renderStage } = useThrelte();
  let x = prop($$props, "x", 3, 0), y2 = prop($$props, "y", 3, 0), z2 = prop($$props, "z", 3, 0), precise = prop($$props, "precise", 3, false), auto = prop($$props, "auto", 3, false), ref = prop($$props, "ref", 15), stage = prop($$props, "stage", 19, () => useStage("<Align>", { before: renderStage })), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "z",
      "precise",
      "auto",
      "ref",
      "onalign",
      "children",
      "stage"
    ],
    "props"
  );
  const group = new Group();
  const innerGroup = new Group();
  const outerGroup = new Group();
  const calculate = () => {
    var _a2;
    if (strict_equals(x(), false) && strict_equals(y2(), false) && strict_equals(z2(), false)) return;
    outerGroup.matrixWorld.identity();
    const box3 = new Box3().setFromObject(innerGroup, precise());
    const align2 = new Vector3();
    const sphere2 = new Sphere();
    const width = box3.max.x - box3.min.x;
    const height = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    box3.getCenter(align2);
    box3.getBoundingSphere(sphere2);
    const vAlign = (y2() || 0) * height / 2;
    const hAlign = (x() || 0) * width / 2;
    const dAlign = (z2() || 0) * depth / 2;
    outerGroup.position.set(strict_equals(x(), false) ? 0 : -align2.x + hAlign, strict_equals(y2(), false) ? 0 : -align2.y + vAlign, strict_equals(z2(), false) ? 0 : -align2.z + dAlign);
    (_a2 = $$props.onalign) == null ? void 0 : _a2.call($$props, {
      boundingBox: box3,
      center: outerGroup.position.clone(),
      boundingSphere: sphere2,
      container: group,
      depth,
      depthAlignment: dAlign,
      height,
      verticalAlignment: vAlign,
      width,
      horizontalAlignment: hAlign
    });
  };
  const { start: scheduleAligning, stop } = useTask(
    () => {
      calculate();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const align = scheduleAligning;
  observe(() => [x(), y2(), z2(), precise()], scheduleAligning);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleAligning();
      return () => {
        if (auto()) scheduleAligning();
      };
    });
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Align, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: outerGroup,
          children: wrap_snippet(Align, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: innerGroup,
              children: wrap_snippet(Align, ($$anchor4, $$slotProps3) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                InjectPlugin_default(node_3, {
                  name: "align",
                  plugin,
                  children: wrap_snippet(Align, ($$anchor5, $$slotProps4) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    snippet(node_4, () => $$props.children ?? noop, () => ({ align: scheduleAligning, ref: group }));
                    append($$anchor5, fragment_4);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get align() {
      return align;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Align = hmr(Align, () => Align[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Align[HMR].source;
    set(Align[HMR].source, module.default[HMR].original);
  });
}
var Align_default = Align;
mark_module_end(Align);

// node_modules/three/examples/jsm/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class _CSMFrustum {
  constructor(data) {
    data = data || {};
    this.zNear = data.webGL === true ? -1 : 0;
    this.vertices = {
      near: [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ],
      far: [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const zNear = this.zNear;
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, zNear);
    this.vertices.near[1].set(1, -1, zNear);
    this.vertices.near[2].set(-1, -1, zNear);
    this.vertices.near[3].set(-1, 1, zNear);
    this.vertices.near.forEach(function(v4) {
      v4.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v4) {
      v4.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v4.z);
      if (isOrthographic) {
        v4.z *= Math.min(maxFar / absZ, 1);
      } else {
        v4.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new _CSMFrustum());
    }
    target.length = breaks.length;
    for (let i = 0; i < breaks.length; i++) {
      const cascade = target[i];
      if (i === 0) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].copy(this.vertices.near[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i - 1]);
        }
      }
      if (i === breaks.length - 1) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].copy(this.vertices.far[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i = 0; i < 4; i++) {
      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);
      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/three/examples/jsm/csm/CSMShader.js
var CSMShader = {
  lights_fragment_begin: (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
  )
};

// node_modules/three/examples/jsm/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum({ webGL: true });
var _center = new Vector3();
var _bbox = new Box3();
var _uniformArray = [];
var _logArray = [];
var _lightOrientationMatrix = new Matrix4();
var _lightOrientationMatrixInverse = new Matrix4();
var _up = new Vector3(0, 1, 0);
var CSM = class {
  constructor(data) {
    this.camera = data.camera;
    this.parent = data.parent;
    this.cascades = data.cascades || 3;
    this.maxFar = data.maxFar || 1e5;
    this.mode = data.mode || "practical";
    this.shadowMapSize = data.shadowMapSize || 2048;
    this.shadowBias = data.shadowBias || 1e-6;
    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();
    this.lightIntensity = data.lightIntensity || 3;
    this.lightNear = data.lightNear || 1;
    this.lightFar = data.lightFar || 2e3;
    this.lightMargin = data.lightMargin || 200;
    this.customSplitsCallback = data.customSplitsCallback;
    this.fade = false;
    this.mainFrustum = new CSMFrustum({ webGL: true });
    this.frustums = [];
    this.breaks = [];
    this.lights = [];
    this.shaders = /* @__PURE__ */ new Map();
    this.createLights();
    this.updateFrustums();
    this.injectInclude();
  }
  createLights() {
    for (let i = 0; i < this.cascades; i++) {
      const light = new DirectionalLight(16777215, this.lightIntensity);
      light.castShadow = true;
      light.shadow.mapSize.width = this.shadowMapSize;
      light.shadow.mapSize.height = this.shadowMapSize;
      light.shadow.camera.near = this.lightNear;
      light.shadow.camera.far = this.lightFar;
      light.shadow.bias = this.shadowBias;
      this.parent.add(light);
      this.parent.add(light.target);
      this.lights.push(light);
    }
  }
  initCascades() {
    const camera = this.camera;
    camera.updateProjectionMatrix();
    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);
    this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const frustums = this.frustums;
    for (let i = 0; i < frustums.length; i++) {
      const light = this.lights[i];
      const shadowCam = light.shadow.camera;
      const frustum = this.frustums[i];
      const nearVerts = frustum.vertices.near;
      const farVerts = frustum.vertices.far;
      const point1 = farVerts[0];
      let point2;
      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
        point2 = farVerts[2];
      } else {
        point2 = nearVerts[2];
      }
      let squaredBBWidth = point1.distanceTo(point2);
      if (this.fade) {
        const camera = this.camera;
        const far = Math.max(camera.far, this.maxFar);
        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);
        const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);
        squaredBBWidth += margin;
      }
      shadowCam.left = -squaredBBWidth / 2;
      shadowCam.right = squaredBBWidth / 2;
      shadowCam.top = squaredBBWidth / 2;
      shadowCam.bottom = -squaredBBWidth / 2;
      shadowCam.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const camera = this.camera;
    const far = Math.min(camera.far, this.maxFar);
    this.breaks.length = 0;
    switch (this.mode) {
      case "uniform":
        uniformSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "logarithmic":
        logarithmicSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "practical":
        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);
        break;
      case "custom":
        if (this.customSplitsCallback === void 0) console.error("CSM: Custom split scheme callback not defined.");
        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);
        break;
    }
    function uniformSplit(amount, near, far2, target) {
      for (let i = 1; i < amount; i++) {
        target.push((near + (far2 - near) * i / amount) / far2);
      }
      target.push(1);
    }
    function logarithmicSplit(amount, near, far2, target) {
      for (let i = 1; i < amount; i++) {
        target.push(near * (far2 / near) ** (i / amount) / far2);
      }
      target.push(1);
    }
    function practicalSplit(amount, near, far2, lambda, target) {
      _uniformArray.length = 0;
      _logArray.length = 0;
      logarithmicSplit(amount, near, far2, _logArray);
      uniformSplit(amount, near, far2, _uniformArray);
      for (let i = 1; i < amount; i++) {
        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));
      }
      target.push(1);
    }
  }
  update() {
    const camera = this.camera;
    const frustums = this.frustums;
    _lightOrientationMatrix.lookAt(new Vector3(), this.lightDirection, _up);
    _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();
    for (let i = 0; i < frustums.length; i++) {
      const light = this.lights[i];
      const shadowCam = light.shadow.camera;
      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
      _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, camera.matrixWorld);
      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
      const nearVerts = _lightSpaceFrustum.vertices.near;
      const farVerts = _lightSpaceFrustum.vertices.far;
      _bbox.makeEmpty();
      for (let j2 = 0; j2 < 4; j2++) {
        _bbox.expandByPoint(nearVerts[j2]);
        _bbox.expandByPoint(farVerts[j2]);
      }
      _bbox.getCenter(_center);
      _center.z = _bbox.max.z + this.lightMargin;
      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;
      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;
      _center.applyMatrix4(_lightOrientationMatrix);
      light.position.copy(_center);
      light.target.position.copy(_center);
      light.target.position.x += this.lightDirection.x;
      light.target.position.y += this.lightDirection.y;
      light.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;
    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;
  }
  setupMaterial(material) {
    material.defines = material.defines || {};
    material.defines.USE_CSM = 1;
    material.defines.CSM_CASCADES = this.cascades;
    if (this.fade) {
      material.defines.CSM_FADE = "";
    }
    const breaksVec2 = [];
    const scope = this;
    const shaders = this.shaders;
    material.onBeforeCompile = function(shader) {
      const far = Math.min(scope.camera.far, scope.maxFar);
      scope.getExtendedBreaks(breaksVec2);
      shader.uniforms.CSM_cascades = { value: breaksVec2 };
      shader.uniforms.cameraNear = { value: scope.camera.near };
      shader.uniforms.shadowFar = { value: far };
      shaders.set(material, shader);
    };
    shaders.set(material, null);
  }
  updateUniforms() {
    const far = Math.min(this.camera.far, this.maxFar);
    const shaders = this.shaders;
    shaders.forEach(function(shader, material) {
      if (shader !== null) {
        const uniforms = shader.uniforms;
        this.getExtendedBreaks(uniforms.CSM_cascades.value);
        uniforms.cameraNear.value = this.camera.near;
        uniforms.shadowFar.value = far;
      }
      if (!this.fade && "CSM_FADE" in material.defines) {
        delete material.defines.CSM_FADE;
        material.needsUpdate = true;
      } else if (this.fade && !("CSM_FADE" in material.defines)) {
        material.defines.CSM_FADE = "";
        material.needsUpdate = true;
      }
    }, this);
  }
  getExtendedBreaks(target) {
    while (target.length < this.breaks.length) {
      target.push(new Vector2());
    }
    target.length = this.breaks.length;
    for (let i = 0; i < this.cascades; i++) {
      const amount = this.breaks[i];
      const prev = this.breaks[i - 1] || 0;
      target[i].x = prev;
      target[i].y = amount;
    }
  }
  updateFrustums() {
    this.getBreaks();
    this.initCascades();
    this.updateShadowBounds();
    this.updateUniforms();
  }
  remove() {
    for (let i = 0; i < this.lights.length; i++) {
      this.parent.remove(this.lights[i].target);
      this.parent.remove(this.lights[i]);
    }
  }
  dispose() {
    const shaders = this.shaders;
    shaders.forEach(function(shader, material) {
      delete material.onBeforeCompile;
      delete material.defines.USE_CSM;
      delete material.defines.CSM_CASCADES;
      delete material.defines.CSM_FADE;
      if (shader !== null) {
        delete shader.uniforms.CSM_cascades;
        delete shader.uniforms.cameraNear;
        delete shader.uniforms.shadowFar;
      }
      material.needsUpdate = true;
    });
    shaders.clear();
  }
};

// node_modules/@threlte/extras/dist/components/CSM/useMaterials.js
var useMaterials = () => {
  let setupCallback = void 0;
  const allMaterials = /* @__PURE__ */ new Set();
  const isSupportedMaterial = (material) => {
    return isInstanceOf(material, "MeshStandardMaterial") || isInstanceOf(material, "MeshPhongMaterial");
  };
  const addMaterial = (material) => {
    if (allMaterials.has(material))
      return;
    allMaterials.add(material);
    setupCallback == null ? void 0 : setupCallback(material);
  };
  const extractMaterials = (ref) => {
    if (isSupportedMaterial(ref)) {
      addMaterial(ref);
    } else if (isInstanceOf(ref, "Mesh")) {
      if (Array.isArray(ref.material)) {
        ref.material.forEach((material) => {
          if (isSupportedMaterial(material)) {
            addMaterial(material);
          }
        });
      } else {
        if (isSupportedMaterial(ref.material)) {
          addMaterial(ref.material);
        }
      }
    }
  };
  const onNewMaterial = (callback) => {
    setupCallback = callback;
  };
  injectPlugin("csm", (args) => {
    onMount(() => {
      extractMaterials(args.ref);
    });
  });
  onDestroy(() => setupCallback = void 0);
  return { onNewMaterial, allMaterials };
};

// node_modules/@threlte/extras/dist/components/CSM/CSM.svelte
mark_module_start();
CSM_1[FILENAME] = "node_modules/@threlte/extras/dist/components/CSM/CSM.svelte";
var root4 = add_locations(template(`<!> <!>`, 1), CSM_1[FILENAME], []);
function CSM_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, CSM_1);
  const [$$stores, $$cleanup] = setup_stores();
  const $csmStore = () => (validate_store(csmStore, "csmStore"), store_get(csmStore, "$csmStore", $$stores));
  const $defaultCamera = () => (validate_store(defaultCamera, "defaultCamera"), store_get(defaultCamera, "$defaultCamera", $$stores));
  let enabled = prop($$props, "enabled", 8, true);
  let args = prop($$props, "args", 24, () => ({}));
  let camera = prop($$props, "camera", 8, void 0);
  let configure = prop($$props, "configure", 8, void 0);
  let lightIntensity = prop($$props, "lightIntensity", 8, void 0);
  let lightColor = prop($$props, "lightColor", 8, void 0);
  let lightDirection = prop($$props, "lightDirection", 24, () => [1, -1, 1]);
  const enabledStore = writable(enabled());
  const { camera: defaultCamera, scene, size } = useThrelte();
  const csmStore = currentWritable(void 0);
  useTask(() => {
    var _a2;
    return (_a2 = $csmStore()) == null ? void 0 : _a2.update();
  }, { autoInvalidate: false });
  const { onNewMaterial, allMaterials } = useMaterials();
  const disposeCsm = () => {
    var _a2, _b2;
    (_a2 = $csmStore()) == null ? void 0 : _a2.remove();
    (_b2 = $csmStore()) == null ? void 0 : _b2.dispose();
    store_set(csmStore, void 0);
  };
  watch([size, csmStore], ([_, csm]) => {
    if (!csm) return;
    csm.updateFrustums();
  });
  const cameraStore = writable(camera());
  watch([defaultCamera, cameraStore, csmStore], ([defaultCamera2, camera2, csm]) => {
    if (!csm) return;
    csm.camera = camera2 ?? defaultCamera2;
    if (strict_equals(args().maxFar, void 0, false)) csm.maxFar = args().maxFar;
    if (strict_equals(args().mode, void 0, false)) csm.mode = args().mode;
    csm.updateFrustums();
  });
  watch(enabledStore, (enabled2) => {
    var _a2;
    if (enabled2) {
      const csm = new CSM({
        camera: camera() ?? $defaultCamera(),
        parent: scene,
        ...args()
      });
      (_a2 = configure()) == null ? void 0 : _a2(csm);
      for (const material of allMaterials) {
        csm.setupMaterial(material);
      }
      onNewMaterial((material) => csm.setupMaterial(material));
      csmStore.set(csm);
    } else {
      onNewMaterial(void 0);
      disposeCsm();
    }
  });
  const lightIntensityStore = writable(lightIntensity());
  const lightColorStore = writable(lightColor());
  watch(
    [
      csmStore,
      lightIntensityStore,
      lightColorStore
    ],
    ([csm, intensity, color2]) => {
      csm == null ? void 0 : csm.lights.forEach((light) => {
        if (strict_equals(intensity, void 0, false)) {
          light.intensity = intensity / Math.PI;
        }
        if (strict_equals(color2, void 0, false)) {
          light.color.set(color2);
        }
      });
    }
  );
  const lightDirectionStore = writable(lightDirection());
  watch([csmStore, lightDirectionStore], ([csm, direction2]) => {
    csm == null ? void 0 : csm.lightDirection.set(...direction2).normalize();
  });
  onDestroy(disposeCsm);
  legacy_pre_effect(() => deep_read_state(enabled()), () => {
    enabledStore.set(enabled());
  });
  legacy_pre_effect(() => deep_read_state(camera()), () => {
    cameraStore.set(camera());
  });
  legacy_pre_effect(() => deep_read_state(lightIntensity()), () => {
    lightIntensityStore.set(lightIntensity());
  });
  legacy_pre_effect(() => deep_read_state(lightColor()), () => {
    lightColorStore.set(lightColor());
  });
  legacy_pre_effect(() => deep_read_state(lightDirection()), () => {
    lightDirectionStore.set(lightDirection());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root4();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      slot(node_2, $$props, "disabled", {}, null);
      append($$anchor2, fragment_1);
    };
    if_block(node_1, ($$render) => {
      if (!enabled()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  CSM_1 = hmr(CSM_1, () => CSM_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CSM_1[HMR].source;
    set(CSM_1[HMR].source, module.default[HMR].original);
  });
}
var CSM_default = CSM_1;
mark_module_end(CSM_1);

// node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte
mark_module_start();
Billboard[FILENAME] = "node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte";
function Billboard($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Billboard);
  const [$$stores, $$cleanup] = setup_stores();
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  let follow = prop($$props, "follow", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "follow",
      "ref",
      "children"
    ],
    "props"
  );
  const inner = new Group();
  const localRef = new Group();
  const { camera, renderStage } = useThrelte();
  const q2 = new Quaternion();
  let followObject = derived(() => strict_equals(follow(), true) ? $camera() : strict_equals(follow(), false) ? void 0 : follow());
  const stage = useStage("<Billboard>", { before: renderStage });
  const { start, stop } = useTask(
    () => {
      var _a2;
      localRef.updateMatrix();
      localRef.updateWorldMatrix(false, false);
      localRef.getWorldQuaternion(q2);
      (_a2 = get(followObject)) == null ? void 0 : _a2.getWorldQuaternion(inner.quaternion).premultiply(q2.invert());
    },
    { autoStart: false, stage }
  );
  user_pre_effect(() => {
    if (follow()) {
      start();
    } else {
      stop();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: localRef }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Billboard, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: inner,
          children: wrap_snippet(Billboard, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: localRef }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Billboard = hmr(Billboard, () => Billboard[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Billboard[HMR].source;
    set(Billboard[HMR].source, module.default[HMR].original);
  });
}
var Billboard_default = Billboard;
mark_module_end(Billboard);

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/fragment.js
var fragmentShader4 = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/vertex.js
var vertexShader4 = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte
mark_module_start();
FakeGlowMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte";
function FakeGlowMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, FakeGlowMaterial);
  let falloff = prop($$props, "falloff", 3, 0.1), glowInternalRadius = prop($$props, "glowInternalRadius", 3, 6), glowColor = prop($$props, "glowColor", 3, "green"), glowSharpness = prop($$props, "glowSharpness", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "falloff",
      "glowInternalRadius",
      "glowColor",
      "glowSharpness",
      "ref",
      "children"
    ],
    "props"
  );
  const uniforms = {
    falloff: { value: falloff() },
    glowInternalRadius: { value: glowInternalRadius() },
    glowColor: { value: new Color(glowColor()) },
    glowSharpness: { value: glowSharpness() }
  };
  const material = new ShaderMaterial({
    uniforms,
    fragmentShader: fragmentShader4,
    vertexShader: vertexShader4,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false
  });
  const { invalidate } = useThrelte();
  user_pre_effect(() => {
    material.uniforms.falloff.value = falloff();
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowInternalRadius.value = glowInternalRadius();
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowColor.value.set(glowColor());
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowSharpness.value = glowSharpness();
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: material }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(FakeGlowMaterial, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FakeGlowMaterial = hmr(FakeGlowMaterial, () => FakeGlowMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FakeGlowMaterial[HMR].source;
    set(FakeGlowMaterial[HMR].source, module.default[HMR].original);
  });
}
var FakeGlowMaterial_default = FakeGlowMaterial;
mark_module_end(FakeGlowMaterial);

// node_modules/@threlte/extras/dist/components/Stars/fragment.js
var fragmentShader5 = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/Stars/vertex.js
var vertexShader5 = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;

// node_modules/@threlte/extras/dist/components/Stars/Stars.svelte
mark_module_start();
Stars[FILENAME] = "node_modules/@threlte/extras/dist/components/Stars/Stars.svelte";
var root_15 = add_locations(template(`<!> <!> <!>`, 1), Stars[FILENAME], []);
function Stars($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Stars);
  let count = prop($$props, "count", 3, 5e3), radius = prop($$props, "radius", 3, 50), depth = prop($$props, "depth", 3, 50), factor = prop($$props, "factor", 3, 6), saturation = prop($$props, "saturation", 3, 1), lightness = prop($$props, "lightness", 3, 0.8), speed = prop($$props, "speed", 3, 1), fade = prop($$props, "fade", 3, true), opacity = prop($$props, "opacity", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "count",
      "radius",
      "depth",
      "factor",
      "saturation",
      "lightness",
      "speed",
      "fade",
      "opacity",
      "ref",
      "children"
    ],
    "props"
  );
  const points = new Points();
  const vec3 = new Vector3();
  const spherical = new Spherical();
  const color2 = new Color();
  const generateStar = (r) => {
    return vec3.setFromSpherical(spherical.set(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  };
  let positions = new BufferAttribute(new Float32Array(count() * 3), 3);
  let colors = new BufferAttribute(new Float32Array(count() * 3), 3);
  let sizes = new BufferAttribute(new Float32Array(count()), 1);
  user_pre_effect(() => {
    positions = new BufferAttribute(new Float32Array(count() * 3), 3);
    colors = new BufferAttribute(new Float32Array(count() * 3), 3);
    sizes = new BufferAttribute(new Float32Array(count()), 1);
  });
  user_pre_effect(() => {
    const increment = depth() / count();
    let r = radius() + depth();
    for (let i = 0; i < count(); i += 1) {
      r -= increment * Math.random();
      const position2 = generateStar(r);
      positions.setXYZ(i, position2.x, position2.y, position2.z);
      color2.setHSL(i / count(), saturation(), lightness());
      colors.setXYZ(i, color2.r, color2.g, color2.b);
      sizes.setX(i, (0.5 + 0.5 * Math.random()) * factor());
    }
  });
  const { stop, start } = useTask(
    (dt3) => {
      uniforms.time.value += dt3 * speed();
    },
    { autoStart: false }
  );
  user_pre_effect(() => strict_equals(speed(), 0) ? stop() : start());
  const uniforms = {
    time: { value: 0 },
    fade: { value: 1 },
    opacity: { value: 1 }
  };
  const material = new ShaderMaterial({ uniforms, vertexShader: vertexShader5, fragmentShader: fragmentShader5 });
  user_pre_effect(() => {
    uniforms.fade.value = fade() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("color", colors);
  geometry.setAttribute("size", sizes);
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: points }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Stars, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_15();
        var node_1 = first_child(fragment_1);
        T(node_1, { is: geometry });
        var node_2 = sibling(node_1, 2);
        T(node_2, {
          is: material,
          blending: AdditiveBlending,
          depthWrite: false,
          transparent: true,
          vertexColors: true
        });
        var node_3 = sibling(node_2, 2);
        snippet(node_3, () => $$props.children ?? noop, () => ({ ref: points }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Stars = hmr(Stars, () => Stars[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Stars[HMR].source;
    set(Stars[HMR].source, module.default[HMR].original);
  });
}
var Stars_default = Stars;
mark_module_end(Stars);

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");

// node_modules/three-mesh-bvh/src/core/build/geometryUtils.js
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}

// node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js
function getBounds(triangleBounds, offset, count, target, centroidTarget) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx) minx = lx;
    if (rx > maxx) maxx = rx;
    if (cx < cminx) cminx = cx;
    if (cx > cmaxx) cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny) miny = ly;
    if (ry > maxy) maxy = ry;
    if (cy < cminy) cminy = cy;
    if (cy > cmaxy) cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz) minz = lz;
    if (rz > maxz) maxz = rz;
    if (cz < cminz) cminz = cz;
    if (cz > cmaxz) cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, target = null, offset = null, count = null) {
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const normalized = posAttr.normalized;
  let triangleBounds;
  if (target === null) {
    triangleBounds = new Float32Array(triCount * 6 * 4);
    offset = 0;
    count = triCount;
  } else {
    triangleBounds = target;
    offset = offset || 0;
    count = count || triCount;
  }
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = offset; tri < offset + count; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el2 = 0; el2 < 3; el2++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el2]](ai);
        b = posAttr[getters[el2]](bi);
        c = posAttr[getters[el2]](ci);
      } else {
        a = posArr[ai + el2];
        b = posArr[bi + el2];
        c = posArr[ci + el2];
      }
      let min = a;
      if (b < min) min = b;
      if (c < min) min = c;
      let max2 = a;
      if (b > max2) max2 = b;
      if (c > max2) max2 = c;
      const halfExtents = (max2 - min) / 2;
      const el22 = el2 * 2;
      triangleBounds[tri6 + el22 + 0] = min + halfExtents;
      triangleBounds[tri6 + el22 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
    }
  }
  return triangleBounds;
}

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/build/splitUtils.js
var BIN_COUNT = 32;
var binsSort = (a, b) => a.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
};

// node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t2 = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t2;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js
function IS_LEAF(n16, uint16Array2) {
  return uint16Array2[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array2) {
  return uint32Array2[n32 + 6];
}
function COUNT(n16, uint16Array2) {
  return uint16Array2[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array2) {
  return uint32Array2[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array2) {
  return uint32Array2[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/build/buildUtils.js
var float32Array;
var uint32Array;
var uint16Array;
var uint8Array;
var MAX_POINTER = Math.pow(2, 32);
function countNodes(node) {
  if ("count" in node) {
    return 1;
  } else {
    return 1 + countNodes(node.left) + countNodes(node.right);
  }
}
function populateBuffer(byteOffset, node, buffer) {
  float32Array = new Float32Array(buffer);
  uint32Array = new Uint32Array(buffer);
  uint16Array = new Uint16Array(buffer);
  uint8Array = new Uint8Array(buffer);
  return _populateBuffer(byteOffset, node);
}
function _populateBuffer(byteOffset, node) {
  const stride4Offset = byteOffset / 4;
  const stride2Offset = byteOffset / 2;
  const isLeaf = "count" in node;
  const boundingData = node.boundingData;
  for (let i = 0; i < 6; i++) {
    float32Array[stride4Offset + i] = boundingData[i];
  }
  if (isLeaf) {
    if (node.buffer) {
      const buffer = node.buffer;
      uint8Array.set(new Uint8Array(buffer), byteOffset);
      for (let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE) {
        const offset2 = offset / 2;
        if (!IS_LEAF(offset2, uint16Array)) {
          uint32Array[offset / 4 + 6] += stride4Offset;
        }
      }
      return byteOffset + buffer.byteLength;
    } else {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    }
  } else {
    const left = node.left;
    const right = node.right;
    const splitAxis = node.splitAxis;
    let nextUnusedPointer;
    nextUnusedPointer = _populateBuffer(byteOffset + BYTES_PER_NODE, left);
    if (nextUnusedPointer / 4 > MAX_POINTER) {
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    }
    uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
    nextUnusedPointer = _populateBuffer(nextUnusedPointer, right);
    uint32Array[stride4Offset + 7] = splitAxis;
    return nextUnusedPointer;
  }
}

// node_modules/three-mesh-bvh/src/core/build/buildTree.js
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, triangleBounds, offset, count, options) {
  const {
    maxDepth,
    verbose,
    maxLeafTris,
    strategy,
    onProgress,
    indirect
  } = options;
  const indirectBuffer = bvh._indirectBuffer;
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const partionFunc = indirect ? partition_indirect : partition;
  const totalTriangles = getTriCount(geometry);
  const cacheCentroidBoundingData = new Float32Array(6);
  let reachedMaxDepth = false;
  const root6 = new MeshBVHNode();
  getBounds(triangleBounds, offset, count, root6.boundingData, cacheCentroidBoundingData);
  splitNode(root6, offset, count, cacheCentroidBoundingData);
  return root6;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset2, count2, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count2 <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset2, count2, strategy);
    if (split.axis === -1) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset2, count2, split);
    if (splitOffset === offset2 || splitOffset === offset2 + count2) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset2;
      const lcount = splitOffset - offset2;
      node.left = left;
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count2 - lcount;
      node.right = right;
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  const triangleBounds = computeTriangleBounds(geometry);
  const geometryRanges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  bvh._roots = geometryRanges.map((range) => {
    const root6 = buildTree(bvh, triangleBounds, range.offset, range.count, options);
    const nodeCount = countNodes(root6);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    populateBuffer(0, root6, buffer);
    return buffer;
  });
}

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max2 = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = p[field];
      min = val < min ? val : min;
      max2 = val > max2 ? val : max2;
    }
    this.min = min;
    this.max = max2;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max2 = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max2 = val > max2 ? val : max2;
    }
    this.min = min;
    this.max = max2;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max2 = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y2 + boxMax.y * (1 - y2);
          p.z = boxMin.z * z2 + boxMax.z * (1 - z2);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max2 = Math.max(val, max2);
        }
      }
    }
    this.min = min;
    this.max = max2;
  };
}();
var areIntersecting = function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds1[i];
      const sa = satAxes1[i];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds)) return false;
    }
    for (let i = 0; i < 3; i++) {
      const sb = satBounds2[i];
      const sa = satAxes2[i];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds)) return false;
    }
  };
}();

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v22 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v22);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp14 = new Vector3();
  const temp23 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp14;
      const closestPoint2 = temp23;
      l1.closestPointToPoint(p2, true, temp14);
      l2.closestPointToPoint(p, true, temp23);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere2, triangle4) {
    const { radius, center } = sphere2;
    const { a, b, c } = triangle4;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius) return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius) return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius) return true;
    const plane = triangle4.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle4.containsPoint(pp);
      if (cp) return true;
    }
    return false;
  };
}();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere2) {
    return sphereIntersectTriangle(sphere2, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds)) return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds)) return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1) lineTarget.getCenter(target1);
        if (target2) lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(point);
        if (target2) target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(thisVec);
        if (target2) target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point);
          if (target2) target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class {
  constructor(min, max2, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min) this.min.copy(min);
    if (max2) this.max.copy(max2);
    if (matrix) this.matrix.copy(matrix);
  }
  set(min, max2, matrix) {
    this.min.copy(min);
    this.max.copy(max2);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max2 = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          const i = (1 << 0) * x | (1 << 1) * y2 | (1 << 2) * z2;
          const v4 = points[i];
          v4.x = x ? max2.x : min.x;
          v4.y = y2 ? max2.y : min.y;
          v4.z = z2 ? max2.z : min.z;
          v4.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi2 = points[index];
      axis.subVectors(minVec, pi2);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max2 = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max2.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max2.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max2.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds)) return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle4) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle4.isExtendedTriangle) {
      saTri.copy(triangle4);
      saTri.update();
      triangle4 = saTri;
    } else if (triangle4.needsUpdate) {
      triangle4.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle4.a;
    pointsArr[1] = triangle4.b;
    pointsArr[2] = triangle4.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    const triSatBounds = triangle4.satBounds;
    const triSatAxes = triangle4.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max2 = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max2);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(p);
        if (target2) target2.copy(point2);
        if (dist < threshold2) return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max2[f2];
          start[f3] = i2 ? min[f3] : max2[f2];
          end[f1] = max2[f1];
          end[f2] = i1 ? min[f2] : max2[f2];
          end[f3] = i2 ? min[f3] : max2[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          point2.x = x ? max2.x : min.x;
          point2.y = y2 ? max2.y : min.y;
          point2.z = z2 ? max2.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1) target1.copy(point1);
            if (target2) target2.copy(point2);
            if (dist < threshold2) return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point1);
          if (target2) target2.copy(point2);
          if (dist < threshold2) return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();

// node_modules/three-mesh-bvh/src/core/utils/BufferStack.js
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();

// node_modules/three-mesh-bvh/src/core/cast/shapecast.js
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box3());
function shapecast(bvh, root6, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root6]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array3);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3) + COUNT(nodeIndex162, uint16Array3);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array2);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array2);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal) return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array2);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js
var temp = new Vector3();
var temp1 = new Vector3();
function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity) return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point) target.point = temp1.clone();
  else target.point.copy(temp1);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(ray3, pA, pB, pC, point, side, near, far) {
  let intersect;
  if (side === BackSide) {
    intersect = ray3.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray3.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null) return null;
  const distance = ray3.origin.distanceTo(point);
  if (distance < near || distance > far) return null;
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray3, position2, normal, uv, uv1, a, b, c, side, near, far) {
  _vA.fromBufferAttribute(position2, a);
  _vB.fromBufferAttribute(position2, b);
  _vC.fromBufferAttribute(position2, c);
  const intersection = checkIntersection(ray3, _vA, _vB, _vC, _intersectionPoint, side, near, far);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray3.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray3, tri, intersections, near, far) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position: position2, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray3, position2, normal, uv, uv1, a, b, c, side, near, far);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections) intersections.push(intersection);
    return intersection;
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
var tempV1 = new Vector3();
var tempV2 = new Vector3();
var tempV3 = new Vector3();
var tempUV1 = new Vector2();
var tempUV2 = new Vector2();
var tempUV3 = new Vector2();

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js
function intersectTris(bvh, side, ray3, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray3, i, intersections, near, far);
  }
}
function intersectClosestTri(bvh, side, ray3, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray3, i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/refit.generated.js
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array2[node32Index + 6];
      const count = uint16Array2[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y2 = posAttr.getY(index);
        const z2 = posAttr.getZ(index);
        if (x < minx) minx = x;
        if (x > maxx) maxx = x;
        if (y2 < miny) miny = y2;
        if (y2 > maxy) maxy = y2;
        if (z2 < minz) minz = z2;
        if (z2 > maxz) maxz = z2;
      }
      if (float32Array2[node32Index + 0] !== minx || float32Array2[node32Index + 1] !== miny || float32Array2[node32Index + 2] !== minz || float32Array2[node32Index + 3] !== maxx || float32Array2[node32Index + 4] !== maxy || float32Array2[node32Index + 5] !== maxz) {
        float32Array2[node32Index + 0] = minx;
        float32Array2[node32Index + 1] = miny;
        float32Array2[node32Index + 2] = minz;
        float32Array2[node32Index + 3] = maxx;
        float32Array2[node32Index + 4] = maxy;
        float32Array2[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array2[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array2[lefti];
          const maxLeftValue = float32Array2[lefti + 3];
          const minRightValue = float32Array2[righti];
          const maxRightValue = float32Array2[righti + 3];
          float32Array2[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js
function intersectRay(nodeIndex32, array, ray3, near, far) {
  let tmin, tmax, tymin, tymax, tzmin, tzmax;
  const invdirx = 1 / ray3.direction.x, invdiry = 1 / ray3.direction.y, invdirz = 1 / ray3.direction.z;
  const ox = ray3.origin.x;
  const oy = ray3.origin.y;
  const oz = ray3.origin.z;
  let minx = array[nodeIndex32];
  let maxx = array[nodeIndex32 + 3];
  let miny = array[nodeIndex32 + 1];
  let maxy = array[nodeIndex32 + 3 + 1];
  let minz = array[nodeIndex32 + 2];
  let maxz = array[nodeIndex32 + 3 + 2];
  if (invdirx >= 0) {
    tmin = (minx - ox) * invdirx;
    tmax = (maxx - ox) * invdirx;
  } else {
    tmin = (maxx - ox) * invdirx;
    tmax = (minx - ox) * invdirx;
  }
  if (invdiry >= 0) {
    tymin = (miny - oy) * invdiry;
    tymax = (maxy - oy) * invdiry;
  } else {
    tymin = (maxy - oy) * invdiry;
    tymax = (miny - oy) * invdiry;
  }
  if (tmin > tymax || tymin > tmax) return false;
  if (tymin > tmin || isNaN(tmin)) tmin = tymin;
  if (tymax < tmax || isNaN(tmax)) tmax = tymax;
  if (invdirz >= 0) {
    tzmin = (minz - oz) * invdirz;
    tzmax = (maxz - oz) * invdirz;
  } else {
    tzmin = (maxz - oz) * invdirz;
    tzmax = (minz - oz) * invdirz;
  }
  if (tmin > tzmax || tzmin > tmax) return false;
  if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
  if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
  return tmin <= far && tmax >= near;
}

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js
function intersectTris_indirect(bvh, side, ray3, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray3, vi, intersections, near, far);
  }
}
function intersectClosestTri_indirect(bvh, side, ray3, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray3, _indirectBuffer ? _indirectBuffer[i] : i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js
function raycast(bvh, root6, side, ray3, intersects, near, far) {
  BufferStack.setBuffer(bvh._roots[root6]);
  _raycast(0, bvh, side, ray3, intersects, near, far);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray3, intersects, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris(bvh, side, ray3, offset, count, intersects, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray3, near, far)) {
      _raycast(leftIndex, bvh, side, ray3, intersects, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray3, near, far)) {
      _raycast(rightIndex, bvh, side, ray3, intersects, near, far);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js
var _xyzFields = ["x", "y", "z"];
function raycastFirst(bvh, root6, side, ray3, near, far) {
  BufferStack.setBuffer(bvh._roots[root6]);
  const result = _raycastFirst(0, bvh, side, ray3, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray3, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri(bvh, side, ray3, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray3.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray3, near, far);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray3, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray3, near, far);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray3, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js
var boundingBox = new Box3();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix4();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
function intersectsGeometry(bvh, root6, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root6]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb2);
      obb2.matrix.copy(invertedMat);
      obb2.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2, i, thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle, i, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array2[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js
var tempMatrix = new Matrix4();
var obb3 = new OrientedBox();
var obb22 = new OrientedBox();
var temp12 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp12;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb22.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb22.min.copy(box.min);
            obb22.max.copy(box.max);
            obb22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle4, 3 * i, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle4, 3 * i, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array2[node32Index + 6];
      const count = uint16Array2[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t2 = 3 * bvh.resolveTriangleIndex(i);
        for (let j2 = 0; j2 < 3; j2++) {
          let index = t2 + j2;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y2 = posAttr.getY(index);
          const z2 = posAttr.getZ(index);
          if (x < minx) minx = x;
          if (x > maxx) maxx = x;
          if (y2 < miny) miny = y2;
          if (y2 > maxy) maxy = y2;
          if (z2 < minz) minz = z2;
          if (z2 > maxz) maxz = z2;
        }
      }
      if (float32Array2[node32Index + 0] !== minx || float32Array2[node32Index + 1] !== miny || float32Array2[node32Index + 2] !== minz || float32Array2[node32Index + 3] !== maxx || float32Array2[node32Index + 4] !== maxy || float32Array2[node32Index + 5] !== maxz) {
        float32Array2[node32Index + 0] = minx;
        float32Array2[node32Index + 1] = miny;
        float32Array2[node32Index + 2] = minz;
        float32Array2[node32Index + 3] = maxx;
        float32Array2[node32Index + 4] = maxy;
        float32Array2[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array2[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array2[lefti];
          const maxLeftValue = float32Array2[lefti + 3];
          const minRightValue = float32Array2[righti];
          const maxRightValue = float32Array2[righti + 3];
          float32Array2[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js
function raycast_indirect(bvh, root6, side, ray3, intersects, near, far) {
  BufferStack.setBuffer(bvh._roots[root6]);
  _raycast2(0, bvh, side, ray3, intersects, near, far);
  BufferStack.clearBuffer();
}
function _raycast2(nodeIndex32, bvh, side, ray3, intersects, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris_indirect(bvh, side, ray3, offset, count, intersects, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray3, near, far)) {
      _raycast2(leftIndex, bvh, side, ray3, intersects, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray3, near, far)) {
      _raycast2(rightIndex, bvh, side, ray3, intersects, near, far);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js
var _xyzFields2 = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root6, side, ray3, near, far) {
  BufferStack.setBuffer(bvh._roots[root6]);
  const result = _raycastFirst2(0, bvh, side, ray3, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst2(nodeIndex32, bvh, side, ray3, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri_indirect(bvh, side, ray3, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields2[splitAxis];
    const rayDir = ray3.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray3, near, far);
    const c1Result = c1Intersection ? _raycastFirst2(c1, bvh, side, ray3, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray3, near, far);
    const c2Result = c2Intersection ? _raycastFirst2(c2, bvh, side, ray3, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js
var boundingBox2 = new Box3();
var triangle3 = new ExtendedTriangle();
var triangle22 = new ExtendedTriangle();
var invertedMat2 = new Matrix4();
var obb4 = new OrientedBox();
var obb23 = new OrientedBox();
function intersectsGeometry_indirect(bvh, root6, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root6]);
  const result = _intersectsGeometry2(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry2(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat2.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb23);
      obb23.matrix.copy(invertedMat2);
      obb23.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb23.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle22, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle22.needsUpdate = true;
            if (tri.intersectsTriangle(triangle22)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle(triangle3, 3 * ti, thisIndex, thisPos);
        triangle3.a.applyMatrix4(invertedMat2);
        triangle3.b.applyMatrix4(invertedMat2);
        triangle3.c.applyMatrix4(invertedMat2);
        triangle3.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle22, i2, index, pos);
          triangle22.needsUpdate = true;
          if (triangle3.intersectsTriangle(triangle22)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array2[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox2);
    const leftIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox2);
    const rightIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js
var tempMatrix2 = new Matrix4();
var obb5 = new OrientedBox();
var obb24 = new OrientedBox();
var temp13 = new Vector3();
var temp22 = new Vector3();
var temp32 = new Vector3();
var temp42 = new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb5.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb5.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp13;
  let tempTargetDest1 = temp22;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp32;
    tempTargetDest2 = temp42;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix2.copy(geometryToBvh).invert();
  obb24.matrix.copy(tempMatrix2);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb5.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb24.min.copy(box.min);
            obb24.max.copy(box.max);
            obb24.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb24.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle23, 3 * ti2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle4, 3 * ti, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle(triangle4, 3 * ti, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix2);
    tempTargetDest1.applyMatrix4(tempMatrix2);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/utils/BufferUtils.js
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}

// node_modules/three-mesh-bvh/src/core/cast/bvhcast.js
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box3());
var _leftBox1 = new Box3();
var _rightBox1 = new Box3();
var _leftBox2 = new Box3();
var _rightBox2 = new Box3();
var _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j2 = 0, jl = otherRoots.length; j2 < jl; j2++) {
      _bufferStack2.setBuffer(otherRoots[i]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j2].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var obb6 = new OrientedBox();
var tempBox = new Box3();
var DEFAULT_OPTIONS = {
  strategy: CENTER,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: false,
  setBoundingBox: true,
  onProgress: null,
  indirect: false,
  verbose: true
};
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root6) => root6.slice()),
        index: indexAttribute ? indexAttribute.array.slice() : null,
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute ? indexAttribute.array : null,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      ...DEFAULT_OPTIONS,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    this.resolveTriangleIndex = options.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array2 = new Uint32Array(buffer);
    const uint16Array2 = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array2[node32Index + 6];
        const count = uint16Array2[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array2[node32Index + 6];
        const splitAxis = uint32Array2[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray3, materialOrSide = FrontSide, near = 0, far = Infinity) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects.length;
      raycastFunc(this, i, materialSide, ray3, intersects, near, far);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j2 = startCount, jl = intersects.length; j2 < jl; j2++) {
          intersects[j2].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects;
  }
  raycastFirst(ray3, materialOrSide = FrontSide, near = 0, far = Infinity) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray3, near, far);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle4 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root6 = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root6.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle4);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle23 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle23, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle23, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle23.a.applyMatrix4(matrixToLocal);
          triangle23.b.applyMatrix4(matrixToLocal);
          triangle23.c.applyMatrix4(matrixToLocal);
          triangle23.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle23, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb6.set(box.min, box.max, boxToMesh);
    obb6.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb6.intersectsBox(box2),
        intersectsTriangle: (tri) => obb6.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere2) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere2.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere2)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
};

// node_modules/three-mesh-bvh/src/objects/MeshBVHHelper.js
var boundingBox3 = new Box3();

// node_modules/three-mesh-bvh/src/debug/Debug.js
var _box12 = new Box3();
var _box22 = new Box3();
var _vec = new Vector3();

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var ray2 = new Ray();
var direction = new Vector3();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
var _worldScale = new Vector3();

// node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js
function countToStringFormat(count) {
  switch (count) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function countToFormat(count) {
  switch (count) {
    case 1:
      return RedFormat;
    case 2:
      return RGFormat;
    case 3:
      return RGBAFormat;
    case 4:
      return RGBAFormat;
  }
}
function countToIntFormat(count) {
  switch (count) {
    case 1:
      return RedIntegerFormat;
    case 2:
      return RGIntegerFormat;
    case 3:
      return RGBAIntegerFormat;
    case 4:
      return RGBAIntegerFormat;
  }
}
var VertexAttributeTexture = class extends DataTexture {
  constructor() {
    super();
    this.minFilter = NearestFilter;
    this.magFilter = NearestFilter;
    this.generateMipmaps = false;
    this.overrideItemSize = null;
    this._forcedType = null;
  }
  updateFrom(attr) {
    const overrideItemSize = this.overrideItemSize;
    const originalItemSize = attr.itemSize;
    const originalCount = attr.count;
    if (overrideItemSize !== null) {
      if (originalItemSize * originalCount % overrideItemSize !== 0) {
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      }
      attr.itemSize = overrideItemSize;
      attr.count = originalCount * originalItemSize / overrideItemSize;
    }
    const itemSize = attr.itemSize;
    const count = attr.count;
    const normalized = attr.normalized;
    const originalBufferCons = attr.array.constructor;
    const byteCount = originalBufferCons.BYTES_PER_ELEMENT;
    let targetType = this._forcedType;
    let finalStride = itemSize;
    if (targetType === null) {
      switch (originalBufferCons) {
        case Float32Array:
          targetType = FloatType;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          targetType = UnsignedIntType;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          targetType = IntType;
          break;
      }
    }
    let type, format, normalizeValue, targetBufferCons;
    let internalFormat = countToStringFormat(itemSize);
    switch (targetType) {
      case FloatType:
        normalizeValue = 1;
        format = countToFormat(itemSize);
        if (normalized && byteCount === 1) {
          targetBufferCons = originalBufferCons;
          internalFormat += "8";
          if (originalBufferCons === Uint8Array) {
            type = UnsignedByteType;
          } else {
            type = ByteType;
            internalFormat += "_SNORM";
          }
        } else {
          targetBufferCons = Float32Array;
          internalFormat += "32F";
          type = FloatType;
        }
        break;
      case IntType:
        internalFormat += byteCount * 8 + "I";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Int8Array;
          type = ByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Int16Array;
          type = ShortType;
        } else {
          targetBufferCons = Int32Array;
          type = IntType;
        }
        break;
      case UnsignedIntType:
        internalFormat += byteCount * 8 + "UI";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Uint8Array;
          type = UnsignedByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Uint16Array;
          type = UnsignedShortType;
        } else {
          targetBufferCons = Uint32Array;
          type = UnsignedIntType;
        }
        break;
    }
    if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {
      finalStride = 4;
    }
    const dimension = Math.ceil(Math.sqrt(count)) || 1;
    const length = finalStride * dimension * dimension;
    const dataArray = new targetBufferCons(length);
    const originalNormalized = attr.normalized;
    attr.normalized = false;
    for (let i = 0; i < count; i++) {
      const ii = finalStride * i;
      dataArray[ii] = attr.getX(i) / normalizeValue;
      if (itemSize >= 2) {
        dataArray[ii + 1] = attr.getY(i) / normalizeValue;
      }
      if (itemSize >= 3) {
        dataArray[ii + 2] = attr.getZ(i) / normalizeValue;
        if (finalStride === 4) {
          dataArray[ii + 3] = 1;
        }
      }
      if (itemSize >= 4) {
        dataArray[ii + 3] = attr.getW(i) / normalizeValue;
      }
    }
    attr.normalized = originalNormalized;
    this.internalFormat = internalFormat;
    this.format = format;
    this.type = type;
    this.image.width = dimension;
    this.image.height = dimension;
    this.image.data = dataArray;
    this.needsUpdate = true;
    this.dispose();
    attr.itemSize = originalItemSize;
    attr.count = originalCount;
  }
};
var UIntVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = UnsignedIntType;
  }
};
var FloatVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = FloatType;
  }
};

// node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js
var MeshBVHUniformStruct = class {
  constructor() {
    this.index = new UIntVertexAttributeTexture();
    this.position = new FloatVertexAttributeTexture();
    this.bvhBounds = new DataTexture();
    this.bvhContents = new DataTexture();
    this._cachedIndexAttr = null;
    this.index.overrideItemSize = 3;
  }
  updateFrom(bvh) {
    const { geometry } = bvh;
    bvhToTextures(bvh, this.bvhBounds, this.bvhContents);
    this.position.updateFrom(geometry.attributes.position);
    if (bvh.indirect) {
      const indirectBuffer = bvh._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {
        if (geometry.index) {
          this._cachedIndexAttr = geometry.index.clone();
        } else {
          const array = getIndexArray(getVertexCount(geometry));
          this._cachedIndexAttr = new BufferAttribute(array, 1, false);
        }
      }
      dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);
      this.index.updateFrom(this._cachedIndexAttr);
    } else {
      this.index.updateFrom(geometry.index);
    }
  }
  dispose() {
    const { index, position: position2, bvhBounds, bvhContents } = this;
    if (index) index.dispose();
    if (position2) position2.dispose();
    if (bvhBounds) bvhBounds.dispose();
    if (bvhContents) bvhContents.dispose();
  }
};
function dereferenceIndex(geometry, indirectBuffer, target) {
  const unpacked = target.array;
  const indexArray = geometry.index ? geometry.index.array : null;
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    const i3 = 3 * i;
    const v32 = 3 * indirectBuffer[i];
    for (let c = 0; c < 3; c++) {
      unpacked[i3 + c] = indexArray ? indexArray[v32 + c] : v32 + c;
    }
  }
}
function bvhToTextures(bvh, boundsTexture, contentsTexture) {
  const roots = bvh._roots;
  if (roots.length !== 1) {
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  }
  const root6 = roots[0];
  const uint16Array2 = new Uint16Array(root6);
  const uint32Array2 = new Uint32Array(root6);
  const float32Array2 = new Float32Array(root6);
  const nodeCount = root6.byteLength / BYTES_PER_NODE;
  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));
  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);
  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));
  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);
  for (let i = 0; i < nodeCount; i++) {
    const nodeIndex32 = i * BYTES_PER_NODE / 4;
    const nodeIndex16 = nodeIndex32 * 2;
    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);
    for (let b = 0; b < 3; b++) {
      boundsArray[8 * i + 0 + b] = float32Array2[boundsIndex + 0 + b];
      boundsArray[8 * i + 4 + b] = float32Array2[boundsIndex + 3 + b];
    }
    if (IS_LEAF(nodeIndex16, uint16Array2)) {
      const count = COUNT(nodeIndex16, uint16Array2);
      const offset = OFFSET(nodeIndex32, uint32Array2);
      const mergedLeafCount = 4294901760 | count;
      contentsArray[i * 2 + 0] = mergedLeafCount;
      contentsArray[i * 2 + 1] = offset;
    } else {
      const rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array2) / BYTES_PER_NODE;
      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
      contentsArray[i * 2 + 0] = splitAxis;
      contentsArray[i * 2 + 1] = rightIndex;
    }
  }
  boundsTexture.image.data = boundsArray;
  boundsTexture.image.width = boundsDimension;
  boundsTexture.image.height = boundsDimension;
  boundsTexture.format = RGBAFormat;
  boundsTexture.type = FloatType;
  boundsTexture.internalFormat = "RGBA32F";
  boundsTexture.minFilter = NearestFilter;
  boundsTexture.magFilter = NearestFilter;
  boundsTexture.generateMipmaps = false;
  boundsTexture.needsUpdate = true;
  boundsTexture.dispose();
  contentsTexture.image.data = contentsArray;
  contentsTexture.image.width = contentsDimension;
  contentsTexture.image.height = contentsDimension;
  contentsTexture.format = RGIntegerFormat;
  contentsTexture.type = UnsignedIntType;
  contentsTexture.internalFormat = "RG32UI";
  contentsTexture.minFilter = NearestFilter;
  contentsTexture.magFilter = NearestFilter;
  contentsTexture.generateMipmaps = false;
  contentsTexture.needsUpdate = true;
  contentsTexture.dispose();
}

// node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js
var _positionVector = new Vector3();
var _normalVector = new Vector3();
var _tangentVector = new Vector3();
var _tangentVector4 = new Vector4();
var _morphVector = new Vector3();
var _temp = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _matrix = new Matrix4();
var _boneMatrix = new Matrix4();

// node_modules/three-mesh-bvh/src/gpu/BVHShaderGLSL.js
var BVHShaderGLSL_exports = {};
__export(BVHShaderGLSL_exports, {
  bvh_distance_functions: () => bvh_distance_functions,
  bvh_ray_functions: () => bvh_ray_functions,
  bvh_struct_definitions: () => bvh_struct_definitions,
  common_functions: () => common_functions
});

// node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js
var common_functions = (
  /* glsl */
  `

// A stack of uint32 indices can can store the indices for
// a perfectly balanced tree with a depth up to 31. Lower stack
// depth gets higher performance.
//
// However not all trees are balanced. Best value to set this to
// is the trees max depth.
#ifndef BVH_STACK_DEPTH
#define BVH_STACK_DEPTH 60
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}
`
);

// node_modules/three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js
var bvh_distance_functions = (
  /* glsl */
  `

float dot2( vec3 v ) {

	return dot( v, v );

}

// https://www.shadertoy.com/view/ttfGWl
vec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {

    vec3 v10 = v1 - v0;
    vec3 v21 = v2 - v1;
    vec3 v02 = v0 - v2;

	vec3 p0 = p - v0;
	vec3 p1 = p - v1;
	vec3 p2 = p - v2;

    vec3 nor = cross( v10, v02 );

    // method 2, in barycentric space
    vec3  q = cross( nor, p0 );
    float d = 1.0 / dot2( nor );
    float u = d * dot( q, v02 );
    float v = d * dot( q, v10 );
    float w = 1.0 - u - v;

	if( u < 0.0 ) {

		w = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );
		u = 0.0;
		v = 1.0 - w;

	} else if( v < 0.0 ) {

		u = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );
		v = 0.0;
		w = 1.0 - u;

	} else if( w < 0.0 ) {

		v = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );
		w = 0.0;
		u = 1.0-v;

	}

	barycoord = vec3( u, v, w );
    return u * v1 + v * v2 + w * v0;

}

float distanceToTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// point and cut off range
	vec3 point, float closestDistanceSquared,

	// outputs
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint
) {

	bool found = false;
	vec3 localBarycoord;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		// get the closest point and barycoord
		vec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );
		vec3 delta = point - closestPoint;
		float sqDist = dot2( delta );
		if ( sqDist < closestDistanceSquared ) {

			// set the output results
			closestDistanceSquared = sqDist;
			faceIndices = uvec4( indices.xyz, i );
			faceNormal = normalize( cross( a - b, b - c ) );
			barycoord = localBarycoord;
			outPoint = closestPoint;
			side = sign( dot( faceNormal, delta ) );

		}

	}

	return closestDistanceSquared;

}

float distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {

	vec3 clampedPoint = clamp( point, boundsMin, boundsMax );
	vec3 delta = point - clampedPoint;
	return dot( delta, delta );

}

float distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return distanceSqToBounds( point, boundsMin, boundsMax );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhClosestPointToPoint(		bvh,		point, faceIndices, faceNormal, barycoord, side, outPoint	)	_bvhClosestPointToPoint(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		point, faceIndices, faceNormal, barycoord, side, outPoint	)

float _bvhClosestPointToPoint(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// point to check
	vec3 point,

	// output variables
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout vec3 outPoint
 ) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float closestDistanceSquared = pow( 100000.0, 2.0 );
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );
		if ( boundsHitDistance > closestDistanceSquared ) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );
		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;
			closestDistanceSquared = distanceToTriangles(
				bvh_position, bvh_index, offset, count, point, closestDistanceSquared,

				// outputs
				faceIndices, faceNormal, barycoord, side, outPoint
			);

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;
			bool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;
			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return sqrt( closestDistanceSquared );

}
`
);

// node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js
var bvh_ray_functions = (
  /* glsl */
  `

#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

// Raycasting
bool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	dist = max( t0, 0.0 );

	return t1 >= dist;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// outputs
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

bool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhIntersectFirstHit(		bvh,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)	_bvhIntersectFirstHit(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)

bool _bvhIntersectFirstHit(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// output variables split into separate variables due to output precision
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float triangleDistance = INFINITY;
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance;
		if (
			! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )
			|| boundsHitDistance > triangleDistance
		) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh_position, bvh_index, offset, count,
				rayOrigin, rayDirection, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
);

// node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js
var bvh_struct_definitions = (
  /* glsl */
  `
struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
);

// node_modules/three-mesh-bvh/src/index.js
var shaderStructs = bvh_struct_definitions;
var shaderIntersectFunction = `
	${common_functions}
	${bvh_ray_functions}
`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/fragment.js
var fragmentShader6 = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${shaderStructs}
${shaderIntersectFunction}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/vertex.js
var vertexShader6 = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte
mark_module_start();
MeshRefractionMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte";
function MeshRefractionMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshRefractionMaterial);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  let bounces = prop($$props, "bounces", 3, 2), ior = prop($$props, "ior", 3, 2.4), fresnel = prop($$props, "fresnel", 3, 0), aberrationStrength = prop($$props, "aberrationStrength", 3, 0), color2 = prop($$props, "color", 3, "white"), fastChroma = prop($$props, "fastChroma", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "envMap",
      "bounces",
      "ior",
      "fresnel",
      "aberrationStrength",
      "color",
      "fastChroma",
      "ref"
    ],
    "props"
  );
  const uniforms = {
    envMap: { value: null },
    bounces: { value: 2 },
    ior: { value: 2.4 },
    correctMips: { value: true },
    aberrationStrength: { value: 0.01 },
    fresnel: { value: 0 },
    bvh: { value: new MeshBVHUniformStruct() },
    color: { value: new Color("white") },
    resolution: { value: new Vector2() },
    viewMatrixInverse: { value: new Matrix4() },
    projectionMatrixInverse: { value: new Matrix4() }
  };
  const material = new ShaderMaterial({ fragmentShader: fragmentShader6, vertexShader: vertexShader6, uniforms });
  const { size, invalidate, camera } = useThrelte();
  const parent = useParent();
  let defines = {};
  const updateDefines = (envMap, aberrationStrength2, fastChroma2) => {
    var _a2;
    const isCubeMap = isInstanceOf(envMap, "CubeTexture");
    const w = (isCubeMap ? (_a2 = envMap.image[0]) == null ? void 0 : _a2.width : envMap == null ? void 0 : envMap.image.width) ?? 1024;
    const cubeSize = w / 4;
    const lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, lodMax);
    const width = 3 * Math.max(_cubeSize, 16 * 7);
    const height = 4 * _cubeSize;
    if (isCubeMap) defines.ENVMAP_TYPE_CUBEM = "";
    defines.CUBEUV_TEXEL_WIDTH = `${1 / width}`;
    defines.CUBEUV_TEXEL_HEIGHT = `${1 / height}`;
    defines.CUBEUV_MAX_MIP = `${lodMax}.0`;
    if (aberrationStrength2 > 0) defines.CHROMATIC_ABERRATIONS = "";
    if (fastChroma2) defines.FAST_CHROMA = "";
  };
  user_pre_effect(() => {
    updateDefines($$props.envMap, aberrationStrength(), fastChroma());
  });
  onMount(() => {
    var _a2;
    if ($parent() && $parent() instanceof Mesh && $parent().geometry) {
      uniforms.bvh.value = new MeshBVHUniformStruct();
      uniforms.bvh.value.updateFrom(new MeshBVH((_a2 = $parent()) == null ? void 0 : _a2.geometry.clone().toNonIndexed(), { strategy: SAH }));
    }
  });
  useTask(
    () => {
      uniforms.viewMatrixInverse.value = camera.current.matrixWorld;
      uniforms.projectionMatrixInverse.value = camera.current.projectionMatrixInverse;
    },
    { autoInvalidate: false }
  );
  const colorObj = new Color(color2());
  user_pre_effect(() => {
    colorObj.set(color2());
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  var uniforms_resolution_value = derived(() => [$size().width, $size().height]);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: material,
        get "uniforms.envMap.value"() {
          return $$props.envMap;
        },
        get "uniforms.bounces.value"() {
          return bounces();
        },
        get "uniforms.ior.value"() {
          return ior();
        },
        get "uniforms.fresnel.value"() {
          return fresnel();
        },
        get "uniforms.aberrationStrength.value"() {
          return aberrationStrength();
        },
        "uniforms.color.value": colorObj,
        get "uniforms.resolution.value"() {
          return get(uniforms_resolution_value);
        },
        defines
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      }
    ));
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MeshRefractionMaterial = hmr(MeshRefractionMaterial, () => MeshRefractionMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshRefractionMaterial[HMR].source;
    set(MeshRefractionMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshRefractionMaterial_default = MeshRefractionMaterial;
mark_module_end(MeshRefractionMaterial);

// node_modules/three/examples/jsm/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, parameters.size);
      if (parameters.depth === void 0 && parameters.height !== void 0) {
        console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead");
      }
      parameters.depth = parameters.depth !== void 0 ? parameters.depth : parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
      super(shapes, parameters);
    }
    this.type = "TextGeometry";
  }
};

// node_modules/three/examples/jsm/loaders/FontLoader.js
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad2, onProgress, onError2) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      const font = scope.parse(JSON.parse(text));
      if (onLoad2) onLoad2(font);
    }, onProgress, onError2);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    this.isFont = true;
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      shapes.push(...paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y2, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action2 = outline[i++];
      switch (action2) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y2 = outline[i++] * scale + offsetY;
          path.moveTo(x, y2);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y2 = outline[i++] * scale + offsetY;
          path.lineTo(x, y2);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}

// node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte
mark_module_start();
Text3DGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte";
function Text3DGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text3DGeometry);
  const [$$stores, $$cleanup] = setup_stores();
  const $loadedFont = () => (validate_store(get(loadedFont), "loadedFont"), store_get(get(loadedFont), "$loadedFont", $$stores));
  let font = prop($$props, "font", 3, "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "text",
      "font",
      "size",
      "depth",
      "curveSegments",
      "bevelEnabled",
      "bevelThickness",
      "bevelSize",
      "bevelOffset",
      "bevelSegments",
      "smooth",
      "extrudePath",
      "steps",
      "UVGenerator",
      "ref",
      "children"
    ],
    "props"
  );
  const suspend = useSuspense();
  let loadedFont = derived(() => suspend(strict_equals(typeof font(), "string") ? useLoader(FontLoader).load(font()) : asyncWritable(new Promise((resolve) => resolve(font())))));
  let baseGeometry = derived(() => {
    if (!$loadedFont()) return;
    return new TextGeometry($$props.text, {
      font: $loadedFont(),
      size: $$props.size,
      depth: $$props.depth,
      curveSegments: $$props.curveSegments,
      bevelEnabled: $$props.bevelEnabled,
      bevelThickness: $$props.bevelThickness,
      bevelSize: $$props.bevelSize,
      bevelOffset: $$props.bevelOffset,
      bevelSegments: $$props.bevelSegments,
      extrudePath: $$props.extrudePath,
      steps: $$props.steps,
      UVGenerator: $$props.UVGenerator
    });
  });
  let creasedGeometry = derived(() => {
    if (!get(baseGeometry)) return;
    if (strict_equals($$props.smooth, 0)) return get(baseGeometry);
    return toCreasedNormals(get(baseGeometry), $$props.smooth);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, spread_props(
          {
            get is() {
              return get(creasedGeometry);
            }
          },
          () => props,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            },
            children: wrap_snippet(Text3DGeometry, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              snippet(node_2, () => $$props.children ?? noop, () => ({ ref: get(creasedGeometry) }));
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }
        ));
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (get(creasedGeometry)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Text3DGeometry = hmr(Text3DGeometry, () => Text3DGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text3DGeometry[HMR].source;
    set(Text3DGeometry[HMR].source, module.default[HMR].original);
  });
}
var Text3DGeometry_default = Text3DGeometry;
mark_module_end(Text3DGeometry);

// node_modules/three-perf/dist/ThreePerf.mjs
var import_tweakpane = __toESM(require_tweakpane(), 1);

// node_modules/three-perf/node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0) dependencies = [];
    var init2 = ref.init;
    if (init2 === void 0) init2 = function() {
    };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0) getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init2 = rehydrate("<" + name + ">.init", init2);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init2 === "function") {
        value = init2.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err2) {
      if (!(err2 && err2.noLog)) {
        console.error(err2);
      }
      callback(err2);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err2) {
      callback(err2);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err2) {
        console.error(err2);
        callback(err2);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err2) {
      console.error(err2);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action2 = ref.action;
    var data = ref.data;
    try {
      if (action2 === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action2 === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err2) {
      postMessage({
        messageId,
        success: false,
        error: err2.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init2 = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(function(dep) {
      if (dep) {
        dep = dep.onMainThread || dep;
        if (dep._getInitResult) {
          dep = dep._getInitResult();
        }
      }
      return dep;
    }) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init2.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err2) {
      if (typeof process !== "undefined" && false) ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err2.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init2 = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  var onMainThread = defineMainThreadModule(options);
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (!supportsWorkers()) {
      return onMainThread.apply(void 0, args);
    }
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init2),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  moduleFunc.onMainThread = onMainThread;
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action2, data) {
  return new Promise(function(resolve, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function(response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action2 + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId,
      action: action2,
      data
    });
  });
}

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports = function(exports2) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2;
      pointOut.y = t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
      pointOut.y = t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v4) {
          return parseFloat(v4);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0) curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i = 1; i < curvePoints; i++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func2) {
                gl.useProgram(program);
                func2({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0) values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }, withTexture = function(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x, y2, width, height, channels, framebuffer) {
      if (channels === void 0) channels = 15;
      if (framebuffer === void 0) framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x, y2, width, height);
            gl.scissor(x, y2, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing3(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing3
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0) sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a, b) {
        return a.maxX - b.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x, y2) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX + closestDist <= x) {
            break;
          }
          if (x + closestDist > seg.minX && y2 - closestDist < seg.maxY && y2 + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x, y2, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x, y2)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x, y2) {
        var winding = 0;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX <= x) {
            break;
          }
          var intersects = seg.y1 > y2 !== seg.y2 > y2 && x < (seg.x2 - seg.x1) * (y2 - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y2, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i = 0; i < data.length; i++) {
        rgbaData[i * 4 + channel] = data[i];
      }
      renderImageData(glOrCanvas, rgbaData, x, y2, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x, y2, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t2 = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y2 - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x - (lineX0 + t2 * ldx);
      var dy = y2 - (lineY0 + t2 * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (glOrCanvas === void 0) glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i = 0, j2 = 0; i < rgbaData.length; i += 4) {
        data[j2++] = rgbaData[i];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y2, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x2, y22) {
        lineSegmentCoords.push(x1, y1, x2, y22);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x, y2, sdfWidth, sdfHeight);
            gl.scissor(x, y2, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key2 = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key2);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i) {
            return val === expectedResult[i];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err2) {
          supported = false;
          failReason = err2.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key2, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports2.forEachPathCommand = forEachPathCommand;
    exports2.generate = generate;
    exports2.generateIntoCanvas = generateIntoCanvas;
    exports2.javascript = javascript;
    exports2.pathToLineSegments = pathToLineSegments;
    exports2.webgl = webgl;
    exports2.webglUtils = webglUtils;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  }({});
  return exports;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i) {
      TYPES[type] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i = +entry; i--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a = ref[0];
          var b = ref[1];
          a = String.fromCodePoint(lastCode += parseInt(a, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a, b);
          includeReverse && reverseMap.set(b, a);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i2, type2) {
        var oldType = charTypes[i2];
        charTypes[i2] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n2) {
        return n2 + (n2 & 1 ? 1 : 2);
      };
      var nextOdd = function(n2) {
        return n2 + (n2 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j2 = run$1._start; j2 <= run$1._end; j2++) {
                seqIndices.push(j2);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a, b) {
                return a[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        for (var i2 = start; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i2);
            i2 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i2 = isolateStart + 1; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i2;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key2) {
          map2.set(key2, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map2 = /* @__PURE__ */ new Map();
      for (var i = start; i <= end; i++) {
        if (embeddingLevels[i] & 1) {
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map2.set(i, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end);
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      segments.forEach(function(ref) {
        var start2 = ref[0];
        var end2 = ref[1];
        var slice = indices.slice(start2, end2 + 1);
        for (var i2 = slice.length; i2--; ) {
          indices[end2 - i2] = slice[i2];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop2)) {
          target[prop2] = source[prop2];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived3 = Object.create(base, descriptor);
    Object.defineProperty(derived3, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived3, "id", { value: materialInstanceId++ });
    derived3.uuid = generateUUID();
    derived3.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived3.defines = assign2({}, base.defines, options.defines);
    derived3.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived3.extensions = assign2({}, base.extensions, options.extensions);
    derived3._listeners = void 0;
    return derived3;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    type: {
      get: () => baseMaterial.type,
      set: (value) => {
        baseMaterial.type = value;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(testMaterial) {
        const base = this.baseMaterial;
        return testMaterial === base || base.isDerivedMaterial && base.isDerivedFrom(testMaterial) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material, { vertexShader: vertexShader9, fragmentShader: fragmentShader9 }, options, key2) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader9 = expandShaderIncludes(vertexShader9);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader9 = fragmentShader9.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader9 = expandShaderIncludes(fragmentShader9);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader: vertexShader9, fragmentShader: fragmentShader9 });
    vertexShader9 = res.vertexShader;
    fragmentShader9 = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader9 = fragmentShader9.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader9 = `vec3 troika_position_${key2};
vec3 troika_normal_${key2};
vec2 troika_uv_${key2};
${vertexShader9}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key2}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key2} = vec3(position);
troika_normal_${key2} = vec3(normal);
troika_uv_${key2} = vec2(uv);
troikaVertexTransform${key2}(troika_position_${key2}, troika_normal_${key2}, troika_uv_${key2});
${vertexMainIntro}
`;
    vertexShader9 = vertexShader9.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key2}`;
    });
    if (!(material.map && material.map.channel > 0)) {
      vertexShader9 = vertexShader9.replace(/\bMAP_UV\b/g, `troika_uv_${key2}`);
    }
  }
  vertexShader9 = injectIntoShaderCode(vertexShader9, key2, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader9 = injectIntoShaderCode(fragmentShader9, key2, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader: vertexShader9,
    fragmentShader: fragmentShader9
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key2, value) {
  return key2 === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/three-perf/node_modules/troika-three-text/dist/troika-three-text.esm.js
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a2, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a2, n2), n2 += 2, t3.readUshort(a2, n2), n2 += 2;
        var o = t3.readUint(a2, n2);
        n2 += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t3.readUint(a2, n2);
          n2 += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t3) {
      var a2 = e._bin, n2 = t3;
      a2.readFixed(r2, t3), t3 += 4;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n2 }, h = {}, d = 0; d < o; d++) {
        var f = a2.readASCII(r2, t3, 4);
        t3 += 4, a2.readUint(r2, t3), t3 += 4;
        var u2 = a2.readUint(r2, t3);
        t3 += 4;
        var l = a2.readUint(r2, t3);
        t3 += 4, h[f] = { offset: u2, length: l };
      }
      for (d = 0; d < s.length; d++) {
        var v4 = s[d];
        h[v4] && (i[v4.trim()] = e[v4.trim()].parse(r2, h[v4].offset, h[v4].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t3, a2) {
      for (var n2 = e._bin, o = n2.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n2.readASCII(r2, s, 4);
        s += 4, n2.readUint(r2, s), s += 4;
        var d = n2.readUint(r2, s);
        if (s += 4, n2.readUint(r2, s), s += 4, h == t3) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a2) {
      for (var n2 = [], o = 0; o < a2; o++) n2.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n2;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) a2 += String.fromCharCode(r2[e2 + n2]);
      return a2;
    }, readUnicode: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a2) {
      var n2 = e._bin._tdec;
      return n2 && 0 == t3 && a2 == r2.length ? n2.decode(r2) : e._bin.readASCII(r2, t3, a2);
    }, readBytes: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(r2[e2 + n2]);
      return a2;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(String.fromCharCode(r2[e2 + n2]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a2, n2, o) {
      var s = e._bin, i = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var u2 = s.readUshort(r2, t3);
      return t3 += 2, i.scriptList = e._lctf.readScriptList(r2, h + d), i.featureList = e._lctf.readFeatureList(r2, h + f), i.lookupList = e._lctf.readLookupList(r2, h + u2, o), i;
    }, e._lctf.readLookupList = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = [], i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readLookupTable(r2, o + d, a2);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r2, t3), t3 += 2, s.flag = n2.readUshort(r2, t3), t3 += 2;
      var i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = a2(r2, h, o + f, s);
        s.tabs.push(u2);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++) 0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = a2.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a2.readUshort(r2, t3);
        t3 += 2;
        var i = a2.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i; h++) n2.push(s + h), n2.push(s + h), n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < d; h++) n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      return n2;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a2 = r2[t3], n2 = r2[t3 + 1];
        if (r2[t3 + 2], a2 <= e2 && e2 <= n2) return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.fmt = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, o)), 2 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, 3 * o)), n2;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a2 = r2.tab;
      if (1 == r2.fmt) return a2.indexOf(t3);
      if (2 == r2.fmt) {
        var n2 = e._lctf.getInterval(a2, t3);
        if (-1 != n2) return a2[n2 + 2] + (t3 - a2[n2]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readFeatureTable(r2, n2 + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a2.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n2 + d);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r2, n2 + s));
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2, o[d.trim()] = e._lctf.readLangSysTable(r2, n2 + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      a2.readUshort(r2, t3), t3 += 2, n2.reqFeature = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, n2.features = a2.readUshorts(r2, t3, o), n2;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a2) {
      var n2 = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a2))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n2.readASCII(r2, t3 + o[i], o[i + 1] - o[i]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r2, t3 + h[i], t3 + h[i + 1]));
      t3 += h[h.length - 1];
      var f = d[0], u2 = [];
      t3 = e.CFF.readIndex(r2, t3, u2);
      var l = [];
      for (i = 0; i < u2.length - 1; i++) l.push(n2.readASCII(r2, t3 + u2[i], u2[i + 1] - u2[i]));
      if (t3 += u2[u2.length - 1], e.CFF.readSubrs(r2, t3, f), f.CharStrings) {
        t3 = f.CharStrings;
        u2 = [];
        t3 = e.CFF.readIndex(r2, t3, u2);
        var v4 = [];
        for (i = 0; i < u2.length - 1; i++) v4.push(n2.readBytes(r2, t3 + u2[i], u2[i + 1] - u2[i]));
        f.CharStrings = v4;
      }
      if (f.ROS) {
        t3 = f.FDArray;
        var c = [];
        t3 = e.CFF.readIndex(r2, t3, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r2, t3 + c[i], t3 + c[i + 1]);
          e.CFF._readFDict(r2, p, l), f.FDArray.push(p);
        }
        t3 += c[c.length - 1], t3 = f.FDSelect, f.FDSelect = [];
        var U2 = r2[t3];
        if (t3++, 3 != U2) throw U2;
        var g4 = n2.readUshort(r2, t3);
        t3 += 2;
        for (i = 0; i < g4 + 1; i++) f.FDSelect.push(n2.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r2, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r2, f.charset, f.CharStrings.length)), e.CFF._readFDict(r2, f, l), f;
    }, e.CFF._readFDict = function(r2, t3, a2) {
      var n2;
      for (var o in t3.Private && (n2 = t3.Private[1], t3.Private = e.CFF.readDict(r2, n2, n2 + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n2 + t3.Private.Subrs, t3.Private)), t3) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a2[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a2.Subrs.push(n2.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++) if (r2.charset[t3] == e2) return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a2) {
      e._bin;
      var n2 = [".notdef"], o = r2[t3];
      if (t3++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i = 0; i < s; i++) n2.push(r2[t3 + i]);
      return n2;
    }, e.CFF.readCharset = function(r2, t3, a2) {
      var n2 = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s) for (var i = 0; i < a2; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2, o.push(h);
      }
      else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n2.readUshort(r2, t3);
          t3 += 2;
          var d = 0;
          1 == s ? (d = r2[t3], t3++) : (d = n2.readUshort(r2, t3), t3 += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a2) {
      var n2 = e._bin, o = n2.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s) for (var i = 0; i < o; i++) a2.push(r2[t3 + i]);
      else if (2 == s) for (i = 0; i < o; i++) a2.push(n2.readUshort(r2, t3 + 2 * i));
      else if (3 == s) for (i = 0; i < o; i++) a2.push(16777215 & n2.readUint(r2, t3 + 3 * i - 1));
      else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a2) {
      var n2 = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i = 1, h = null, d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n2.readShort(r2, t3 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n2.readInt(r2, t3 + 1) / 65535, i = 5), a2.val = null != d ? d : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t3, a2) {
      for (var n2 = t3 + a2, o = e._bin, s = []; t3 < n2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u2 = o.readShort(r2, t3 + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u2 = o.readInt(r2, t3 + 1) / 65535, d = 5), s.push(null != u2 ? u2 : "o" + f), t3 += d;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a2) {
      for (var n2 = e._bin, o = {}, s = []; t3 < a2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        if (28 == i && (u2 = n2.readShort(r2, t3 + 1), d = 3), 29 == i && (u2 = n2.readInt(r2, t3 + 1), d = 5), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u2 = n2.readInt(r2, t3 + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1; ; ) {
            var v4 = r2[t3 + d];
            d++;
            var c = v4 >> 4, p = 15 & v4;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U2 = "", g4 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U2 += g4[l[S]];
          u2 = parseFloat(U2);
        }
        if (i <= 21) {
          if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        }
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u2), t3 += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a2) {
      r2 = new Uint8Array(r2.buffer, t3, a2), t3 = 0;
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = n2.readUint(r2, t3);
        t3 += 4;
        var l = "p" + d + "e" + f, v4 = i.indexOf(u2);
        if (-1 == v4) {
          var c;
          v4 = o.tables.length, i.push(u2);
          var p = n2.readUshort(r2, u2);
          0 == p ? c = e.cmap.parse0(r2, u2) : 4 == p ? c = e.cmap.parse4(r2, u2) : 6 == p ? c = e.cmap.parse6(r2, u2) : 12 == p ? c = e.cmap.parse12(r2, u2) : console.debug("unknown format: " + p, d, f, u2), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v4;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o - 6; s++) n2.map.push(r2[t3 + s]);
      return n2;
    }, e.cmap.parse4 = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {};
      o.format = a2.readUshort(r2, t3), t3 += 2;
      var s = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t3), t3 += 2, o.entrySelector = a2.readUshort(r2, t3), t3 += 2, o.rangeShift = a2.readUshort(r2, t3), t3 += 2, o.endCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a2.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n2 + s; ) o.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.firstCode = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o; s++) n2.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.cmap.parse12 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, t3 += 2, a2.readUint(r2, t3), t3 += 4, a2.readUint(r2, t3), t3 += 4;
      var o = a2.readUint(r2, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t3 + 12 * s, h = a2.readUint(r2, i + 0), d = a2.readUint(r2, i + 4), f = a2.readUint(r2, i + 8);
        n2.groups.push([h, d, f]);
      }
      return n2;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a2) {
      for (var n2 = [], o = 0; o < a2.maxp.numGlyphs; o++) n2.push(null);
      return n2;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a2 = e._bin, n2 = r2._data, o = e._tabOffset(n2, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1]) return null;
      var s = {};
      if (s.noc = a2.readShort(n2, o), o += 2, s.xMin = a2.readShort(n2, o), o += 2, s.yMin = a2.readShort(n2, o), o += 2, s.xMax = a2.readShort(n2, o), o += 2, s.yMax = a2.readShort(n2, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a2.readUshort(n2, o)), o += 2;
        var h = a2.readUshort(n2, o);
        if (o += 2, n2.length - o < h) return null;
        s.instructions = a2.readBytes(n2, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n2[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u2 = n2[o];
            o++;
            for (var l = 0; l < u2; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v4 = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v4 ? (s.xs.push(c ? n2[o] : -n2[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n2, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v4 = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v4 ? (s.ys.push(c ? n2[o] : -n2[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n2, o)), o += 2);
        }
        var p = 0, U2 = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U2 += s.ys[i], s.xs[i] = p, s.ys[i] = U2;
      } else {
        var g4;
        s.parts = [];
        do {
          g4 = a2.readUshort(n2, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n2, o), o += 2, 1 & g4) {
            var m = a2.readShort(n2, o);
            o += 2;
            var b = a2.readShort(n2, o);
            o += 2;
          } else {
            m = a2.readInt8(n2, o);
            o++;
            b = a2.readInt8(n2, o);
            o++;
          }
          2 & g4 ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g4 ? (S.m.a = S.m.d = a2.readF2dot14(n2, o), o += 2) : 64 & g4 ? (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2) : 128 & g4 && (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.b = a2.readF2dot14(n2, o), o += 2, S.m.c = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2);
        } while (32 & g4);
        if (256 & g4) {
          var y2 = a2.readUshort(n2, o);
          o += 2, s.instr = [];
          for (i = 0; i < y2; i++) s.instr.push(n2[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function(r2, t3, a2, n2) {
      var o = t3;
      t3 += 4;
      var s = e._bin.readUshort(r2, t3);
      return { glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r2, o + s) };
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i.fmt) {
        var d = o.readUshort(r2, a2);
        a2 += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r2, a2, d));
      } else if (2 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r2, a2);
        a2 += 2;
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var u2 = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v4 = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v4; c++) {
            var p = s + o.readUshort(r2, a2);
            a2 += 2;
            var U2 = o.readUshort(r2, p);
            p += 2;
            for (var g4 = [], S = 0; S < U2; S++) {
              var m = o.readUshort(r2, p);
              p += 2, 0 != d && (P2 = e.GPOS.readValueRecord(r2, p, d), p += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * l), g4.push({ gid2: m, val1: P2, val2: x });
            }
            i.pairsets.push(g4);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y2 = o.readUshort(r2, a2);
          a2 += 2;
          var F3 = o.readUshort(r2, a2);
          a2 += 2;
          var C3 = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y2), i.matrix = [];
          for (c = 0; c < F3; c++) {
            var _ = [];
            for (S = 0; S < C3; S++) {
              var P2 = null, x = null;
              0 != d && (P2 = e.GPOS.readValueRecord(r2, a2, d), a2 += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * l), _.push({ val1: P2, val2: x });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t3 && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.baseCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.markArray = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.baseArray = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else if (6 == t3 && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.mark2Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.mark1Array = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else {
        if (9 == t3 && 1 == i.fmt) {
          var I4 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = I4;
          else if (n2.ltype != I4) throw "invalid extension substitution";
          return e.GPOS.subt(r2, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      return o.push(1 & a2 ? n2.readShort(r2, t3) : 0), t3 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n2.readShort(r2, t3) : 0), t3 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n2.readShort(r2, t3) : 0), t3 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n2.readShort(r2, t3) : 0), t3 += 8 & a2 ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function(r2, t3, a2) {
      var n2 = e._bin, o = [], s = t3, i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a2; f++) d.push(e.GPOS.readAnchorRecord(r2, s + n2.readUshort(r2, t3))), t3 += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = t3, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r2, a2.readUshort(r2, t3 + 2) + o);
        h.markClass = a2.readUshort(r2, t3), n2.push(h), t3 += 4;
      }
      return n2;
    }, e.GPOS.readAnchorRecord = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      return n2.fmt = a2.readUshort(r2, t3), n2.x = a2.readShort(r2, t3 + 2), n2.y = a2.readShort(r2, t3 + 4), n2;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t3 && 2 != t3 && 4 != t3 && 5 != t3 && 6 != t3) return null;
      if (1 == t3 || 2 == t3 || 4 == t3 || 5 == t3 && i.fmt <= 2 || 6 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var d = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, d), a2 += 2 * i.newg.length;
        }
      } else if (2 == t3 && 1 == i.fmt) {
        d = o.readUshort(r2, a2);
        a2 += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u2 = o.readUshort(r2, a2) + s;
          a2 += 2;
          var l = o.readUshort(r2, u2);
          i.seqs.push(o.readUshorts(r2, u2 + 2, l));
        }
      } else if (4 == t3) {
        i.vals = [];
        d = o.readUshort(r2, a2);
        a2 += 2;
        for (f = 0; f < d; f++) {
          var v4 = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + v4));
        }
      } else if (5 == t3 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + c), i.scset = [];
          var p = o.readUshort(r2, a2);
          a2 += 2;
          for (f = 0; f < p; f++) {
            var U2 = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == U2 ? null : e.GSUB.readSubClassSet(r2, s + U2));
          }
        }
      } else if (6 == t3 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r2, a2);
            a2 += 2;
            for (var g4 = [], S = 0; S < d; S++) g4.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * S)));
            a2 += 2 * d, 0 == f && (i.backCvg = g4), 1 == f && (i.inptCvg = g4), 2 == f && (i.ahedCvg = g4);
          }
          d = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, d);
        }
      } else {
        if (7 == t3 && 1 == i.fmt) {
          var m = o.readUshort(r2, a2);
          a2 += 2;
          var b = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = m;
          else if (n2.ltype != m) throw "invalid extension substitution";
          return e.GSUB.subt(r2, n2.ltype, s + b);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = t3, o = [], s = a2(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = {}, o = a2(r2, t3), s = a2(r2, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i = 0; i < o - 1; i++) n2.input.push(a2(r2, t3)), t3 += 2;
      return n2.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n2;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a2) {
      for (var n2 = e._bin.readUshort, o = [], s = 0; s < a2; s++) o.push(n2(r2, t3), n2(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a2 = e._bin, n2 = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t3);
        t3 += 2, 1 == s && i--, n2[o[s]] = a2.readUshorts(r2, t3, i), t3 += 2 * n2[o[s]].length;
      }
      i = a2.readUshort(r2, t3);
      return t3 += 2, n2.subst = a2.readUshorts(r2, t3, 2 * i), t3 += 2 * n2.subst.length, n2;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a2 = e._bin, n2 = { chain: [] };
      n2.nglyph = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++) n2.chain.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.head = {}, e.head.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.fontRevision = n2.readFixed(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, o.flags = n2.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n2.readUshort(r2, t3), t3 += 2, o.created = n2.readUint64(r2, t3), t3 += 8, o.modified = n2.readUint64(r2, t3), t3 += 8, o.xMin = n2.readShort(r2, t3), t3 += 2, o.yMin = n2.readShort(r2, t3), t3 += 2, o.xMax = n2.readShort(r2, t3), t3 += 2, o.yMax = n2.readShort(r2, t3), t3 += 2, o.macStyle = n2.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n2.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n2.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n2.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n2.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.ascender = n2.readShort(r2, t3), t3 += 2, o.descender = n2.readShort(r2, t3), t3 += 2, o.lineGap = n2.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n2.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n2.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n2.readShort(r2, t3), t3 += 2, o.xMaxExtent = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n2.readShort(r2, t3), t3 += 2, o.caretOffset = n2.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n2.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n2.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a2, n2) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, d = 0; d < n2.maxp.numGlyphs; d++) d < n2.hhea.numberOfHMetrics && (i = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s) return e.kern.parseV1(r2, t3 - 2, a2, n2);
      var i = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < i; d++) {
        t3 += 2;
        a2 = o.readUshort(r2, t3);
        t3 += 2;
        var f = o.readUshort(r2, t3);
        t3 += 2;
        var u2 = f >>> 8;
        if (0 != (u2 &= 15)) throw "unknown kern table format: " + u2;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a2, n2) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var d = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t3 = e.kern.readFormat0(r2, t3, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t3, a2) {
      var n2 = e._bin, o = -1, s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readShort(r2, t3);
        t3 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var u2 = a2.rval[a2.rval.length - 1];
        u2.glyph2.push(d), u2.vals.push(f), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = [], i = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r2, t3 + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r2, t3 + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {}, s = n2.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n2.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n2.readUshort(r2, t3), t3 += 2, o.maxContours = n2.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n2.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n2.readUshort(r2, t3), t3 += 2, o.maxZones = n2.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n2.readUshort(r2, t3), t3 += 2, o.maxStorage = n2.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxStackElements = n2.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n2.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n2.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n2.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t3 += 2, f = 0; f < s; f++) {
        var u2 = n2.readUshort(r2, t3);
        t3 += 2;
        var l = n2.readUshort(r2, t3);
        t3 += 2;
        var v4 = n2.readUshort(r2, t3);
        t3 += 2;
        var c = n2.readUshort(r2, t3);
        t3 += 2;
        var p = n2.readUshort(r2, t3);
        t3 += 2;
        var U2 = n2.readUshort(r2, t3);
        t3 += 2;
        var g4, S = h[c], m = d + 12 * s + U2;
        if (0 == u2) g4 = n2.readUnicode(r2, m, p / 2);
        else if (3 == u2 && 0 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else if (0 == l) g4 = n2.readASCII(r2, m, p);
        else if (1 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else if (3 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else {
          if (1 != u2) throw "unknown encoding " + l + ", platformID: " + u2;
          g4 = n2.readASCII(r2, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b = "p" + u2 + "," + v4.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g4, o[b]._lang = v4;
      }
      for (var y2 in o) if (null != o[y2].postScriptName && 1033 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 0 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 3084 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName) return o[y2];
      for (var y2 in o) {
        i = y2;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a2) {
      var n2 = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n2) e["OS/2"].version0(r2, t3, o);
      else if (1 == n2) e["OS/2"].version1(r2, t3, o);
      else if (2 == n2 || 3 == n2 || 4 == n2) e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n2) throw "unknown OS/2 table version: " + n2;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a2) {
      var n2 = e._bin;
      return a2.xAvgCharWidth = n2.readShort(r2, t3), t3 += 2, a2.usWeightClass = n2.readUshort(r2, t3), t3 += 2, a2.usWidthClass = n2.readUshort(r2, t3), t3 += 2, a2.fsType = n2.readUshort(r2, t3), t3 += 2, a2.ySubscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutSize = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutPosition = n2.readShort(r2, t3), t3 += 2, a2.sFamilyClass = n2.readShort(r2, t3), t3 += 2, a2.panose = n2.readBytes(r2, t3, 10), t3 += 10, a2.ulUnicodeRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange2 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange3 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange4 = n2.readUint(r2, t3), t3 += 4, a2.achVendID = [n2.readInt8(r2, t3), n2.readInt8(r2, t3 + 1), n2.readInt8(r2, t3 + 2), n2.readInt8(r2, t3 + 3)], t3 += 4, a2.fsSelection = n2.readUshort(r2, t3), t3 += 2, a2.usFirstCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.usLastCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.sTypoAscender = n2.readShort(r2, t3), t3 += 2, a2.sTypoDescender = n2.readShort(r2, t3), t3 += 2, a2.sTypoLineGap = n2.readShort(r2, t3), t3 += 2, a2.usWinAscent = n2.readUshort(r2, t3), t3 += 2, a2.usWinDescent = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a2), a2.ulCodePageRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulCodePageRange2 = n2.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a2), a2.sxHeight = n2.readShort(r2, t3), t3 += 2, a2.sCapHeight = n2.readShort(r2, t3), t3 += 2, a2.usDefault = n2.readUshort(r2, t3), t3 += 2, a2.usBreak = n2.readUshort(r2, t3), t3 += 2, a2.usMaxContext = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a2), a2.usLowerOpticalPointSize = n2.readUshort(r2, t3), t3 += 2, a2.usUpperOpticalPointSize = n2.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return o.version = n2.readFixed(r2, t3), t3 += 4, o.italicAngle = n2.readFixed(r2, t3), t3 += 4, o.underlinePosition = n2.readShort(r2, t3), t3 += 2, o.underlineThickness = n2.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a2 = -1;
      if (null != t3.p0e4 ? a2 = t3.p0e4 : null != t3.p3e1 ? a2 = t3.p3e1 : null != t3.p1e0 ? a2 = t3.p1e0 : null != t3.p0e3 && (a2 = t3.p0e3), -1 == a2) throw "no familiar platform and encoding!";
      var n2 = t3.tables[a2];
      if (0 == n2.format) return e2 >= n2.map.length ? 0 : n2.map[e2];
      if (4 == n2.format) {
        for (var o = -1, s = 0; s < n2.endCount.length; s++) if (e2 <= n2.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n2.startCount[o] > e2) return 0;
        return 65535 & (0 != n2.idRangeOffset[o] ? n2.glyphIdArray[e2 - n2.startCount[o] + (n2.idRangeOffset[o] >> 1) - (n2.idRangeOffset.length - o)] : e2 + n2.idDelta[o]);
      }
      if (12 == n2.format) {
        if (e2 > n2.groups[n2.groups.length - 1][1]) return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i = n2.groups[s];
          if (i[0] <= e2 && e2 <= i[1]) return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n2 = r2.SVG.entries[t3];
        return null == n2 ? a2 : ("string" == typeof n2 && (n2 = e.SVG.toPath(n2), r2.SVG.entries[t3] = n2), n2);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; ) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i, a2);
      } else r2.glyf && e.U._drawGlyf(t3, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t3, a2) {
      var n2 = t3.glyf[r2];
      null == n2 && (n2 = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n2 && (n2.noc > -1 ? e.U._simpleGlyph(n2, a2) : e.U._compoGlyph(n2, t3, a2));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n2 = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n2; s <= o; s++) {
          var i = s == n2 ? o : s - 1, h = s == o ? n2 : s + 1, d = 1 & r2.flags[s], f = 1 & r2.flags[i], u2 = 1 & r2.flags[h], l = r2.xs[s], v4 = r2.ys[s];
          if (s == n2) if (d) {
            if (!f) {
              e.U.P.moveTo(t3, l, v4);
              continue;
            }
            e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]);
          } else f ? e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t3, (r2.xs[i] + l) / 2, (r2.ys[i] + v4) / 2);
          d ? f && e.U.P.lineTo(t3, l, v4) : u2 ? e.U.P.qcurveTo(t3, l, v4, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, l, v4, (l + r2.xs[h]) / 2, (v4 + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a2) {
      for (var n2 = 0; n2 < r2.parts.length; n2++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n2];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h], f = o.crds[h + 1];
          a2.crds.push(d * i.a + f * i.b + i.tx), a2.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a2 = e._lctf.getInterval(t3, r2);
      return -1 == a2 ? 0 : t3[a2 + 2];
    }, e.U._applySubs = function(r2, t3, a2, n2) {
      for (var o = r2.length - t3 - 1, s = 0; s < a2.tabs.length; s++) if (null != a2.tabs[s]) {
        var i, h = a2.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
          if (1 == a2.ltype) r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i];
          else if (4 == a2.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
            var u2 = d[f], l = u2.chain.length;
            if (!(l > o)) {
              for (var v4 = true, c = 0, p = 0; p < l; p++) {
                for (; -1 == r2[t3 + c + (1 + p)]; ) c++;
                u2.chain[p] != r2[t3 + c + (1 + p)] && (v4 = false);
              }
              if (v4) {
                r2[t3] = u2.nglyph;
                for (p = 0; p < l + c; p++) r2[t3 + p + 1] = -1;
                break;
              }
            }
          }
          else if (5 == a2.ltype && 2 == h.fmt) for (var U2 = e._lctf.getInterval(h.cDef, r2[t3]), g4 = h.cDef[U2 + 2], S = h.scset[g4], m = 0; m < S.length; m++) {
            var b = S[m], y2 = b.input;
            if (!(y2.length > o)) {
              for (v4 = true, p = 0; p < y2.length; p++) {
                var F3 = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p]);
                if (-1 == U2 && h.cDef[F3 + 2] != y2[p]) {
                  v4 = false;
                  break;
                }
              }
              if (v4) {
                var C3 = b.substLookupRecords;
                for (f = 0; f < C3.length; f += 2) C3[f], C3[f + 1];
              }
            }
          }
          else if (6 == a2.ltype && 3 == h.fmt) {
            if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length)) continue;
            if (!e.U._glsCovered(r2, h.inptCvg, t3)) continue;
            if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length)) continue;
            var _ = h.lookupRec;
            for (m = 0; m < _.length; m += 2) {
              U2 = _[m];
              var P2 = n2[_[m + 1]];
              e.U._applySubs(r2, t3 + U2, P2, n2);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r2, t3, a2) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e._lctf.coverageIndex(t3[n2], r2[a2 + n2])) return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a2) {
      for (var n2 = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i = t3[s];
        if (-1 != i) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, d = e.U.glyphToPath(r2, i), f = 0; f < d.crds.length; f += 2) n2.crds.push(d.crds[f] + o), n2.crds.push(d.crds[f + 1]);
          a2 && n2.cmds.push(a2);
          for (f = 0; f < d.cmds.length; f++) n2.cmds.push(d.cmds[f]);
          a2 && n2.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n2;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a2, n2, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a2, n2, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a2, n2) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a2, n2);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a2, n2, o) {
      for (var s = t3.stack, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open, u2 = 0, l = t3.x, v4 = t3.y, c = 0, p = 0, U2 = 0, g4 = 0, S = 0, m = 0, b = 0, y2 = 0, F3 = 0, C3 = 0, _ = { val: 0, size: 0 }; u2 < r2.length; ) {
        e.CFF.getCharString(r2, u2, _);
        var P2 = _.val;
        if (u2 += _.size, "o1" == P2 || "o18" == P2) s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == P2 || "o23" == P2) {
          s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == P2) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), f && e.U.P.closePath(o), v4 += s.pop(), e.U.P.moveTo(o, l, v4), f = true;
        else if ("o5" == P2) for (; s.length > 0; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
        else if ("o6" == P2 || "o7" == P2) for (var x = s.length, I4 = "o6" == P2, w = 0; w < x; w++) {
          var k = s.shift();
          I4 ? l += k : v4 += k, I4 = !I4, e.U.P.lineTo(o, l, v4);
        }
        else if ("o8" == P2 || "o24" == P2) {
          x = s.length;
          for (var G2 = 0; G2 + 6 <= x; ) c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4), G2 += 6;
          "o24" == P2 && (l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4));
        } else {
          if ("o11" == P2) break;
          if ("o1234" == P2 || "o1235" == P2 || "o1236" == P2 || "o1237" == P2) "o1234" == P2 && (p = v4, U2 = (c = l + s.shift()) + s.shift(), C3 = g4 = p + s.shift(), m = g4, y2 = v4, l = (b = (S = (F3 = U2 + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1235" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), F3 = U2 + s.shift(), C3 = g4 + s.shift(), S = F3 + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y2 = m + s.shift(), l = b + s.shift(), v4 = y2 + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1236" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), C3 = g4 = p + s.shift(), m = g4, b = (S = (F3 = U2 + s.shift()) + s.shift()) + s.shift(), y2 = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1237" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), F3 = U2 + s.shift(), C3 = g4 + s.shift(), S = F3 + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y2 = m + s.shift(), Math.abs(b - l) > Math.abs(y2 - v4) ? l = b + s.shift() : v4 = y2 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4));
          else if ("o14" == P2) {
            if (s.length > 0 && !h && (d = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var O3 = s.shift(), T4 = s.shift(), D2 = s.shift(), B3 = s.shift(), A3 = e.CFF.glyphBySE(a2, D2), R2 = e.CFF.glyphBySE(a2, B3);
              e.U._drawCFF(a2.CharStrings[A3], t3, a2, n2, o), t3.x = O3, t3.y = T4, e.U._drawCFF(a2.CharStrings[R2], t3, a2, n2, o);
            }
            f && (e.U.P.closePath(o), f = false);
          } else if ("o19" == P2 || "o20" == P2) {
            s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, u2 += i + 7 >> 3;
          } else if ("o21" == P2) s.length > 2 && !h && (d = s.shift() + n2.nominalWidthX, h = true), v4 += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o22" == P2) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o25" == P2) {
            for (; s.length > 6; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
            c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          } else if ("o26" == P2) for (s.length % 2 && (l += s.shift()); s.length > 0; ) c = l, p = v4 + s.shift(), l = U2 = c + s.shift(), v4 = (g4 = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          else if ("o27" == P2) for (s.length % 2 && (v4 += s.shift()); s.length > 0; ) p = v4, U2 = (c = l + s.shift()) + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4, e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          else if ("o10" == P2 || "o29" == P2) {
            var L = "o10" == P2 ? n2 : a2;
            if (0 == s.length) console.debug("error: empty stack");
            else {
              var W2 = s.pop(), M3 = L.Subrs[W2 + L.Bias];
              t3.x = l, t3.y = v4, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f, e.U._drawCFF(M3, t3, a2, n2, o), l = t3.x, v4 = t3.y, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open;
            }
          } else if ("o30" == P2 || "o31" == P2) {
            var V2 = s.length, E3 = (G2 = 0, "o31" == P2);
            for (G2 += V2 - (x = -3 & V2); G2 < x; ) E3 ? (p = v4, U2 = (c = l + s.shift()) + s.shift(), v4 = (g4 = p + s.shift()) + s.shift(), x - G2 == 5 ? (l = U2 + s.shift(), G2++) : l = U2, E3 = false) : (c = l, p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), x - G2 == 5 ? (v4 = g4 + s.shift(), G2++) : v4 = g4, E3 = true), e.U.P.curveTo(o, c, p, U2, g4, l, v4), G2 += 4;
          } else {
            if ("o" == (P2 + "").charAt(0)) throw console.debug("Unknown operation: " + P2, r2), P2;
            s.push(P2);
          }
        }
      }
      t3.x = l, t3.y = v4, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f;
    };
    var t2 = e, a = { Typr: t2 };
    return r.Typr = t2, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n2(31), i2 = 0; i2 < 31; ++i2) a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t2(a2[30]);
      for (i2 = 1; i2 < 30; ++i2) for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2) o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u2 = f(a, 2), v4 = u2[0], s = u2[1];
    v4[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n2(32768), g4 = 0; g4 < 32768; ++g4) {
      var h = (43690 & g4) >>> 1 | (21845 & g4) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g4] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a2 = r2.length, i2 = 0, o2 = new n2(e2); i2 < a2; ++i2) ++o2[r2[i2] - 1];
      var f2, u3 = new n2(e2);
      for (i2 = 0; i2 < e2; ++i2) u3[i2] = u3[i2 - 1] + o2[i2 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e2);
        var v5 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2) if (r2[i2]) for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g5 = u3[r2[i2] - 1]++ << l2, h2 = g5 | (1 << l2) - 1; g5 <= h2; ++g5) f2[c[g5] >>> v5] = s2;
      } else for (f2 = new n2(a2), i2 = 0; i2 < a2; ++i2) r2[i2] && (f2[i2] = c[u3[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g4 = 0; g4 < 144; ++g4) d[g4] = 8;
    for (g4 = 144; g4 < 256; ++g4) d[g4] = 9;
    for (g4 = 256; g4 < 280; ++g4) d[g4] = 7;
    for (g4 = 280; g4 < 288; ++g4) d[g4] = 8;
    var m = new e(32);
    for (g4 = 0; g4 < 32; ++g4) m[g4] = 5;
    var b = w(d, 9, 1), p = w(m, 5, 1), y2 = function(r2) {
      for (var e2 = r2[0], n3 = 1; n3 < r2.length; ++n3) r2[n3] > e2 && (e2 = r2[n3]);
      return e2;
    }, L = function(r2, e2, n3) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n3;
    }, U2 = function(r2, e2) {
      var n3 = e2 / 8 | 0;
      return (r2[n3] | r2[n3 + 1] << 8 | r2[n3 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T4 = function(r2, e2, n3) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T4), !n3) throw t3;
      return t3;
    }, O3 = function(r2, f2, u3) {
      var s2 = r2.length;
      if (!s2 || u3 && !u3.l && s2 < 5) return f2 || new e(0);
      var c2 = !f2 || u3, g5 = !u3 || u3.i;
      u3 || (u3 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n3 = f2.length;
        if (r3 > n3) {
          var t3 = new e(Math.max(2 * n3, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u3.f || 0, k2 = u3.p || 0, O4 = u3.b || 0, A4 = u3.l, x2 = u3.d, E3 = u3.m, D2 = u3.n, M3 = 8 * s2;
      do {
        if (!A4) {
          u3.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V2 = r2[(I4 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I4 - 3] << 8, _ = I4 + V2;
            if (_ > s2) {
              g5 && T4(0);
              break;
            }
            c2 && d2(O4 + V2), f2.set(r2.subarray(I4, _), O4), u3.b = O4 += V2, u3.p = k2 = 8 * _;
            continue;
          }
          if (1 == S) A4 = b, x2 = p, E3 = 9, D2 = 5;
          else if (2 == S) {
            var j2 = L(r2, k2, 31) + 257, z2 = L(r2, k2 + 10, 15) + 4, C3 = j2 + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F3 = new e(C3), P2 = new e(19), q2 = 0; q2 < z2; ++q2) P2[o[q2]] = L(r2, k2 + 3 * q2, 7);
            k2 += 3 * z2;
            var B3 = y2(P2), G2 = (1 << B3) - 1, H2 = w(P2, B3, 1);
            for (q2 = 0; q2 < C3; ) {
              var I4, J2 = H2[L(r2, k2, G2)];
              if (k2 += 15 & J2, (I4 = J2 >>> 4) < 16) F3[q2++] = I4;
              else {
                var K3 = 0, N2 = 0;
                for (16 == I4 ? (N2 = 3 + L(r2, k2, 3), k2 += 2, K3 = F3[q2 - 1]) : 17 == I4 ? (N2 = 3 + L(r2, k2, 7), k2 += 3) : 18 == I4 && (N2 = 11 + L(r2, k2, 127), k2 += 7); N2--; ) F3[q2++] = K3;
              }
            }
            var Q2 = F3.subarray(0, j2), R2 = F3.subarray(j2);
            E3 = y2(Q2), D2 = y2(R2), A4 = w(Q2, E3, 1), x2 = w(R2, D2, 1);
          } else T4(1);
          if (k2 > M3) {
            g5 && T4(0);
            break;
          }
        }
        c2 && d2(O4 + 131072);
        for (var W2 = (1 << E3) - 1, X3 = (1 << D2) - 1, Y3 = k2; ; Y3 = k2) {
          var Z3 = (K3 = A4[U2(r2, k2) & W2]) >>> 4;
          if ((k2 += 15 & K3) > M3) {
            g5 && T4(0);
            break;
          }
          if (K3 || T4(2), Z3 < 256) f2[O4++] = Z3;
          else {
            if (256 == Z3) {
              Y3 = k2, A4 = null;
              break;
            }
            var $ = Z3 - 254;
            if (Z3 > 264) {
              var rr = a[q2 = Z3 - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v4[q2], k2 += rr;
            }
            var er = x2[U2(r2, k2) & X3], nr = er >>> 4;
            er || T4(3), k2 += 15 & er;
            R2 = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R2 += U2(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M3) {
              g5 && T4(0);
              break;
            }
            c2 && d2(O4 + 131072);
            for (var tr = O4 + $; O4 < tr; O4 += 4) f2[O4] = f2[O4 - R2], f2[O4 + 1] = f2[O4 + 1 - R2], f2[O4 + 2] = f2[O4 + 2 - R2], f2[O4 + 3] = f2[O4 + 3 - R2];
            O4 = tr;
          }
        }
        u3.l = A4, u3.p = Y3, u3.b = O4, A4 && (m2 = 1, u3.m = E3, u3.d = x2, u3.n = D2);
      } while (!m2);
      return O4 == f2.length ? f2 : function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n2 ? n2 : r3 instanceof t2 ? t2 : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O4);
    }, A3 = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A3, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n3 = 0;
      function t3() {
        var r3 = e2.getUint16(n3);
        return n3 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n3);
        return n3 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b3, r3), b3 += 2;
      }
      function o2(r3) {
        m2.setUint32(b3, r3), b3 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t3(), reserved: t3(), totalSfntSize: a2(), majorVersion: t3(), minorVersion: t3(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u3 = 0; Math.pow(2, u3) <= f2.numTables; ) u3++;
      u3--;
      for (var v5 = 16 * Math.pow(2, u3), s2 = 16 * f2.numTables - v5, l2 = 12, c2 = [], g5 = 0; g5 < f2.numTables; g5++) c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b3 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v5), i2(u3), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n4, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n4 = new Uint8Array(t4, 2), O3(n4, a3);
        } else a3 = new Uint8Array(t4);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch3) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch3) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535) i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3);
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId];
      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j2 = 0; j2 < lookup.tabs.length; j2++) {
            const tab = lookup.tabs[j2];
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            } else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k = 0; k < right.length; k++) {
                      if (right[k].gid2 === glyphId) adj = right[k];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            } else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            } else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "number") {
        return args[i];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j2 = 1; j2 <= numArgs; j2++) {
                  path += (j2 > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x = crds[i2];
                  let y2 = crds[i2 + 1];
                  if (x < xMin) xMin = x;
                  if (y2 < yMin) yMin = y2;
                  if (x > xMax) xMax = x;
                  if (y2 > yMax) yMax = y2;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(
              null,
              glyphObj,
              penX + positions[i * 3] * fontScale,
              positions[i * 3 + 1] * fontScale,
              charIndex
            );
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory3, woff2otfFactory3, parserFactory3) {
    const Typr = typrFactory3();
    const woff2otf = woff2otfFactory3();
    return parserFactory3(Typr, woff2otf);
  }
});
function unicodeFontResolverClientFactory() {
  return function(t2) {
    var n2 = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    n2.prototype.add = function(t3) {
      var n3 = t3 >> 5;
      this.buckets.set(n3, (this.buckets.get(n3) || 0) | 1 << (31 & t3));
    }, n2.prototype.has = function(t3) {
      var n3 = this.buckets.get(t3 >> 5);
      return void 0 !== n3 && 0 != (n3 & 1 << (31 & t3));
    }, n2.prototype.serialize = function() {
      var t3 = [];
      return this.buckets.forEach(function(n3, r2) {
        t3.push((+r2).toString(36) + ":" + n3.toString(36));
      }), t3.join(",");
    }, n2.prototype.deserialize = function(t3) {
      var n3 = this;
      this.buckets.clear(), t3.split(",").forEach(function(t4) {
        var r2 = t4.split(":");
        n3.buckets.set(parseInt(r2[0], 36), parseInt(r2[1], 36));
      });
    };
    var r = Math.pow(2, 8), e = r - 1, o = ~e;
    function a(t3) {
      var n3 = function(t4) {
        return t4 & o;
      }(t3).toString(16), e2 = function(t4) {
        return (t4 & o) + r - 1;
      }(t3).toString(16);
      return "codepoint-index/plane" + (t3 >> 16) + "/" + n3 + "-" + e2 + ".json";
    }
    function i(t3, n3) {
      var r2 = t3 & e, o2 = n3.codePointAt(r2 / 6 | 0);
      return 0 != ((o2 = (o2 || 48) - 48) & 1 << r2 % 6);
    }
    function u2(t3, n3) {
      var r2;
      (r2 = t3, r2.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(t4) {
        return t4.split("-").map(function(t5) {
          return parseInt(t5.trim(), 16);
        });
      })).forEach(function(t4) {
        var r3 = t4[0], e2 = t4[1];
        void 0 === e2 && (e2 = r3), n3(r3, e2);
      });
    }
    function c(t3, n3) {
      u2(t3, function(t4, r2) {
        for (var e2 = t4; e2 <= r2; e2++) n3(e2);
      });
    }
    var s = {}, f = {}, l = /* @__PURE__ */ new WeakMap(), v4 = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t3) {
      var r2 = l.get(t3);
      return r2 || (r2 = new n2(), c(t3.ranges, function(t4) {
        return r2.add(t4);
      }), l.set(t3, r2)), r2;
    }
    var h, p = /* @__PURE__ */ new Map();
    function g4(t3, n3, r2) {
      return t3[n3] ? n3 : t3[r2] ? r2 : function(t4) {
        for (var n4 in t4) return n4;
      }(t3);
    }
    function w(t3, n3) {
      var r2 = n3;
      if (!t3.includes(r2)) {
        r2 = 1 / 0;
        for (var e2 = 0; e2 < t3.length; e2++) Math.abs(t3[e2] - n3) < Math.abs(r2 - n3) && (r2 = t3[e2]);
      }
      return r2;
    }
    function k(t3) {
      return h || (h = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(t4) {
        h.add(t4);
      })), h.has(t3);
    }
    return t2.CodePointSet = n2, t2.clearCache = function() {
      s = {}, f = {};
    }, t2.getFontsForString = function(t3, n3) {
      void 0 === n3 && (n3 = {});
      var r2, e2 = n3.lang;
      void 0 === e2 && (e2 = new RegExp("\\p{Script=Hangul}", "u").test(r2 = t3) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(r2) ? "ja" : "en");
      var o2 = n3.category;
      void 0 === o2 && (o2 = "sans-serif");
      var u3 = n3.style;
      void 0 === u3 && (u3 = "normal");
      var c2 = n3.weight;
      void 0 === c2 && (c2 = 400);
      var l2 = (n3.dataUrl || v4).replace(/\/$/g, ""), h2 = /* @__PURE__ */ new Map(), y2 = new Uint8Array(t3.length), b = {}, m = {}, A3 = new Array(t3.length), S = /* @__PURE__ */ new Map(), j2 = false;
      function M3(t4) {
        var n4 = p.get(t4);
        return n4 || (n4 = fetch(l2 + "/" + t4).then(function(t5) {
          if (!t5.ok) throw new Error(t5.statusText);
          return t5.json().then(function(t6) {
            if (!Array.isArray(t6) || 1 !== t6[0]) throw new Error("Incorrect schema version; need 1, got " + t6[0]);
            return t6[1];
          });
        }).catch(function(n5) {
          if (l2 !== v4) return j2 || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l2 + '", trying default CDN. ' + n5.message), j2 = true), l2 = v4, p.delete(t4), M3(t4);
          throw n5;
        }), p.set(t4, n4)), n4;
      }
      for (var P2 = function(n4) {
        var r3 = t3.codePointAt(n4), e3 = a(r3);
        A3[n4] = e3, s[e3] || S.has(e3) || S.set(e3, M3(e3).then(function(t4) {
          s[e3] = t4;
        })), r3 > 65535 && (n4++, E3 = n4);
      }, E3 = 0; E3 < t3.length; E3++) P2(E3);
      return Promise.all(S.values()).then(function() {
        S.clear();
        for (var n4 = function(n5) {
          var o3 = t3.codePointAt(n5), a2 = null, u4 = s[A3[n5]], c3 = void 0;
          for (var l3 in u4) {
            var v5 = m[l3];
            if (void 0 === v5 && (v5 = m[l3] = new RegExp(l3).test(e2 || "en")), v5) {
              for (var d2 in c3 = l3, u4[l3]) if (i(o3, u4[l3][d2])) {
                a2 = d2;
                break;
              }
              break;
            }
          }
          if (!a2) {
            t: for (var h3 in u4) if (h3 !== c3) {
              for (var p2 in u4[h3]) if (i(o3, u4[h3][p2])) {
                a2 = p2;
                break t;
              }
            }
          }
          a2 || (console.debug("No font coverage for U+" + o3.toString(16)), a2 = "latin"), A3[n5] = a2, f[a2] || S.has(a2) || S.set(a2, M3("font-meta/" + a2 + ".json").then(function(t4) {
            f[a2] = t4;
          })), o3 > 65535 && (n5++, r3 = n5);
        }, r3 = 0; r3 < t3.length; r3++) n4(r3);
        return Promise.all(S.values());
      }).then(function() {
        for (var n4, r3 = null, e3 = 0; e3 < t3.length; e3++) {
          var a2 = t3.codePointAt(e3);
          if (r3 && (k(a2) || d(r3).has(a2))) y2[e3] = y2[e3 - 1];
          else {
            r3 = f[A3[e3]];
            var i2 = b[r3.id];
            if (!i2) {
              var s2 = r3.typeforms, v5 = g4(s2, o2, "sans-serif"), p2 = g4(s2[v5], u3, "normal"), m2 = w(null === (n4 = s2[v5]) || void 0 === n4 ? void 0 : n4[p2], c2);
              i2 = b[r3.id] = l2 + "/font-files/" + r3.id + "/" + v5 + "." + p2 + "." + m2 + ".woff";
            }
            var S2 = h2.get(i2);
            null == S2 && (S2 = h2.size, h2.set(i2, S2)), y2[e3] = S2;
          }
          a2 > 65535 && (e3++, y2[e3] = y2[e3 - 1]);
        }
        return { fontUrls: Array.from(h2.keys()), chars: y2 };
      });
    }, Object.defineProperty(t2, "__esModule", { value: true }), t2;
  }({});
}
function createFontResolver(fontParser, unicodeFontResolverClient) {
  const parsedFonts = /* @__PURE__ */ Object.create(null);
  const loadingFonts = /* @__PURE__ */ Object.create(null);
  function doLoadFont(url, callback) {
    const onError2 = (err2) => {
      console.error(`Failure loading font ${url}`, err2);
    };
    try {
      const request = new XMLHttpRequest();
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.status >= 400) {
          onError2(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError2(e);
          }
        }
      };
      request.onerror = onError2;
      request.send();
    } catch (err2) {
      onError2(err2);
    }
  }
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, (fontObj) => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach((cb) => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }
  return function(text, callback, {
    lang,
    fonts: userFonts = [],
    style = "normal",
    weight = "normal",
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = /* @__PURE__ */ new Map();
    const fallbackRanges = [];
    if (style !== "italic") style = "normal";
    if (typeof weight !== "number") {
      weight = weight === "bold" ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice().filter((def) => !def.lang || def.lang.test(lang)).reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || i > 0 && /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j2 = charResolutions[i], jLen = userFonts.length; j2 <= jLen; j2++) {
              if (j2 === jLen) {
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j2;
                const { src, unicodeRange } = userFonts[j2];
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== "number") {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 65535 && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        const fallbackString = fallbackRanges.map((range) => text.substring(range[0], range[1] + 1)).join("\n");
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || void 0,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({ fontUrls, chars }) => {
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach((range) => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++;
          });
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, (fontObj) => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      for (let k = 0; k < ranges.length; k++) {
        const [start, end = start] = ranges[k];
        if (start <= code && code <= end) {
          return true;
        }
      }
      return false;
    }
  };
}
var fontResolverWorkerModule = defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(createFontResolver3, fontParser, unicodeFontResolverClientFactory3) {
    return createFontResolver3(fontParser, unicodeFontResolverClientFactory3());
  }
});
function createTypesetter(resolveFonts, bidi) {
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {
    const onResolved = ({ chars, fonts: parsedFonts }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]] });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(
        text,
        onResolved,
        { lang, fonts, style, weight, unicodeFontsURL }
      );
    }
  }
  function typeset({
    text = "",
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = "normal",
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction: direction2,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now3();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === "string" ? [{ src: font }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, (runs) => {
      timings.fontLoad = now3() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const metricsByFont = /* @__PURE__ */ new Map();
      const typesetStart = now3();
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach((run) => {
        const { fontObj } = run;
        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
        let fontData2 = metricsByFont.get(fontObj);
        if (!fontData2) {
          const fontSizeMult2 = fontSize / unitsPerEm;
          const calcLineHeight = lineHeight === "normal" ? (ascender - descender + lineGap) * fontSizeMult2 : lineHeight * fontSize;
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult2) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult2);
          const caretTop = (ascender + descender) / 2 * fontSizeMult2 + caretHeight / 2;
          fontData2 = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult: fontSizeMult2,
            unitsPerEm,
            ascender: ascender * fontSizeMult2,
            descender: descender * fontSizeMult2,
            capHeight: capHeight * fontSizeMult2,
            xHeight: xHeight * fontSizeMult2,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult2,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData2);
        }
        const { fontSizeMult } = fontData2;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;
          if (!("isEmpty" in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              for (let i = curLineCount; i--; ) {
                if (i === 0 && overflowWrap === "break-word") {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j2 = nextLine.count; j2--; ) {
                    nextLine.glyphAt(j2).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth;
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData2;
          if (char === "\n") {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });
      let totalHeight = 0;
      lines.forEach((line) => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--; ) {
          const glyphInfo = line.glyphAt(i);
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          let { lineHeight: lineHeight2, capHeight, xHeight, baseline } = glyphInfo.fontData;
          if (lineHeight2 > line.lineHeight) line.lineHeight = lineHeight2;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -lines[0].baseline : anchorY === "top-cap" ? -lines[0].cap : anchorY === "top-ex" ? -lines[0].ex : anchorY === "middle" ? totalHeight / 2 : anchorY === "bottom" ? totalHeight : anchorY === "bottom-baseline" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction2);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j2 = startInLine; j2 < endInLine; j2++) {
                    const glyphInfo = line.glyphAt(j2);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g4) => glyphObj = g4;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex, fontData: fontData2 } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData2.caretBottom + anchorYOffset;
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData2.caretTop + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      const fontData = [];
      metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight }) => {
        fontData[index] = { src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight };
      });
      timings.typesetting = now3() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - totalHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset({ ...args, metricsOnly: true }, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now3() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop2, i, all) => {
    Object.defineProperty(obj, prop2, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel).then(
    null,
    (err2) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err2);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel);
    }
  );
}
var queue = [];
var chunkTimeBudget = 5;
var timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
var generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({ timing: now() - start });
      } catch (err2) {
        reject(err2);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
var threadCount = 4;
var idleTimeout = 2e3;
var threads = {};
var callNum = 0;
function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now3) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now3();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now3() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y2, width, height, 1 << 3 - channel);
    timing += now() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
var CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048,
  useWorker: true
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now$1();
  const { defaultFontURL } = CONFIG;
  const fonts = [];
  if (defaultFontURL) {
    fonts.push({ label: "default", src: toAbsoluteURL(defaultFontURL) });
  }
  if (args.font) {
    fonts.push({ label: "user", src: toAbsoluteURL(args.font) });
  }
  args.font = fonts;
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key2 in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key2)) {
        let val = args.colorRanges[key2];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key2] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  const typeset = CONFIG.useWorker ? typesetInWorker : typesetOnMainThread;
  typeset(args).then((result) => {
    const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    const fontGlyphMaps = fontData.map((font) => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = /* @__PURE__ */ new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const { src: fontSrc, unitsPerEm } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[fontSrc][glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y2 = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y2, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function assign3(toObj, fromObj) {
  for (let key2 in fromObj) {
    if (fromObj.hasOwnProperty(key2)) {
      toObj[key2] = fromObj[key2];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidi_default
  ],
  init(createTypesetter3, fontResolver, bidiFactory2) {
    return createTypesetter3(fontResolver, bidiFactory2());
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
var typesetOnMainThread = typesetInWorker.onMainThread;
var templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    geom = templateGeometries[detail] = new PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);
  }
  return geom;
}
var glyphBoundsAttrName = "aTroikaGlyphBounds";
var glyphIndexAttrName = "aTroikaGlyphIndex";
var glyphColorAttrName = "aTroikaGlyphColor";
var GlyphsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);
    this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);
    this.updateAttributeData(glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max: max2, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max2(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max2(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--; ) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(attrName, newArray, itemSize) {
    const attr = this.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        this.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete this._maxInstanceCount;
        this.dispose();
      }
    } else if (attr) {
      this.deleteAttribute(attrName);
    }
  }
};
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: vertexShader9, fragmentShader: fragmentShader9 }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader9)) {
        fragmentShader9 = fragmentShader9.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader9)) {
          vertexShader9 = vertexShader9.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader: vertexShader9, fragmentShader: fragmentShader9 };
    }
  });
  textMaterial.transparent = true;
  textMaterial.forceSinglePass = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
var defaultStrokeColor = 8421504;
var tempMat4 = new Matrix4();
var tempVec3a = new Vector3();
var tempVec3b = new Vector3();
var tempArray = [];
var origin2 = new Vector3();
var defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
var getFlatRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
var syncStartEvent = { type: "syncstart" };
var syncCompleteEvent = { type: "synccomplete" };
var SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text = class extends Mesh {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.unicodeFontsURL = null;
    this.fontSize = 0.1;
    this.fontWeight = "normal";
    this.fontStyle = "normal";
    this.lang = null;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || "normal",
          fontStyle: this.fontStyle || "normal",
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(baseMaterial) {
    return createTextDerivedMaterial(baseMaterial);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {
      derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.hasOutline()) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaEdgeOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
    const color2 = isOutline ? this.outlineColor || 0 : this.color;
    if (color2 == null) {
      delete material.color;
    } else {
      const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
      if (color2 !== colorObj._input || typeof color2 === "object") {
        colorObj.set(colorObj._input = color2);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin2, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position2, target = new Vector2()) {
    target.copy(position2);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position2.x, Math.abs(r) - Math.abs(position2.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position2, target = new Vector2()) {
    tempVec3a.copy(position2);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position: position2, uv } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y2 = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z2 = 0;
        if (curveRadius) {
          z2 = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position2.setXYZ(i, x, y2, z2);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i = 0; i < tempArray.length; i++) {
        tempArray[i].object = this;
        intersects.push(tempArray[i]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop2) => {
      this[prop2] = source[prop2];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((prop2) => {
  const privateKey = "_private_" + prop2;
  Object.defineProperty(Text.prototype, prop2, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});
var tempBox3 = new Box3();
var tempColor$1 = new Color();

// node_modules/three-perf/dist/ui/UI.mjs
var ThreePerfUI = class {
  //
  constructor(props) {
    var _a2;
    this._charts = /* @__PURE__ */ new Map();
    this._width = 400;
    this._height = 110;
    this._backgroundOpacity = 0.7;
    this._perf = props.perf;
    this._backgroundOpacity = (_a2 = props.backgroundOpacity) != null ? _a2 : this._backgroundOpacity;
    this.wrapper = document.createElement("div");
    this.wrapper.id = "three-perf-ui";
    this.wrapper.style.position = "fixed";
    this.wrapper.style.bottom = "0";
    this.wrapper.style.left = "0";
    this.wrapper.style.width = this._width + "px";
    this.wrapper.style.height = this._height + "px";
    props.domElement.appendChild(this.wrapper);
    this.canvas = document.createElement("canvas");
    this.canvas.width = this._width;
    this.canvas.height = this._height;
    this.canvas.style.position = "absolute";
    this.wrapper.appendChild(this.canvas);
    this.initCanvas();
  }
  setScale(value) {
    this.wrapper.style.width = value * this.width + "px";
    this.wrapper.style.height = value * this.height + "px";
    this._renderer.setSize(this._width * value, this._height * value, true);
  }
  initCanvas() {
    this._renderer = new WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
      alpha: true
    });
    this._renderer.setClearColor(0, this._backgroundOpacity);
    this._renderer.setPixelRatio(window.devicePixelRatio);
    this._scene = new Scene();
    this._camera = new OrthographicCamera(
      0,
      this._width,
      0,
      -this._height,
      0.1,
      100
    );
    this._camera.position.set(0, 0, 10);
    this._camera.lookAt(0, 0, 0);
    this._camera.updateProjectionMatrix();
    this._scene.add(this._camera);
    this._scene.userData.useStats = false;
    const gpuValue = new Text();
    gpuValue.anchorX = "right";
    gpuValue.position.set(45, -8, 0);
    gpuValue.text = "0.000";
    gpuValue.fontSize = 15;
    gpuValue.color = "rgb(253, 151, 31)";
    gpuValue.sync();
    this._scene.add(gpuValue);
    const gpuMs = new Text();
    gpuMs.anchorX = "right";
    gpuMs.position.set(65, -7, 0);
    gpuMs.text = "ms";
    gpuMs.fontSize = 9;
    gpuMs.color = "rgb(255, 255, 255)";
    gpuMs.sync();
    this._scene.add(gpuMs);
    const gpuLabel = new Text();
    gpuLabel.anchorX = "right";
    gpuLabel.position.set(65, -22, 0);
    gpuLabel.text = "GPU";
    gpuLabel.fontSize = 9;
    gpuLabel.color = "rgb(253, 151, 31)";
    gpuLabel.sync();
    this._scene.add(gpuLabel);
    const cpuValue = new Text();
    cpuValue.anchorX = "right";
    cpuValue.position.set(115, -8, 0);
    cpuValue.text = "0.000";
    cpuValue.fontSize = 15;
    cpuValue.color = "rgb(66, 226, 46)";
    cpuValue.sync();
    this._scene.add(cpuValue);
    const cpuMs = new Text();
    cpuMs.anchorX = "right";
    cpuMs.position.set(135, -7, 0);
    cpuMs.text = "ms";
    cpuMs.fontSize = 9;
    cpuMs.color = "rgb(255, 255, 255)";
    cpuMs.sync();
    this._scene.add(cpuMs);
    const cpuLabel = new Text();
    cpuLabel.anchorX = "right";
    cpuLabel.position.set(135, -22, 0);
    cpuLabel.text = "CPU";
    cpuLabel.fontSize = 9;
    cpuLabel.color = "rgb(66, 226, 46)";
    cpuLabel.sync();
    this._scene.add(cpuLabel);
    const fpsValue = new Text();
    fpsValue.anchorX = "center";
    fpsValue.position.set(165, -8, 0);
    fpsValue.text = "0";
    fpsValue.fontSize = 15;
    fpsValue.color = "rgb(238, 38, 110)";
    fpsValue.sync();
    this._scene.add(fpsValue);
    const fpsLabel = new Text();
    fpsLabel.anchorX = "center";
    fpsLabel.position.set(175, -22, 0);
    fpsLabel.text = "FPS";
    fpsLabel.fontSize = 9;
    fpsLabel.color = "rgb(238, 38, 110)";
    fpsLabel.sync();
    this._scene.add(fpsLabel);
    const callsValue = new Text();
    callsValue.anchorX = "right";
    callsValue.position.set(235, -8, 0);
    callsValue.text = "0";
    callsValue.fontSize = 15;
    callsValue.color = "#ffffff";
    callsValue.sync();
    this._scene.add(callsValue);
    const callsLabel = new Text();
    callsLabel.anchorX = "right";
    callsLabel.position.set(235, -22, 0);
    callsLabel.text = "calls";
    callsLabel.fontSize = 9;
    callsLabel.color = "rgb(101, 197, 188)";
    callsLabel.sync();
    this._scene.add(callsLabel);
    const trianglesValue = new Text();
    trianglesValue.anchorX = "right";
    trianglesValue.position.set(315, -8, 0);
    trianglesValue.text = "0";
    trianglesValue.fontSize = 15;
    trianglesValue.color = "#ffffff";
    trianglesValue.sync();
    this._scene.add(trianglesValue);
    const trianglesLabel = new Text();
    trianglesLabel.anchorX = "right";
    trianglesLabel.position.set(315, -22, 0);
    trianglesLabel.text = "triangles";
    trianglesLabel.fontSize = 9;
    trianglesLabel.color = "rgb(101, 197, 188)";
    trianglesLabel.sync();
    this._scene.add(trianglesLabel);
    const renderpassesValue = new Text();
    renderpassesValue.anchorX = "right";
    renderpassesValue.position.set(365, -8, 0);
    renderpassesValue.text = "0";
    renderpassesValue.fontSize = 15;
    renderpassesValue.color = "#ffffff";
    renderpassesValue.sync();
    this._scene.add(renderpassesValue);
    const renderpassesLabel = new Text();
    renderpassesLabel.anchorX = "right";
    renderpassesLabel.position.set(365, -22, 0);
    renderpassesLabel.text = "passes";
    renderpassesLabel.fontSize = 9;
    renderpassesLabel.color = "rgb(101, 197, 188)";
    renderpassesLabel.sync();
    this._scene.add(renderpassesLabel);
    this._basicInfoElements = {
      gpuValue,
      cpuValue,
      fpsValue,
      callsValue,
      trianglesValue,
      renderpassesValue
    };
    const geometriesValue = new Text();
    geometriesValue.anchorX = "right";
    geometriesValue.position.set(65, -39, 0);
    geometriesValue.text = "0";
    geometriesValue.fontSize = 15;
    geometriesValue.color = "#ffffff";
    geometriesValue.sync();
    this._scene.add(geometriesValue);
    const geometriesLabel = new Text();
    geometriesLabel.anchorX = "right";
    geometriesLabel.position.set(65, -53, 0);
    geometriesLabel.text = "geometries";
    geometriesLabel.fontSize = 9;
    geometriesLabel.color = "rgb(101, 197, 188)";
    geometriesLabel.sync();
    this._scene.add(geometriesLabel);
    const texturesValue = new Text();
    texturesValue.anchorX = "right";
    texturesValue.position.set(135, -39, 0);
    texturesValue.text = "0";
    texturesValue.fontSize = 15;
    texturesValue.color = "#ffffff";
    texturesValue.sync();
    this._scene.add(texturesValue);
    const texturesLabel = new Text();
    texturesLabel.anchorX = "right";
    texturesLabel.position.set(135, -53, 0);
    texturesLabel.text = "textures";
    texturesLabel.fontSize = 9;
    texturesLabel.color = "rgb(101, 197, 188)";
    texturesLabel.sync();
    this._scene.add(texturesLabel);
    const shadersValue = new Text();
    shadersValue.anchorX = "right";
    shadersValue.position.set(205, -39, 0);
    shadersValue.text = "0";
    shadersValue.fontSize = 15;
    shadersValue.color = "#ffffff";
    shadersValue.sync();
    this._scene.add(shadersValue);
    const shadersLabel = new Text();
    shadersLabel.anchorX = "right";
    shadersLabel.position.set(205, -53, 0);
    shadersLabel.text = "shaders";
    shadersLabel.fontSize = 9;
    shadersLabel.color = "rgb(101, 197, 188)";
    shadersLabel.sync();
    this._scene.add(shadersLabel);
    const linesValue = new Text();
    linesValue.anchorX = "right";
    linesValue.position.set(275, -39, 0);
    linesValue.text = "0";
    linesValue.fontSize = 15;
    linesValue.color = "#ffffff";
    linesValue.sync();
    this._scene.add(linesValue);
    const linesLabel = new Text();
    linesLabel.anchorX = "right";
    linesLabel.position.set(275, -53, 0);
    linesLabel.text = "lines";
    linesLabel.fontSize = 9;
    linesLabel.color = "rgb(101, 197, 188)";
    linesLabel.sync();
    this._scene.add(linesLabel);
    const pointsValue = new Text();
    pointsValue.anchorX = "right";
    pointsValue.position.set(345, -39, 0);
    pointsValue.text = "0";
    pointsValue.fontSize = 15;
    pointsValue.color = "#ffffff";
    pointsValue.sync();
    this._scene.add(pointsValue);
    const pointsLabel = new Text();
    pointsLabel.anchorX = "right";
    pointsLabel.position.set(345, -53, 0);
    pointsLabel.text = "points";
    pointsLabel.fontSize = 9;
    pointsLabel.color = "rgb(101, 197, 188)";
    pointsLabel.sync();
    this._scene.add(pointsLabel);
    this._memInfoElements = {
      geometriesValue,
      geometriesLabel,
      texturesValue,
      texturesLabel,
      shadersValue,
      shadersLabel,
      linesValue,
      linesLabel,
      pointsValue,
      pointsLabel
    };
    const gpuChartGeometry = new BufferGeometry();
    let positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    let positionAttribute = new BufferAttribute(positions, 3);
    positionAttribute.usage = DynamicDrawUsage;
    gpuChartGeometry.setAttribute("position", positionAttribute);
    const gpuChart = new Line(
      gpuChartGeometry,
      new LineBasicMaterial({ color: "rgb(253, 151, 31)" })
    );
    this._scene.add(gpuChart);
    this._charts.set("gpu", gpuChart);
    const cpuChartGeometry = new BufferGeometry();
    positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    positionAttribute = new BufferAttribute(positions, 3);
    positionAttribute.usage = DynamicDrawUsage;
    cpuChartGeometry.setAttribute("position", positionAttribute);
    const cpuChart = new Line(
      cpuChartGeometry,
      new LineBasicMaterial({ color: "rgb(66, 226, 46)" })
    );
    this._scene.add(cpuChart);
    this._charts.set("cpu", cpuChart);
    const fpsChartGeometry = new BufferGeometry();
    positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    positionAttribute = new BufferAttribute(positions, 3);
    positionAttribute.usage = DynamicDrawUsage;
    fpsChartGeometry.setAttribute("position", positionAttribute);
    const fpsChart = new Line(
      fpsChartGeometry,
      new LineBasicMaterial({ color: "rgb(238, 38, 110)" })
    );
    this._scene.add(fpsChart);
    this._charts.set("fps", fpsChart);
  }
  update() {
    var _a2, _b2;
    if (this._perf.chart && this._perf.showGraph) {
      for (const chartName in this._perf.chart.data) {
        const chartData = this._perf.chart.data[chartName];
        if (!this._charts.get(chartName) || !chartData)
          continue;
        const geometry = this._charts.get(chartName).geometry;
        const positionAttr = geometry.attributes.position;
        let maxValue = 0;
        for (let i = 0; i < chartData.length; i++) {
          if (chartData[i] > maxValue)
            maxValue = chartData[i];
        }
        maxValue = Math.max(maxValue, 20);
        for (let i = 0; i < chartData.length; i++) {
          let id = (this._perf.chart.circularId + i + 1) % 60;
          positionAttr.setY(
            i,
            (chartData[id] / maxValue * 90 - 110) * this.height / 110
          );
        }
        positionAttr.needsUpdate = true;
      }
    }
    this._basicInfoElements.gpuValue.text = this._perf.log.gpu.toFixed(3);
    this._basicInfoElements.cpuValue.text = this._perf.log.cpu.toFixed(3);
    this._basicInfoElements.fpsValue.text = this._perf.log.fps.toFixed(0);
    this._basicInfoElements.callsValue.text = this._perf.threeRenderer.info.render.calls.toString();
    this._basicInfoElements.trianglesValue.text = this._perf.threeRenderer.info.render.triangles.toString();
    this._basicInfoElements.renderpassesValue.text = this._perf.renderPassesNumber.toString();
    this._memInfoElements.geometriesValue.text = this._perf.threeRenderer.info.memory.geometries.toString();
    this._memInfoElements.texturesValue.text = this._perf.threeRenderer.info.memory.textures.toString();
    this._memInfoElements.shadersValue.text = (_b2 = (_a2 = this._perf.threeRenderer.info.programs) == null ? void 0 : _a2.length.toString()) != null ? _b2 : "";
    this._memInfoElements.linesValue.text = this._perf.threeRenderer.info.render.lines.toString();
    this._memInfoElements.pointsValue.text = this._perf.threeRenderer.info.render.points.toString();
    this.render();
  }
  render() {
    this._renderer.render(this._scene, this._camera);
  }
  dispose() {
    this.wrapper.remove();
  }
  //
  toggleVisibility(value) {
    this.wrapper.style.display = value ? "block" : "none";
  }
  toggleCharts(value) {
    this._charts.forEach((chart) => {
      chart.visible = value;
    });
    if (this._perf.showGraph) {
      this.height = this._perf.memory ? 110 : 70;
    } else {
      this.height = this._perf.memory ? 70 : 40;
    }
    this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  toggleMemoryInfo(value) {
    for (const key2 in this._memInfoElements) {
      this._memInfoElements[key2].visible = value;
    }
    this.width = 380;
    if (this._perf.showGraph) {
      this.height = this._perf.memory ? 110 : 70;
    } else {
      this.height = this._perf.memory ? 70 : 40;
    }
    this.wrapper.style.width = this._perf.scale * this.width + "px";
    this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  setBackgroundOpacity(value) {
    this._backgroundOpacity = value;
    this._renderer.setClearColor(0, this._backgroundOpacity);
    this.render();
  }
  //
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._camera.right = value;
    this._camera.updateProjectionMatrix();
    this._renderer.setSize(
      this._perf.scale * this._width,
      this._perf.scale * this._height
    );
    this.render();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._camera.bottom = -value;
    this._camera.updateProjectionMatrix();
    this._renderer.setSize(
      this._perf.scale * this._width,
      this._perf.scale * this._height
    );
    this.render();
  }
};

// node_modules/three-perf/dist/GLPerf.mjs
var overLimitFps = {
  value: 0,
  fpsLimit: 60,
  isOverLimit: 0
};
var average = (arr) => (arr == null ? void 0 : arr.reduce((a, b) => a + b, 0)) / arr.length;
var GLPerf = class {
  //
  constructor(settings) {
    this.names = [""];
    this.finished = [];
    this.paused = false;
    this.overClock = false;
    this.queryHasResult = false;
    this.queryCreated = false;
    this.isWebGL2 = true;
    this.memAccums = [];
    this.gpuAccums = [];
    this.activeAccums = [];
    this.logsAccums = {
      mem: [],
      gpu: [],
      cpu: [],
      fps: [],
      fpsFixed: []
    };
    this.fpsChart = [];
    this.gpuChart = [];
    this.cpuChart = [];
    this.memChart = [];
    this.paramLogger = () => {
    };
    this.glFinish = () => {
    };
    this.chartLogger = () => {
    };
    this.chartLen = 60;
    this.logsPerSecond = 10;
    this.maxMemory = 1500;
    this.chartHz = 10;
    this.startCpuProfiling = false;
    this.lastCalculateFixed = 0;
    this.chartFrame = 0;
    this.gpuTimeProcess = 0;
    this.chartTime = 0;
    this.activeQueries = 0;
    this.circularId = 0;
    this.detected = 0;
    this.frameId = 0;
    this.rafId = 0;
    this.idleCbId = 0;
    this.checkQueryId = 0;
    this.uuid = void 0;
    this.currentCpu = 0;
    this.currentMem = 0;
    this.paramFrame = 0;
    this.paramTime = 0;
    this.now = () => {
    };
    this.t0 = 0;
    this.nextFps = (d) => {
      const goal = 1e3 / 60;
      const elapsed = goal - d.timeRemaining();
      const fps = goal * overLimitFps.fpsLimit / 10 / elapsed;
      if (fps < 0)
        return;
      overLimitFps.value = fps;
      if (overLimitFps.isOverLimit < 25) {
        overLimitFps.isOverLimit++;
      } else {
        this.perf.overclockingFps = true;
      }
    };
    this.nextFrame = (now3) => {
      this.frameId++;
      const t2 = now3 || this.now();
      let duration = t2 - this.paramTime;
      let gpu = 0;
      if (this.frameId <= 1) {
        this.paramFrame = this.frameId;
        this.paramTime = t2;
      } else {
        if (t2 >= this.paramTime) {
          this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0;
          const frameCount = this.frameId - this.paramFrame;
          const fpsFixed = frameCount * 1e3 / duration;
          const fps = this.perf.overclockingFps ? overLimitFps.value : fpsFixed;
          gpu = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / duration;
          if (this.isWebGL2) {
            this.gpuAccums[0] = 0;
          } else {
            Promise.all(this.finished).then(() => {
              this.gpuAccums[0] = 0;
              this.finished = [];
            });
          }
          this.currentMem = Math.round(window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0);
          if (window.performance && this.startCpuProfiling) {
            window.performance.mark("cpu-finished");
            const cpuMeasure = performance.measure("cpu-duration", "cpu-started", "cpu-finished");
            this.currentCpu = cpuMeasure.duration;
            this.logsAccums.cpu.push(this.currentCpu);
            this.startCpuProfiling = false;
          }
          this.logsAccums.mem.push(this.currentMem);
          this.logsAccums.fpsFixed.push(fpsFixed);
          this.logsAccums.fps.push(fps);
          this.logsAccums.gpu.push(gpu);
          if (this.overClock && typeof window.requestIdleCallback !== "undefined") {
            if (overLimitFps.isOverLimit > 0 && fps > fpsFixed) {
              overLimitFps.isOverLimit--;
            } else if (this.perf.overclockingFps) {
              this.perf.overclockingFps = false;
            }
          }
          if (t2 >= this.paramTime + 1e3 / this.logsPerSecond) {
            this.paramLogger({
              cpu: average(this.logsAccums.cpu),
              gpu: average(this.logsAccums.gpu),
              mem: average(this.logsAccums.mem),
              fps: average(this.logsAccums.fps),
              duration: Math.round(duration),
              maxMemory: this.maxMemory,
              frameCount
            });
            this.logsAccums.mem = [];
            this.logsAccums.fps = [];
            this.logsAccums.gpu = [];
            this.logsAccums.cpu = [];
            this.paramFrame = this.frameId;
            this.paramTime = t2;
          }
          if (this.overClock) {
            if (t2 - this.lastCalculateFixed >= 2 * 1e3) {
              this.lastCalculateFixed = now3;
              overLimitFps.fpsLimit = Math.round(average(this.logsAccums.fpsFixed) / 10) * 100;
              this.perf.fpsLimit = overLimitFps.fpsLimit / 10;
              this.logsAccums.fpsFixed = [];
              this.paramFrame = this.frameId;
              this.paramTime = t2;
            }
          }
        }
      }
      if (!this.detected || !this.chartFrame) {
        this.chartFrame = this.frameId;
        this.chartTime = t2;
        this.circularId = 0;
      } else {
        const timespan = t2 - this.chartTime;
        let hz = this.chartHz * timespan / 1e3;
        while (--hz > 0 && this.detected) {
          const frameCount = this.frameId - this.chartFrame;
          const fpsFixed = frameCount / timespan * 1e3;
          const fps = this.perf.overclockingFps ? overLimitFps.value : fpsFixed;
          this.fpsChart[this.circularId % this.chartLen] = fps;
          const memS = 1e3 / this.currentMem;
          const cpuS = this.currentCpu;
          const gpuS = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round(this.gpuAccums[1] / duration * 100)) + 4;
          if (gpuS > 0) {
            this.gpuChart[this.circularId % this.chartLen] = gpuS;
          }
          if (cpuS > 0) {
            this.cpuChart[this.circularId % this.chartLen] = cpuS;
          }
          if (memS > 0) {
            this.memChart[this.circularId % this.chartLen] = memS;
          }
          for (let i = 0; i < this.names.length; i++) {
            this.chartLogger({
              i,
              data: {
                fps: this.fpsChart,
                gpu: this.gpuChart,
                cpu: this.cpuChart,
                mem: this.memChart
              },
              circularId: this.circularId
            });
          }
          this.circularId++;
          this.chartFrame = this.frameId;
          this.chartTime = t2;
        }
      }
    };
    this.perf = settings.perf;
    this.trackGPU = settings.trackGPU;
    this.overClock = settings.overClock;
    this.logsPerSecond = settings.logsPerSecond;
    this.gl = settings.gl;
    this.paramLogger = settings.paramLogger;
    this.chartLogger = settings.chartLogger;
    window.GLPerf = window.GLPerf || {};
    this.fpsChart = new Array(this.chartLen).fill(0);
    this.gpuChart = new Array(this.chartLen).fill(0);
    this.cpuChart = new Array(this.chartLen).fill(0);
    this.memChart = new Array(this.chartLen).fill(0);
    this.now = () => window.performance && window.performance.now ? window.performance.now() : Date.now();
    this.initGpu();
    this.is120hz();
  }
  initGpu() {
    this.uuid = MathUtils.generateUUID();
    if (this.gl) {
      this.isWebGL2 = true;
      if (!this.extension) {
        this.extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
      }
      if (this.extension === null) {
        this.isWebGL2 = false;
      }
    }
  }
  /**
   * 120hz device detection
   */
  is120hz() {
    let n2 = 0;
    const loop = (t2) => {
      if (++n2 < 20) {
        this.rafId = window.requestAnimationFrame(loop);
      } else {
        this.detected = Math.ceil(1e3 * n2 / (t2 - this.t0) / 70);
        window.cancelAnimationFrame(this.rafId);
      }
      if (!this.t0)
        this.t0 = t2;
    };
    this.rafId = window.requestAnimationFrame(loop);
  }
  /**
   * Explicit UI add
   * @param { string | undefined } name
   */
  addUI(name) {
    if (this.names.indexOf(name) === -1) {
      this.names.push(name);
      this.gpuAccums.push(0);
      this.activeAccums.push(false);
    }
  }
  startGpu() {
    const gl = this.gl;
    const ext = this.extension;
    if (!gl || !ext)
      return;
    if (this.isWebGL2) {
      let available = false;
      let disjoint;
      let ns;
      if (this.query) {
        this.queryHasResult = false;
        let query = this.query;
        available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
        disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
        if (available && !disjoint) {
          ns = gl.getQueryParameter(this.query, gl.QUERY_RESULT);
          const ms = ns * 1e-6;
          if (available || disjoint) {
            gl.deleteQuery(this.query);
            query = null;
          }
          if (available && ms > 0) {
            if (!disjoint) {
              this.activeAccums.forEach((_active2, i) => {
                this.gpuAccums[i] = ms;
              });
            }
          }
        }
      }
      if (available || !this.query) {
        this.queryCreated = true;
        this.query = gl.createQuery();
        gl.beginQuery(ext.TIME_ELAPSED_EXT, this.query);
      }
    }
  }
  endGpu() {
    const ext = this.extension;
    const gl = this.gl;
    if (this.isWebGL2 && this.queryCreated && gl.getQuery(ext.TIME_ELAPSED_EXT, gl.CURRENT_QUERY)) {
      gl.endQuery(ext.TIME_ELAPSED_EXT);
    }
  }
  /**
   * Begin named measurement
   * @param { string | undefined } name
   */
  begin(name) {
    this.startGpu();
    this.updateAccums(name);
  }
  /**
   * End named measure
   * @param { string | undefined } name
   */
  end(name) {
    this.endGpu();
    this.updateAccums(name);
  }
  updateAccums(name) {
    let nameId = this.names.indexOf(name);
    if (nameId === -1) {
      nameId = this.names.length;
      this.addUI(name);
    }
    const t2 = this.now();
    this.activeAccums[nameId] = !this.activeAccums[nameId];
    this.t0 = t2;
  }
};

// node_modules/three-perf/dist/ThreePerf.mjs
var updateMatrixWorldTemp = Object3D.prototype.updateMatrixWorld;
var updateWorldMatrixTemp = Object3D.prototype.updateWorldMatrix;
var updateMatrixTemp = Object3D.prototype.updateMatrix;
var maxGl = ["calls", "triangles", "points", "lines"];
var maxLog = ["gpu", "cpu", "mem", "fps"];
var ThreePerf = class {
  //
  constructor(props) {
    var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
    this.gui = new import_tweakpane.Pane();
    this.accumulated = {
      totalFrames: 0,
      log: {
        i: 0,
        maxMemory: 0,
        gpu: 0,
        mem: 0,
        cpu: 0,
        fps: 0,
        duration: 0,
        frameCount: 0
      },
      gl: {
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
        counts: 0
      },
      max: {
        log: {
          i: 0,
          maxMemory: 0,
          gpu: 0,
          mem: 0,
          cpu: 0,
          fps: 0,
          duration: 0,
          frameCount: 0
        },
        gl: {
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
          counts: 0
        }
      }
    };
    this.renderPassesNumber = 0;
    this._keypressed = "";
    this._guiVisible = true;
    this.actionToCallUI = "dev";
    this.keypressHandler = (event) => {
      if (!this.actionToCallUI)
        return;
      this._keypressed += event.key;
      const keys = this._keypressed.split("");
      while (keys.length > this.actionToCallUI.length) {
        keys.shift();
      }
      if (keys.join("") === this.actionToCallUI) {
        this._keypressed = "";
        this.guiVisible = !this.guiVisible;
      }
    };
    this.afterRender = () => {
      if (!this._enabled)
        return;
      if (!this.perfEngine.paused) {
        this.perfEngine.nextFrame(window.performance.now());
        if (this.perfEngine.overClock && typeof window.requestIdleCallback !== "undefined") {
          this.perfEngine.idleCbId = requestIdleCallback(this.perfEngine.nextFps);
        }
      }
      if (this.perfEngine) {
        this.perfEngine.end("profiler");
      }
      if (window.performance) {
        window.performance.mark("cpu-started");
        this.perfEngine.startCpuProfiling = true;
      }
      if (this.deepAnalyze) {
      }
    };
    this.deepAnalyze = (_a2 = props.deepAnalyze) != null ? _a2 : false;
    this.threeRenderer = props.renderer;
    this.ui = new ThreePerfUI({
      perf: this,
      domElement: props.domElement,
      backgroundOpacity: props.backgroundOpacity
    });
    this._visible = (_b2 = props.visible) != null ? _b2 : true;
    this._enabled = (_c = props.enabled) != null ? _c : true;
    this.scale = (_d = props.scale) != null ? _d : 1;
    this.anchorX = (_e2 = props.anchorX) != null ? _e2 : "left";
    this.anchorY = (_f = props.anchorY) != null ? _f : "top";
    this.showGraph = (_g = props.showGraph) != null ? _g : true;
    this.memory = (_h = props.memory) != null ? _h : true;
    this.actionToCallUI = (_i = props.actionToCallUI) != null ? _i : "";
    this.guiVisible = (_j = props.guiVisible) != null ? _j : false;
    this.gui.element.parentElement.style.width = "300px";
    window.addEventListener("keypress", this.keypressHandler);
    const overClock = (_k = props.overClock) != null ? _k : true;
    this.perfEngine = new GLPerf({
      perf: this,
      trackGPU: true,
      overClock,
      chartLen: 120,
      // chart ? chart.length : 120,
      chartHz: 60,
      // chart ? chart.hz : 60,
      logsPerSecond: (_l = props.logsPerSecond) != null ? _l : 10,
      gl: props.renderer.getContext(),
      chartLogger: (chart) => {
        this.chart = chart;
      },
      paramLogger: (logger) => {
        if (!this._enabled)
          return;
        const log = {
          maxMemory: logger.maxMemory,
          gpu: logger.gpu,
          cpu: logger.cpu,
          mem: logger.mem,
          fps: logger.fps,
          totalTime: logger.duration,
          frameCount: logger.frameCount
        };
        this.log = log;
        const accumulated = this.accumulated;
        const glRender = this.threeRenderer.info.render;
        accumulated.totalFrames++;
        accumulated.gl.calls += glRender.calls;
        accumulated.gl.triangles += glRender.triangles;
        accumulated.gl.points += glRender.points;
        accumulated.gl.lines += glRender.lines;
        accumulated.log.gpu += logger.gpu;
        accumulated.log.cpu += logger.cpu;
        accumulated.log.mem += logger.mem;
        accumulated.log.fps += logger.fps;
        for (let i = 0; i < maxGl.length; i++) {
          const key2 = maxGl[i];
          const value = glRender[key2];
          if (value > accumulated.max.gl[key2]) {
            accumulated.max.gl[key2] = value;
          }
        }
        for (let i = 0; i < maxLog.length; i++) {
          const key2 = maxLog[i];
          const value = logger[key2];
          if (value > accumulated.max.log[key2]) {
            accumulated.max.log[key2] = value;
          }
        }
        this.accumulated = accumulated;
        this.ui.update();
      }
    });
    const ctx = props.renderer.getContext();
    let glRenderer = null;
    let glVendor = null;
    const rendererInfo = ctx.getExtension("WEBGL_debug_renderer_info");
    const glVersion = ctx.getParameter(ctx.VERSION);
    if (rendererInfo != null) {
      glRenderer = ctx.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      glVendor = ctx.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!glVendor) {
      glVendor = "Unknown vendor";
    }
    if (!glRenderer) {
      glRenderer = ctx.getParameter(ctx.RENDERER);
    }
    this.startTime = performance.now();
    this.infos = {
      version: glVersion,
      renderer: glRenderer,
      vendor: glVendor
    };
    this.rendererRender = this.threeRenderer.render;
    this.threeRenderer.info.autoReset = false;
    this.threeRenderer.render = (scene, camera) => {
      this.renderPassesNumber++;
      this.rendererRender.call(this.threeRenderer, scene, camera);
    };
    this.guiFolder = this.gui.addFolder({ title: "Settings" });
    const perfFolder = this.guiFolder.addFolder({ title: "ThreePerf" });
    perfFolder.addInput(this, "visible", { label: "Visible" });
    perfFolder.addInput(this, "enabled", { label: "Enabled" });
    perfFolder.addInput(this, "anchorX", {
      label: "xAnchor",
      options: { left: "left", right: "right" }
    });
    perfFolder.addInput(this, "anchorY", {
      label: "yAnchor",
      options: { top: "top", bottom: "bottom" }
    });
    perfFolder.addInput(this, "backgroundOpacity", {
      label: "Background opacity",
      min: 0,
      max: 1,
      step: 0.1
    });
    perfFolder.addInput(this, "memory", { label: "Memory" });
    perfFolder.addInput(this, "showGraph", { label: "Charts" });
    perfFolder.addInput(this, "scale", {
      label: "Scale",
      min: 0.1,
      max: 2,
      step: 0.1
    });
    perfFolder.addInput(this, "logsPerSecond", {
      label: "LogsPerSecond",
      min: 1,
      max: 60,
      step: 1
    });
    console.log("ThreePerf inited.");
  }
  begin() {
    this.perfEngine.begin("profiler");
  }
  end() {
    this.afterRender();
    this.renderPassesNumber = 0;
    this.threeRenderer.info.reset();
  }
  dispose() {
    var _a2;
    this.ui.dispose();
    (_a2 = this.gui.element.parentElement) == null ? void 0 : _a2.remove();
    window.removeEventListener("keypress", this.keypressHandler);
  }
  //
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.ui.toggleVisibility(value);
  }
  get guiVisible() {
    return this._guiVisible;
  }
  set guiVisible(value) {
    this._guiVisible = value;
    this.gui.element.parentElement.style["display"] = value ? "block" : "none";
  }
  get anchorX() {
    return this._anchorX;
  }
  set anchorX(value) {
    this._anchorX = value;
    if (this._anchorX === "left") {
      this.ui.wrapper.style.left = "0";
      this.ui.wrapper.style.right = "";
    } else {
      this.ui.wrapper.style.left = "";
      this.ui.wrapper.style.right = "0";
    }
  }
  get anchorY() {
    return this._anchorY;
  }
  set anchorY(value) {
    this._anchorY = value;
    if (this._anchorY === "top") {
      this.ui.wrapper.style.top = "0";
      this.ui.wrapper.style.bottom = "";
    } else {
      this.ui.wrapper.style.top = "";
      this.ui.wrapper.style.bottom = "0";
    }
  }
  get showGraph() {
    return this._showGraph;
  }
  set showGraph(value) {
    this._showGraph = value;
    this.ui.toggleCharts(value);
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    this._memory = value;
    this.ui.toggleMemoryInfo(value);
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    this._scale = value;
    this.ui.setScale(value);
  }
  get logsPerSecond() {
    return this.perfEngine.logsPerSecond;
  }
  set logsPerSecond(value) {
    this.perfEngine.logsPerSecond = value;
  }
  get backgroundOpacity() {
    return this.ui._backgroundOpacity;
  }
  set backgroundOpacity(value) {
    this.ui.setBackgroundOpacity(value);
  }
};

// node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte
mark_module_start();
PerfMonitor[FILENAME] = "node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte";
function PerfMonitor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PerfMonitor);
  let domElement = prop($$props, "domElement", 19, () => document.body), logsPerSecond = prop($$props, "logsPerSecond", 3, 10), showGraph = prop($$props, "showGraph", 3, true), memory = prop($$props, "memory", 3, true), enabled = prop($$props, "enabled", 3, true), visible = prop($$props, "visible", 3, true), actionToCallUI = prop($$props, "actionToCallUI", 3, ""), guiVisible = prop($$props, "guiVisible", 3, false), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0.7), scale = prop($$props, "scale", 3, 1), anchorX = prop($$props, "anchorX", 3, "left"), anchorY = prop($$props, "anchorY", 3, "top");
  const { renderer, renderStage, mainStage } = useThrelte();
  let perf;
  user_pre_effect(() => {
    domElement();
    perf == null ? void 0 : perf.dispose();
    perf = new ThreePerf({ domElement: domElement(), renderer });
  });
  user_pre_effect(() => {
    perf.logsPerSecond = logsPerSecond();
    perf.showGraph = showGraph();
    perf.memory = memory();
    perf.enabled = enabled();
    perf.visible = visible();
    perf.actionToCallUI = actionToCallUI();
    perf.guiVisible = guiVisible();
    perf.backgroundOpacity = backgroundOpacity();
    perf.scale = scale();
    perf.anchorX = anchorX();
    perf.anchorY = anchorY();
  });
  useTask(
    () => {
      perf.begin();
    },
    {
      stage: useStage("monitor-begin", { before: mainStage })
    }
  );
  useTask(
    () => {
      perf.end();
    },
    {
      stage: useStage("monitor-end", { after: renderStage })
    }
  );
  onDestroy(() => {
    if (perf) perf.dispose();
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PerfMonitor = hmr(PerfMonitor, () => PerfMonitor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PerfMonitor[HMR].source;
    set(PerfMonitor[HMR].source, module.default[HMR].original);
  });
}
var PerfMonitor_default = PerfMonitor;
mark_module_end(PerfMonitor);

// node_modules/@threlte/extras/dist/components/Outlines/shaders.js
var vertexShader7 = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`;
var fragmentShader7 = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
}
`;

// node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte
mark_module_start();
Outlines[FILENAME] = "node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte";
var root_22 = add_locations(template(`<!> <!>`, 1), Outlines[FILENAME], []);
var root_16 = add_locations(template(`<!> <!>`, 1), Outlines[FILENAME], []);
function Outlines($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Outlines);
  let color2 = prop($$props, "color", 3, "black"), screenspace = prop($$props, "screenspace", 3, false), opacity = prop($$props, "opacity", 3, 1), transparent = prop($$props, "transparent", 3, false), thickness = prop($$props, "thickness", 3, 0.05), toneMapped = prop($$props, "toneMapped", 3, true), angle = prop($$props, "angle", 19, () => Math.PI), polygonOffset = prop($$props, "polygonOffset", 3, false), polygonOffsetFactor = prop($$props, "polygonOffsetFactor", 3, 0), renderOrder = prop($$props, "renderOrder", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "screenspace",
      "opacity",
      "transparent",
      "thickness",
      "toneMapped",
      "angle",
      "polygonOffset",
      "polygonOffsetFactor",
      "renderOrder",
      "children",
      "ref"
    ],
    "props"
  );
  const { renderer } = useThrelte();
  const uniforms = {
    screenspace: { value: screenspace() },
    color: { value: new Color(color2()) },
    opacity: { value: opacity() },
    thickness: { value: thickness() },
    size: { value: new Vector2() }
  };
  const group = new Group();
  const material = new ShaderMaterial({
    side: BackSide,
    uniforms,
    vertexShader: vertexShader7,
    fragmentShader: fragmentShader7
  });
  const parent = useParent();
  let parentMesh = fromStore(parent);
  let geometry = derived(() => {
    if (!isInstanceOf(parentMesh.current, "Mesh")) return void 0;
    return toCreasedNormals(parentMesh.current.geometry, angle());
  });
  let mesh = derived(() => {
    if (!isInstanceOf(parentMesh.current, "Mesh")) return;
    if (isInstanceOf(parentMesh.current, "SkinnedMesh")) {
      const nextMesh = new SkinnedMesh();
      nextMesh.bind(parentMesh.current.skeleton, parentMesh.current.bindMatrix);
      return nextMesh;
    } else if (isInstanceOf(parentMesh.current, "InstancedMesh")) {
      const nextMesh = new InstancedMesh(void 0, void 0, parentMesh.current.count);
      nextMesh.instanceMatrix = parentMesh.current.instanceMatrix;
      return nextMesh;
    }
    return new Mesh();
  });
  user_pre_effect(() => {
    if (get(mesh)) get(mesh).renderOrder = renderOrder();
  });
  user_pre_effect(() => {
    material.transparent = transparent();
  });
  user_pre_effect(() => {
    material.toneMapped = toneMapped();
  });
  user_pre_effect(() => {
    material.polygonOffset = polygonOffset();
  });
  user_pre_effect(() => {
    material.polygonOffsetFactor = polygonOffsetFactor();
  });
  user_pre_effect(() => {
    material.uniforms.screenspace.value = screenspace();
  });
  user_pre_effect(() => {
    material.uniforms.color.value.set(color2());
  });
  user_pre_effect(() => {
    material.uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    material.uniforms.thickness.value = thickness();
  });
  user_pre_effect(() => {
    renderer.getDrawingBufferSize(material.uniforms.size.value);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Outlines, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_16();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          get is() {
            return get(mesh);
          },
          children: wrap_snippet(Outlines, ($$anchor3, $$slotProps2) => {
            var fragment_2 = root_22();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              get is() {
                return get(geometry);
              }
            });
            var node_3 = sibling(node_2, 2);
            T(node_3, { is: material });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        var node_4 = sibling(node_1, 2);
        snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Outlines = hmr(Outlines, () => Outlines[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Outlines[HMR].source;
    set(Outlines[HMR].source, module.default[HMR].original);
  });
}
var Outlines_default = Outlines;
mark_module_end(Outlines);

// node_modules/@threlte/extras/dist/components/Mask/Mask.svelte
mark_module_start();
Mask[FILENAME] = "node_modules/@threlte/extras/dist/components/Mask/Mask.svelte";
function Mask($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mask);
  let id = prop($$props, "id", 3, 1), colorWrite = prop($$props, "colorWrite", 3, false), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "colorWrite",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh();
  user_effect(() => {
    const { material } = mesh;
    if (Array.isArray(material)) return;
    material.colorWrite = colorWrite();
    material.depthWrite = depthWrite();
    material.stencilWrite = true;
    material.stencilRef = id();
    material.stencilFunc = AlwaysStencilFunc;
    material.stencilFail = ReplaceStencilOp;
    material.stencilZFail = ReplaceStencilOp;
    material.stencilZPass = ReplaceStencilOp;
  });
  var fragment = comment();
  var node = first_child(fragment);
  var renderOrder = derived(() => -id());
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: mesh,
        get renderOrder() {
          return get(renderOrder);
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(Mask, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mask = hmr(Mask, () => Mask[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mask[HMR].source;
    set(Mask[HMR].source, module.default[HMR].original);
  });
}
var Mask_default = Mask;
mark_module_end(Mask);

// node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte
mark_module_start();
BakeShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte";
function BakeShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BakeShadows);
  const suspended = fromStore(useSuspense().suspended);
  const { renderer } = useThrelte();
  user_effect(() => {
    if (!suspended.current) {
      renderer.shadowMap.autoUpdate = false;
      renderer.shadowMap.needsUpdate = true;
    }
    return () => {
      renderer.shadowMap.autoUpdate = true;
      renderer.shadowMap.needsUpdate = true;
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BakeShadows = hmr(BakeShadows, () => BakeShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BakeShadows[HMR].source;
    set(BakeShadows[HMR].source, module.default[HMR].original);
  });
}
var BakeShadows_default = BakeShadows;
mark_module_end(BakeShadows);

// node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte
mark_module_start();
Detailed[FILENAME] = "node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte";
function Detailed($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Detailed);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const lod = new LOD();
  injectPlugin("detailed", (args) => {
    const parent = useParent();
    if (strict_equals(parent.current, lod, false)) return;
    let previousRef;
    let previousDistance = args.props.distance;
    let previousHysteresis = args.props.hysteresis;
    const ref2 = derived(() => isInstanceOf(args.ref, "Object3D") ? args.ref : void 0);
    const distance = derived(() => args.props.distance ?? 0);
    const hysteresis = derived(() => args.props.hysteresis ?? 0);
    const addLevel = (ref3, distance2, hysteresis2) => {
      lod.addLevel(ref3, distance2, hysteresis2);
    };
    const removeLevel = (ref3) => {
      const i = lod.levels.findIndex((l) => strict_equals(l.object, ref3));
      if (i > -1) {
        lod.levels.splice(i, 1);
      }
    };
    const mutateLevel = (ref3, distance2, hysteresis2) => {
      untrack(() => {
        const level = lod.levels.find((l) => strict_equals(l.object, ref3));
        if (!level) return;
        level.distance = distance2;
        level.hysteresis = hysteresis2;
      });
    };
    observe.pre(
      () => [
        get(ref2),
        get(distance),
        get(hysteresis)
      ],
      ([ref3, distance2, hysteresis2]) => {
        if (strict_equals(ref3, previousRef, false)) {
          if (previousRef) removeLevel(previousRef);
          if (ref3) addLevel(ref3, distance2, hysteresis2);
          previousRef = ref3;
        }
        if (ref3 && (strict_equals(distance2, previousDistance, false) || strict_equals(hysteresis2, previousHysteresis, false))) {
          mutateLevel(ref3, distance2, hysteresis2);
          previousDistance = distance2;
          previousHysteresis = hysteresis2;
        }
      }
    );
    onDestroy(() => {
      if (get(ref2)) removeLevel(get(ref2));
    });
    return { pluginProps: ["distance", "hysteresis"] };
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: lod }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Detailed, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: lod }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Detailed = hmr(Detailed, () => Detailed[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Detailed[HMR].source;
    set(Detailed[HMR].source, module.default[HMR].original);
  });
}
var Detailed_default = Detailed;
mark_module_end(Detailed);

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/fragment.js
var fragmentShader8 = `void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	discard;
}
`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/vertex.js
var vertexShader8 = `void main() {}`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte
mark_module_start();
MeshDiscardMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte";
function MeshDiscardMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshDiscardMaterial);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "ref"
    ],
    "props"
  );
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => T.ShaderMaterial, ($$anchor2, $$component) => {
    {
      add_owner_effect(ref, $$component);
      $$component($$anchor2, spread_props({ fragmentShader: fragmentShader8, vertexShader: vertexShader8 }, () => props, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(MeshDiscardMaterial, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, ref);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshDiscardMaterial = hmr(MeshDiscardMaterial, () => MeshDiscardMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshDiscardMaterial[HMR].source;
    set(MeshDiscardMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshDiscardMaterial_default = MeshDiscardMaterial;
mark_module_end(MeshDiscardMaterial);

// node_modules/@threlte/extras/dist/components/Resize/Resize.svelte
mark_module_start();
Resize[FILENAME] = "node_modules/@threlte/extras/dist/components/Resize/Resize.svelte";
var _box = new Box3();
function Resize($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Resize);
  const { renderStage } = useThrelte();
  let auto = prop($$props, "auto", 3, false), box = prop($$props, "box", 3, _box), stage = prop($$props, "stage", 19, () => useStage("<Resize>", { before: renderStage })), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "axis",
      "auto",
      "box",
      "precise",
      "onresize",
      "stage",
      "ref",
      "children"
    ],
    "props"
  );
  ref(new Group());
  const inner = new Group();
  const outer = new Group();
  const doResize = () => {
    var _a2;
    outer.matrixWorld.identity();
    const { max: max2, min } = box().setFromObject(inner, $$props.precise);
    const width = max2.x - min.x;
    const height = max2.y - min.y;
    const depth = max2.z - min.z;
    const denominator = strict_equals($$props.axis, "x") ? width : strict_equals($$props.axis, "y") ? height : strict_equals($$props.axis, "z") ? depth : Math.max(width, height, depth);
    outer.scale.setScalar(1 / denominator);
    (_a2 = $$props.onresize) == null ? void 0 : _a2.call($$props);
  };
  const { start: scheduleResizing, stop } = useTask(
    () => {
      doResize();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const resize = scheduleResizing;
  observe(() => [$$props.axis, $$props.precise], scheduleResizing);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleResizing();
      return () => {
        if (auto()) scheduleResizing();
      };
    });
  };
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props(
    {
      get is() {
        return ref();
      }
    },
    () => props,
    {
      children: wrap_snippet(Resize, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: outer,
          children: wrap_snippet(Resize, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: inner,
              children: wrap_snippet(Resize, ($$anchor4, $$slotProps3) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                InjectPlugin_default(node_3, {
                  name: "resize",
                  plugin,
                  children: wrap_snippet(Resize, ($$anchor5, $$slotProps4) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    snippet(node_4, () => $$props.children ?? noop, () => ({ ref: ref(), resize: scheduleResizing }));
                    append($$anchor5, fragment_4);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({
    get resize() {
      return resize;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Resize = hmr(Resize, () => Resize[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Resize[HMR].source;
    set(Resize[HMR].source, module.default[HMR].original);
  });
}
var Resize_default = Resize;
mark_module_end(Resize);

// node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte
mark_module_start();
CubeCamera2[FILENAME] = "node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte";
var root_17 = add_locations(template(`<!> <!>`, 1), CubeCamera2[FILENAME], []);
function CubeCamera2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CubeCamera2);
  const [$$stores, $$cleanup] = setup_stores();
  const $started = () => (validate_store(started, "started"), store_get(started, "$started", $$stores));
  let background = prop($$props, "background", 3, "auto"), far = prop($$props, "far", 3, 1e3), fog = prop($$props, "fog", 3, "auto"), frames = prop($$props, "frames", 3, Infinity), near = prop($$props, "near", 3, 0.1), resolution = prop($$props, "resolution", 3, 256), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "background",
      "far",
      "fog",
      "frames",
      "near",
      "onupdatestart",
      "onupdatestop",
      "resolution",
      "children",
      "ref"
    ],
    "props"
  );
  const { camera, renderTarget } = useCubeCamera(() => near(), () => far(), () => resolution());
  const { renderer, scene } = useThrelte();
  const group = new Group();
  const inner = new Group();
  let count = 0;
  const update = () => {
    var _a2;
    if (count < frames()) {
      inner.visible = false;
      const originalFog = scene.fog;
      const originalBackground = scene.background;
      scene.background = strict_equals(background(), "auto") ? originalBackground : background();
      scene.fog = strict_equals(fog(), "auto") ? originalFog : fog();
      camera.update(renderer, scene);
      scene.background = originalBackground;
      scene.fog = originalFog;
      inner.visible = true;
      count += 1;
    } else {
      stop();
      (_a2 = $$props.onupdatestop) == null ? void 0 : _a2.call($$props);
    }
  };
  const { start, stop, started } = useTask(update, { autoStart: false });
  const restart = () => {
    var _a2, _b2;
    if ($started()) {
      stop();
      (_a2 = $$props.onupdatestop) == null ? void 0 : _a2.call($$props);
    }
    count = 0;
    start();
    (_b2 = $$props.onupdatestart) == null ? void 0 : _b2.call($$props);
  };
  observe(
    () => [
      background(),
      far(),
      near(),
      fog(),
      frames(),
      resolution()
    ],
    restart
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(CubeCamera2, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_17();
        var node_1 = first_child(fragment_1);
        T(node_1, { is: camera });
        var node_2 = sibling(node_1, 2);
        T(node_2, {
          is: inner,
          children: wrap_snippet(CubeCamera2, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children ?? noop, () => ({
              camera,
              ref: group,
              renderTarget,
              restart,
              update
            }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  var $$pop = pop({
    get camera() {
      return camera;
    },
    get renderTarget() {
      return renderTarget;
    },
    get update() {
      return update;
    },
    get restart() {
      return restart;
    },
    ...legacy_api()
  });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  CubeCamera2 = hmr(CubeCamera2, () => CubeCamera2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubeCamera2[HMR].source;
    set(CubeCamera2[HMR].source, module.default[HMR].original);
  });
}
var CubeCamera_default = CubeCamera2;
mark_module_end(CubeCamera2);

// node_modules/@threlte/extras/dist/components/GradientTexture/common.js
var applyGradient = (context, gradient) => {
  context.save();
  let lastFillStyle = context.fillStyle;
  context.fillStyle = gradient;
  context.fillRect(0, 0, context.canvas.width, context.canvas.height);
  context.fillStyle = lastFillStyle;
  context.restore();
};
var color = new Color();
var addStops = (gradient, stops = []) => {
  for (const stop of stops) {
    gradient.addColorStop(stop.offset, color.set(stop.color).getStyle());
  }
  return gradient;
};

// node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte
mark_module_start();
LinearGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte";
function LinearGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinearGradientTexture);
  let width = prop($$props, "width", 3, 1024), height = prop($$props, "height", 3, 1024), startX = prop($$props, "startX", 3, 0), startY = prop($$props, "startY", 3, 0), endX = prop($$props, "endX", 3, 0), endY = prop($$props, "endY", 19, height), stops = prop($$props, "stops", 19, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "startX",
      "startY",
      "endX",
      "endY",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  const texture = new CanvasTexture(canvas);
  user_pre_effect(() => {
    canvas.width = width();
  });
  user_pre_effect(() => {
    canvas.height = height();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  const gradient = derived(() => {
    const gradient2 = context == null ? void 0 : context.createLinearGradient(startX(), startY(), endX(), endY());
    if (strict_equals(gradient2, void 0, false)) {
      addStops(gradient2, stops());
    }
    return gradient2;
  });
  const { invalidate } = useThrelte();
  user_effect(() => {
    if (strict_equals(get(gradient), void 0, false) && strict_equals(context, null, false)) {
      applyGradient(context, get(gradient));
      texture.needsUpdate = true;
      invalidate();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: texture,
        get attach() {
          return attach();
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(LinearGradientTexture, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinearGradientTexture = hmr(LinearGradientTexture, () => LinearGradientTexture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinearGradientTexture[HMR].source;
    set(LinearGradientTexture[HMR].source, module.default[HMR].original);
  });
}
var LinearGradientTexture_default = LinearGradientTexture;
mark_module_end(LinearGradientTexture);

// node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte
mark_module_start();
RadialGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte";
function RadialGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RadialGradientTexture);
  let width = prop($$props, "width", 3, 1024), height = prop($$props, "height", 3, 1024), innerRadius = prop($$props, "innerRadius", 3, 0), outerRadius = prop($$props, "outerRadius", 3, "auto"), stops = prop($$props, "stops", 19, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "innerRadius",
      "outerRadius",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  const texture = new CanvasTexture(canvas);
  user_pre_effect(() => {
    canvas.width = width();
  });
  user_pre_effect(() => {
    canvas.height = height();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  let canvasCenterX = derived(() => 0.5 * width());
  let canvasCenterY = derived(() => 0.5 * height());
  const gradient = derived(() => {
    const gradient2 = context == null ? void 0 : context.createRadialGradient(get(canvasCenterX), get(canvasCenterY), innerRadius(), get(canvasCenterX), get(canvasCenterY), strict_equals(outerRadius(), "auto") ? Math.hypot(get(canvasCenterX), get(canvasCenterY)) : outerRadius());
    if (strict_equals(gradient2, void 0, false)) {
      addStops(gradient2, stops());
    }
    return gradient2;
  });
  const { invalidate } = useThrelte();
  user_effect(() => {
    if (strict_equals(get(gradient), void 0, false) && strict_equals(context, null, false)) {
      applyGradient(context, get(gradient));
      texture.needsUpdate = true;
      invalidate();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: texture }, () => props, {
      get attach() {
        return attach();
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(RadialGradientTexture, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RadialGradientTexture = hmr(RadialGradientTexture, () => RadialGradientTexture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadialGradientTexture[HMR].source;
    set(RadialGradientTexture[HMR].source, module.default[HMR].original);
  });
}
var RadialGradientTexture_default = RadialGradientTexture;
mark_module_end(RadialGradientTexture);

// node_modules/@threlte/extras/dist/components/View/OffscreenObserver.svelte.js
var _isOffscreen;
var OffscreenObserver = class {
  constructor(getElement) {
    __privateAdd(this, _isOffscreen, state(false));
    observe(() => [getElement()], ([element2]) => {
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          this.isOffscreen = !entry.isIntersecting;
        }
      });
      observer.observe(element2);
      return () => {
        observer.disconnect();
      };
    });
  }
  get isOffscreen() {
    return get(__privateGet(this, _isOffscreen));
  }
  set isOffscreen(value) {
    set(__privateGet(this, _isOffscreen), proxy(value, null, __privateGet(this, _isOffscreen)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isOffscreen)), owner, false);
  }
};
_isOffscreen = new WeakMap();

// node_modules/@threlte/extras/dist/components/View/InnerView.svelte
mark_module_start();
InnerView[FILENAME] = "node_modules/@threlte/extras/dist/components/View/InnerView.svelte";
function InnerView($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InnerView);
  const offscreenObserver = new OffscreenObserver(() => $$props.dom);
  const parentContext = useThrelte();
  createDOMContext({
    dom: $$props.dom,
    canvas: parentContext.canvas
  });
  createCacheContext();
  const { scene } = createSceneContext();
  createParentContext(scene);
  createParentObject3DContext(scene);
  const { camera } = createCameraContext();
  createUserContext();
  const { renderer, renderStage, canvas } = useThrelte();
  const originalViewport = new Vector4();
  const originalScissor = new Vector4();
  let originalScissorTest;
  const { start, stop } = useTask(
    Symbol("<View>"),
    () => {
      if (offscreenObserver.isOffscreen) return;
      const {
        left: trackLeft,
        bottom: trackBottom,
        width,
        height
      } = $$props.dom.getBoundingClientRect();
      const { bottom: canvasBottom, left: canvasLeft } = canvas.getBoundingClientRect();
      const bottom = canvasBottom - trackBottom;
      const left = trackLeft - canvasLeft;
      renderer.getScissor(originalScissor);
      renderer.getViewport(originalViewport);
      originalScissorTest = renderer.getScissorTest();
      renderer.setViewport(left, bottom, width, height);
      renderer.setScissor(left, bottom, width, height);
      renderer.setScissorTest(true);
      renderer.render(scene, camera.current);
      renderer.setViewport(originalViewport);
      renderer.setScissor(originalScissor);
      renderer.setScissorTest(originalScissorTest);
    },
    { stage: renderStage, autoStart: false }
  );
  user_effect(() => {
    if (offscreenObserver.isOffscreen) {
      stop();
    } else {
      start();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InnerView = hmr(InnerView, () => InnerView[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InnerView[HMR].source;
    set(InnerView[HMR].source, module.default[HMR].original);
  });
}
var InnerView_default = InnerView;
mark_module_end(InnerView);

// node_modules/@threlte/extras/dist/components/View/View.svelte
mark_module_start();
View[FILENAME] = "node_modules/@threlte/extras/dist/components/View/View.svelte";
function View($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, View);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      InnerView_default(node_1, {
        get dom() {
          return $$props.dom;
        },
        children: wrap_snippet(View, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($$props.dom) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  View = hmr(View, () => View[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = View[HMR].source;
    set(View[HMR].source, module.default[HMR].original);
  });
}
var View_default = View;
mark_module_end(View);

// node_modules/three/examples/jsm/effects/AsciiEffect.js
var AsciiEffect = class {
  constructor(renderer, charSet = " .:-=+*#%@", options = {}) {
    const fResolution = options["resolution"] || 0.15;
    const iScale = options["scale"] || 1;
    const bColor = options["color"] || false;
    const bAlpha = options["alpha"] || false;
    const bBlock = options["block"] || false;
    const bInvert = options["invert"] || false;
    const strResolution = options["strResolution"] || "low";
    let width, height;
    const domElement = document.createElement("div");
    domElement.style.cursor = "default";
    const oAscii = document.createElement("table");
    domElement.appendChild(oAscii);
    let iWidth, iHeight;
    let oImg;
    this.setSize = function(w, h) {
      width = w;
      height = h;
      renderer.setSize(w, h);
      initAsciiSize();
    };
    this.render = function(scene, camera) {
      renderer.render(scene, camera);
      asciifyImage(oAscii);
    };
    this.domElement = domElement;
    function initAsciiSize() {
      iWidth = Math.floor(width * fResolution);
      iHeight = Math.floor(height * fResolution);
      oCanvas.width = iWidth;
      oCanvas.height = iHeight;
      oImg = renderer.domElement;
      if (oImg.style.backgroundColor) {
        oAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;
        oAscii.rows[0].cells[0].style.color = oImg.style.color;
      }
      oAscii.cellSpacing = 0;
      oAscii.cellPadding = 0;
      const oStyle = oAscii.style;
      oStyle.whiteSpace = "pre";
      oStyle.margin = "0px";
      oStyle.padding = "0px";
      oStyle.letterSpacing = fLetterSpacing + "px";
      oStyle.fontFamily = strFont;
      oStyle.fontSize = fFontSize + "px";
      oStyle.lineHeight = fLineHeight + "px";
      oStyle.textAlign = "left";
      oStyle.textDecoration = "none";
    }
    const aDefaultCharList = " .,:;i1tfLCG08@".split("");
    const aDefaultColorCharList = " CGO08@".split("");
    const strFont = "courier new, monospace";
    const oCanvasImg = renderer.domElement;
    const oCanvas = document.createElement("canvas");
    if (!oCanvas.getContext) {
      return;
    }
    const oCtx = oCanvas.getContext("2d");
    if (!oCtx.getImageData) {
      return;
    }
    let aCharList = bColor ? aDefaultColorCharList : aDefaultCharList;
    if (charSet) aCharList = charSet;
    const fFontSize = 2 / fResolution * iScale;
    const fLineHeight = 2 / fResolution * iScale;
    let fLetterSpacing = 0;
    if (strResolution == "low") {
      switch (iScale) {
        case 1:
          fLetterSpacing = -1;
          break;
        case 2:
        case 3:
          fLetterSpacing = -2.1;
          break;
        case 4:
          fLetterSpacing = -3.1;
          break;
        case 5:
          fLetterSpacing = -4.15;
          break;
      }
    }
    if (strResolution == "medium") {
      switch (iScale) {
        case 1:
          fLetterSpacing = 0;
          break;
        case 2:
          fLetterSpacing = -1;
          break;
        case 3:
          fLetterSpacing = -1.04;
          break;
        case 4:
        case 5:
          fLetterSpacing = -2.1;
          break;
      }
    }
    if (strResolution == "high") {
      switch (iScale) {
        case 1:
        case 2:
          fLetterSpacing = 0;
          break;
        case 3:
        case 4:
        case 5:
          fLetterSpacing = -1;
          break;
      }
    }
    function asciifyImage(oAscii2) {
      oCtx.clearRect(0, 0, iWidth, iHeight);
      oCtx.drawImage(oCanvasImg, 0, 0, iWidth, iHeight);
      const oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;
      let strChars = "";
      for (let y2 = 0; y2 < iHeight; y2 += 2) {
        for (let x = 0; x < iWidth; x++) {
          const iOffset = (y2 * iWidth + x) * 4;
          const iRed = oImgData[iOffset];
          const iGreen = oImgData[iOffset + 1];
          const iBlue = oImgData[iOffset + 2];
          const iAlpha = oImgData[iOffset + 3];
          let iCharIdx;
          let fBrightness;
          fBrightness = (0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue) / 255;
          if (iAlpha == 0) {
            fBrightness = 1;
          }
          iCharIdx = Math.floor((1 - fBrightness) * (aCharList.length - 1));
          if (bInvert) {
            iCharIdx = aCharList.length - iCharIdx - 1;
          }
          let strThisChar = aCharList[iCharIdx];
          if (strThisChar === void 0 || strThisChar == " ")
            strThisChar = "&nbsp;";
          if (bColor) {
            strChars += "<span style='color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");" + (bBlock ? "background-color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");" : "") + (bAlpha ? "opacity:" + iAlpha / 255 + ";" : "") + "'>" + strThisChar + "</span>";
          } else {
            strChars += strThisChar;
          }
        }
        strChars += "<br/>";
      }
      oAscii2.innerHTML = `<tr><td style="display:block;width:${width}px;height:${height}px;overflow:hidden">${strChars}</td></tr>`;
    }
  }
};

// node_modules/@threlte/extras/dist/components/AsciiRenderer/AsciiRenderer.svelte
mark_module_start();
AsciiRenderer[FILENAME] = "node_modules/@threlte/extras/dist/components/AsciiRenderer/AsciiRenderer.svelte";
function AsciiRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AsciiRenderer);
  const defaultCharacters = " .:-+*=%@#";
  let autoRender = prop($$props, "autoRender", 3, true), bgColor = prop($$props, "bgColor", 3, "#000000"), characters = prop($$props, "characters", 3, defaultCharacters), fgColor = prop($$props, "fgColor", 3, "#ffffff"), options = prop($$props, "options", 19, () => ({}));
  const {
    autoRender: threlteAutoRender,
    camera: defaultCamera,
    renderStage,
    renderer,
    canvas,
    dom,
    scene: defaultScene,
    size
  } = useThrelte();
  const charSet = derived(() => characters() || defaultCharacters);
  const asciiEffect = derived(() => {
    const effect = new AsciiEffect(renderer, get(charSet), options());
    effect.domElement.style.position = "absolute";
    effect.domElement.style.top = "0px";
    effect.domElement.style.left = "0px";
    effect.domElement.style.pointerEvents = "none";
    return effect;
  });
  const getEffect = () => get(asciiEffect);
  const sizeStore = fromStore(size);
  user_pre_effect(() => {
    get(asciiEffect).setSize(sizeStore.current.width, sizeStore.current.height);
  });
  user_pre_effect(() => {
    get(asciiEffect).domElement.style.color = fgColor();
  });
  user_pre_effect(() => {
    get(asciiEffect).domElement.style.backgroundColor = bgColor();
  });
  user_effect(() => {
    canvas.style.opacity = "0";
    const last = get(asciiEffect).domElement;
    dom.appendChild(last);
    return () => {
      canvas.style.opacity = "1";
      dom.removeChild(last);
    };
  });
  const { start: startRendering, stop: stopRendering } = useTask(
    () => {
      get(asciiEffect).render($$props.scene ?? defaultScene, $$props.camera ?? defaultCamera.current);
    },
    {
      autoInvalidate: false,
      autoStart: false,
      stage: renderStage
    }
  );
  const start = () => {
    var _a2;
    startRendering();
    (_a2 = $$props.onstart) == null ? void 0 : _a2.call($$props);
  };
  const stop = () => {
    var _a2;
    stopRendering();
    (_a2 = $$props.onstop) == null ? void 0 : _a2.call($$props);
  };
  user_effect(() => {
    if (autoRender()) {
      start();
      return () => {
        stop();
      };
    }
  });
  user_effect(() => {
    const lastAutoRender = threlteAutoRender.current;
    threlteAutoRender.set(!autoRender());
    return () => {
      threlteAutoRender.set(lastAutoRender);
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop, () => ({ asciiEffect: get(asciiEffect) }));
  append($$anchor, fragment);
  return pop({
    get getEffect() {
      return getEffect;
    },
    get start() {
      return start;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  AsciiRenderer = hmr(AsciiRenderer, () => AsciiRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AsciiRenderer[HMR].source;
    set(AsciiRenderer[HMR].source, module.default[HMR].original);
  });
}
var AsciiRenderer_default = AsciiRenderer;
mark_module_end(AsciiRenderer);

// node_modules/@threlte/extras/dist/transitions/transltions.svelte.js
var el = strict_equals(typeof window, "undefined", false) ? document.createElement("div") : void 0;
var transitions = () => {
  injectPlugin("transitions", (args) => {
    if (!el) return;
    if (!args.props.in && !args.props.out && !args.props.transition) return;
    const { invalidate } = useThrelte();
    el.dispatchEvent = (e) => {
      var _a2, _b2, _c, _d, _e2, _f, _g, _h;
      if (strict_equals(e.type, "introstart")) {
        (_b2 = (_a2 = args.props).onintrostart) == null ? void 0 : _b2.call(_a2);
      } else if (strict_equals(e.type, "outrostart")) {
        (_d = (_c = args.props).onoutrostart) == null ? void 0 : _d.call(_c);
      } else if (strict_equals(e.type, "introend")) {
        (_f = (_e2 = args.props).onintroend) == null ? void 0 : _f.call(_e2);
      } else if (strict_equals(e.type, "outroend")) {
        (_h = (_g = args.props).onoutroend) == null ? void 0 : _h.call(_g);
      }
      return true;
    };
    const convertTransition = (transitionC) => {
      return (_node, _params, options) => {
        const t2 = transitionC(args.ref, { direction: options.direction });
        return {
          ...t2,
          tick(...args2) {
            var _a2;
            invalidate();
            (_a2 = t2 == null ? void 0 : t2.tick) == null ? void 0 : _a2.call(t2, ...args2);
          }
        };
      };
    };
    const props = ["in", "out", "transition"];
    const globalFlags = { in: 5, out: 6, transition: 7 };
    const localFlags = { in: 1, out: 2, transition: 3 };
    for (const prop2 of props) {
      const t2 = args.props[prop2];
      if (t2) {
        const global2 = "global" in t2;
        const flag = global2 ? globalFlags[prop2] : localFlags[prop2];
        transition(flag, el, () => convertTransition(t2));
      }
    }
    return {
      pluginProps: [
        "in",
        "out",
        "transition",
        "onintrostart",
        "onoutrostart",
        "onintroend",
        "onoutroend"
      ]
    };
  });
};

// node_modules/@threlte/extras/dist/transitions/createTransition.js
var createTransition = (transition2) => transition2;

// node_modules/@threlte/extras/dist/transitions/global.js
var global = (transition2) => {
  return Object.assign(transition2, {
    global: true
  });
};

// node_modules/@threlte/extras/dist/suspense/Suspense.svelte
mark_module_start();
Suspense[FILENAME] = "node_modules/@threlte/extras/dist/suspense/Suspense.svelte";
var root5 = add_locations(template(`<!> <!>`, 1), Suspense[FILENAME], []);
function Suspense($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Suspense);
  const [$$stores, $$cleanup] = setup_stores();
  const $suspended = () => (validate_store(suspended, "suspended"), store_get(suspended, "$suspended", $$stores));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$stores));
  let final = prop($$props, "final", 3, false);
  const { suspended, errors, setFinal } = createSuspenseContext({ final: final() });
  user_effect(() => setFinal(final()));
  user_effect(() => {
    var _a2;
    if (!$suspended()) (_a2 = $$props.onload) == null ? void 0 : _a2.call($$props);
  });
  user_effect(() => {
    var _a2;
    if ($suspended()) (_a2 = $$props.onsuspend) == null ? void 0 : _a2.call($$props);
  });
  user_effect(() => {
    var _a2;
    if ($errors().length > 0) (_a2 = $$props.onerror) == null ? void 0 : _a2.call($$props, $errors());
  });
  const group = new Group();
  const parentObject3D = useParentObject3D();
  watch([parentObject3D, suspended, errors], ([parent, suspended2, errors2]) => {
    if (!parent) return;
    if (suspended2 || errors2.length) {
      parent.remove(group);
      return;
    }
    parent.add(group);
    return () => {
      parent.remove(group);
    };
  });
  var fragment = root5();
  var node = first_child(fragment);
  T(node, {
    is: group,
    attach: false,
    children: wrap_snippet(Suspense, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop, () => ({
        suspended: $suspended(),
        errors: $errors()
      }));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      snippet(node_3, () => $$props.error ?? noop, () => ({ errors: $errors() }));
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_4 = first_child(fragment_3);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          snippet(node_5, () => $$props.fallback ?? noop);
          append($$anchor3, fragment_4);
        };
        if_block(
          node_4,
          ($$render) => {
            if ($suspended()) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_3);
    };
    if_block(node_2, ($$render) => {
      if ($errors().length) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Suspense = hmr(Suspense, () => Suspense[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Suspense[HMR].source;
    set(Suspense[HMR].source, module.default[HMR].original);
  });
}
var Suspense_default = Suspense;
mark_module_end(Suspense);

// node_modules/@threlte/extras/dist/suspense/onReveal.js
var onReveal = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  let cleanup;
  const mounted = writable(false);
  onMount(() => {
    if (!ctx)
      cleanup = callback();
    mounted.set(true);
  });
  if (!ctx) {
    onDestroy(() => cleanup == null ? void 0 : cleanup());
    return;
  }
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && !suspended)
      cleanup = callback();
    return () => cleanup == null ? void 0 : cleanup();
  });
};

// node_modules/@threlte/extras/dist/suspense/onSuspend.js
var onSuspend = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  if (!ctx)
    return;
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
  });
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/components/portals/usePortalContext.js
var createPortalContext = () => {
  const ctx = {
    portals: currentWritable(/* @__PURE__ */ new Map()),
    addPortal(object, id) {
      ctx.portals.update((portals) => {
        if (portals.has(id)) {
          console.warn(`Portal with id ${id} already exists. Skipping portal creation.`);
        } else {
          portals.set(id, object);
        }
        return portals;
      });
    },
    removePortal(id) {
      ctx.portals.update((portals) => {
        if (!portals.has(id)) {
          console.warn(`Portal with id ${id} does not exist. Skipping portal removal.`);
        } else {
          portals.delete(id);
        }
        return portals;
      });
    },
    getPortal(id) {
      return derived2(ctx.portals, (portals) => portals.get(id));
    },
    hasPortal(id) {
      return ctx.portals.current.has(id);
    }
  };
  return ctx;
};
var usePortalContext = () => {
  return useThrelteUserContext("threlte-portals", createPortalContext());
};

// node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte
mark_module_start();
Portal[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  const [$$stores, $$cleanup] = setup_stores();
  const $portal = () => (validate_store(get(portal), "portal"), store_get(get(portal), "$portal", $$stores));
  const $target = () => (validate_store(target, "target"), store_get(target, "$target", $$stores));
  let id = prop($$props, "id", 3, "default");
  const { getPortal } = usePortalContext();
  const children = writable([]);
  const target = writable();
  let portal = derived(() => getPortal(id()));
  user_pre_effect(() => target.set($$props.object ?? $portal()));
  watch([children, target], ([children2, target2]) => {
    if (strict_equals(target2, void 0)) return;
    for (const child2 of children2) {
      if (target2.children.includes(child2)) continue;
      target2.add(child2);
    }
    return () => {
      for (const child2 of children2) {
        if (target2.children.includes(child2)) {
          target2.remove(child2);
        }
      }
    };
  });
  const proxy2 = new Object3D();
  proxy2.add = (child2) => {
    children.update((array) => {
      array.push(child2);
      return array;
    });
    return child2;
  };
  proxy2.remove = (child2) => {
    children.update((array) => {
      array.splice(array.indexOf(child2), 1);
      return array;
    });
    return child2;
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      T(node_1, {
        is: proxy2,
        attach: false,
        children: wrap_snippet(Portal, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($target()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var Portal_default = Portal;
mark_module_end(Portal);

// node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte
mark_module_start();
PortalTarget[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte";
function PortalTarget($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PortalTarget);
  const [$$stores, $$cleanup] = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  let id = prop($$props, "id", 3, "default");
  const parent = useParent();
  if (!$parent()) {
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  }
  const { addPortal, removePortal } = usePortalContext();
  watch(parent, (parent2) => {
    if (!parent2 || !isInstanceOf(parent2, "Object3D")) return;
    addPortal(parent2, id());
    return () => {
      removePortal(id());
    };
  });
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  PortalTarget = hmr(PortalTarget, () => PortalTarget[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PortalTarget[HMR].source;
    set(PortalTarget[HMR].source, module.default[HMR].original);
  });
}
var PortalTarget_default = PortalTarget;
mark_module_end(PortalTarget);

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function workerBootstrap2() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0) dependencies = [];
    var init2 = ref.init;
    if (init2 === void 0) init2 = function() {
    };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0) getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init2 = rehydrate("<" + name + ">.init", init2);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init2 === "function") {
        value = init2.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err2) {
      if (!(err2 && err2.noLog)) {
        console.error(err2);
      }
      callback(err2);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err2) {
      callback(err2);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err2) {
        console.error(err2);
        callback(err2);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err2) {
      console.error(err2);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action2 = ref.action;
    var data = ref.data;
    try {
      if (action2 === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action2 === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err2) {
      postMessage({
        messageId,
        success: false,
        error: err2.stack
      });
    }
  });
}
function defineMainThreadModule2(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init2 = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(
      function(dep) {
        return dep && dep._getInitResult ? dep._getInitResult() : dep;
      }
    ) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init2.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers2 = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err2) {
      if (typeof process !== "undefined" && false) ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err2.message + "]"
        );
      }
    }
  }
  supportsWorkers2 = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId2 = 0;
var _messageId2 = 0;
var _allowInitAsString2 = false;
var workers2 = /* @__PURE__ */ Object.create(null);
var registeredModules2 = /* @__PURE__ */ Object.create(null);
var openRequests2 = /* @__PURE__ */ Object.create(null);
function defineWorkerModule2(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString2) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init2 = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers2()) {
    return defineMainThreadModule2(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId2;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString2 = true;
      dep = defineWorkerModule2({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction2(dep) + "\n)}"
      });
      _allowInitAsString2 = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (!registrationPromise) {
      registrationPromise = callWorker2(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules2[workerId].delete(unregister);
      };
      (registeredModules2[workerId] || (registeredModules2[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker2(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction2(init2),
    getTransferables: getTransferables && stringifyFunction2(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker2(workerId) {
  if (registeredModules2[workerId]) {
    registeredModules2[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers2[workerId]) {
    workers2[workerId].terminate();
    delete workers2[workerId];
  }
}
function stringifyFunction2(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker2(workerId) {
  var worker = workers2[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction2(workerBootstrap2);
    worker = workers2[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests2[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests2[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker2(workerId, action2, data) {
  return new Promise(function(resolve, reject) {
    var messageId = ++_messageId2;
    openRequests2[messageId] = function(response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action2 + " call: " + response.error));
      }
    };
    getWorker2(workerId).postMessage({
      messageId,
      action: action2,
      data
    });
  });
}

// node_modules/troika-three-text/node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp2 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes2(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes2(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut2 = [];
for (let i = 0; i < 256; i++) {
  _lut2[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID2() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut2[d0 & 255] + _lut2[d0 >> 8 & 255] + _lut2[d0 >> 16 & 255] + _lut2[d0 >> 24 & 255] + "-" + _lut2[d1 & 255] + _lut2[d1 >> 8 & 255] + "-" + _lut2[d1 >> 16 & 15 | 64] + _lut2[d1 >> 24 & 255] + "-" + _lut2[d2 & 63 | 128] + _lut2[d2 >> 8 & 255] + "-" + _lut2[d2 >> 16 & 255] + _lut2[d2 >> 24 & 255] + _lut2[d3 & 255] + _lut2[d3 >> 8 & 255] + _lut2[d3 >> 16 & 255] + _lut2[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign4 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop2)) {
          target[prop2] = source[prop2];
        }
      }
    }
  }
  return target;
};
var epoch2 = Date.now();
var CONSTRUCTOR_CACHE2 = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE2 = /* @__PURE__ */ new Map();
var materialInstanceId2 = 1e10;
function createDerivedMaterial2(baseMaterial, options) {
  const optionsKey = getKeyForOptions2(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE2.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE2.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE2[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders2(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE2[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign4(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch2;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived3 = Object.create(base, descriptor);
    Object.defineProperty(derived3, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived3, "id", { value: materialInstanceId2++ });
    derived3.uuid = generateUUID2();
    derived3.uniforms = assign4({}, base.uniforms, options.uniforms);
    derived3.defines = assign4({}, base.defines, options.defines);
    derived3.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived3.extensions = assign4({}, base.extensions, options.extensions);
    derived3._listeners = void 0;
    return derived3;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    type: {
      get: () => baseMaterial.type,
      set: (value) => {
        baseMaterial.type = value;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(testMaterial) {
        const base = this.baseMaterial;
        return testMaterial === base || base.isDerivedMaterial && base.isDerivedFrom(testMaterial) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign4(this.extensions, source.extensions);
          assign4(this.defines, source.defines);
          assign4(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial2(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial2(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders2(material, { vertexShader: vertexShader9, fragmentShader: fragmentShader9 }, options, key2) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader9 = expandShaderIncludes2(vertexShader9);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader9 = fragmentShader9.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader9 = expandShaderIncludes2(fragmentShader9);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader: vertexShader9, fragmentShader: fragmentShader9 });
    vertexShader9 = res.vertexShader;
    fragmentShader9 = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader9 = fragmentShader9.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader9 = `vec3 troika_position_${key2};
vec3 troika_normal_${key2};
vec2 troika_uv_${key2};
${vertexShader9}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key2}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key2} = vec3(position);
troika_normal_${key2} = vec3(normal);
troika_uv_${key2} = vec2(uv);
troikaVertexTransform${key2}(troika_position_${key2}, troika_normal_${key2}, troika_uv_${key2});
${vertexMainIntro}
`;
    vertexShader9 = vertexShader9.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key2}`;
    });
    if (!(material.map && material.map.channel > 0)) {
      vertexShader9 = vertexShader9.replace(/\bMAP_UV\b/g, `troika_uv_${key2}`);
    }
  }
  vertexShader9 = injectIntoShaderCode2(vertexShader9, key2, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader9 = injectIntoShaderCode2(fragmentShader9, key2, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader: vertexShader9,
    fragmentShader: fragmentShader9
  };
}
function injectIntoShaderCode2(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp2,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer2(key2, value) {
  return key2 === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr2 = 0;
var optionsHashesToIds2 = /* @__PURE__ */ new Map();
function getKeyForOptions2(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer2);
  let id = optionsHashesToIds2.get(optionsHash);
  if (id == null) {
    optionsHashesToIds2.set(optionsHash, id = ++_idCtr2);
  }
  return id;
}
var defaultBaseMaterial2 = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function typrFactory2() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a2, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a2, n2), n2 += 2, t3.readUshort(a2, n2), n2 += 2;
        var o = t3.readUint(a2, n2);
        n2 += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t3.readUint(a2, n2);
          n2 += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t3) {
      var a2 = e._bin, n2 = t3;
      a2.readFixed(r2, t3), t3 += 4;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n2 }, h = {}, d = 0; d < o; d++) {
        var f = a2.readASCII(r2, t3, 4);
        t3 += 4, a2.readUint(r2, t3), t3 += 4;
        var u2 = a2.readUint(r2, t3);
        t3 += 4;
        var l = a2.readUint(r2, t3);
        t3 += 4, h[f] = { offset: u2, length: l };
      }
      for (d = 0; d < s.length; d++) {
        var v4 = s[d];
        h[v4] && (i[v4.trim()] = e[v4.trim()].parse(r2, h[v4].offset, h[v4].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t3, a2) {
      for (var n2 = e._bin, o = n2.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n2.readASCII(r2, s, 4);
        s += 4, n2.readUint(r2, s), s += 4;
        var d = n2.readUint(r2, s);
        if (s += 4, n2.readUint(r2, s), s += 4, h == t3) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a2) {
      for (var n2 = [], o = 0; o < a2; o++) n2.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n2;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) a2 += String.fromCharCode(r2[e2 + n2]);
      return a2;
    }, readUnicode: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a2) {
      var n2 = e._bin._tdec;
      return n2 && 0 == t3 && a2 == r2.length ? n2.decode(r2) : e._bin.readASCII(r2, t3, a2);
    }, readBytes: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(r2[e2 + n2]);
      return a2;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(String.fromCharCode(r2[e2 + n2]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a2, n2, o) {
      var s = e._bin, i = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var u2 = s.readUshort(r2, t3);
      return t3 += 2, i.scriptList = e._lctf.readScriptList(r2, h + d), i.featureList = e._lctf.readFeatureList(r2, h + f), i.lookupList = e._lctf.readLookupList(r2, h + u2, o), i;
    }, e._lctf.readLookupList = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = [], i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readLookupTable(r2, o + d, a2);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r2, t3), t3 += 2, s.flag = n2.readUshort(r2, t3), t3 += 2;
      var i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = a2(r2, h, o + f, s);
        s.tabs.push(u2);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++) 0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = a2.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a2.readUshort(r2, t3);
        t3 += 2;
        var i = a2.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i; h++) n2.push(s + h), n2.push(s + h), n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < d; h++) n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      return n2;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a2 = r2[t3], n2 = r2[t3 + 1];
        if (r2[t3 + 2], a2 <= e2 && e2 <= n2) return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.fmt = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, o)), 2 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, 3 * o)), n2;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a2 = r2.tab;
      if (1 == r2.fmt) return a2.indexOf(t3);
      if (2 == r2.fmt) {
        var n2 = e._lctf.getInterval(a2, t3);
        if (-1 != n2) return a2[n2 + 2] + (t3 - a2[n2]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readFeatureTable(r2, n2 + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a2.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n2 + d);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r2, n2 + s));
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2, o[d.trim()] = e._lctf.readLangSysTable(r2, n2 + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      a2.readUshort(r2, t3), t3 += 2, n2.reqFeature = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, n2.features = a2.readUshorts(r2, t3, o), n2;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a2) {
      var n2 = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a2))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n2.readASCII(r2, t3 + o[i], o[i + 1] - o[i]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r2, t3 + h[i], t3 + h[i + 1]));
      t3 += h[h.length - 1];
      var f = d[0], u2 = [];
      t3 = e.CFF.readIndex(r2, t3, u2);
      var l = [];
      for (i = 0; i < u2.length - 1; i++) l.push(n2.readASCII(r2, t3 + u2[i], u2[i + 1] - u2[i]));
      if (t3 += u2[u2.length - 1], e.CFF.readSubrs(r2, t3, f), f.CharStrings) {
        t3 = f.CharStrings;
        u2 = [];
        t3 = e.CFF.readIndex(r2, t3, u2);
        var v4 = [];
        for (i = 0; i < u2.length - 1; i++) v4.push(n2.readBytes(r2, t3 + u2[i], u2[i + 1] - u2[i]));
        f.CharStrings = v4;
      }
      if (f.ROS) {
        t3 = f.FDArray;
        var c = [];
        t3 = e.CFF.readIndex(r2, t3, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r2, t3 + c[i], t3 + c[i + 1]);
          e.CFF._readFDict(r2, p, l), f.FDArray.push(p);
        }
        t3 += c[c.length - 1], t3 = f.FDSelect, f.FDSelect = [];
        var U2 = r2[t3];
        if (t3++, 3 != U2) throw U2;
        var g4 = n2.readUshort(r2, t3);
        t3 += 2;
        for (i = 0; i < g4 + 1; i++) f.FDSelect.push(n2.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r2, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r2, f.charset, f.CharStrings.length)), e.CFF._readFDict(r2, f, l), f;
    }, e.CFF._readFDict = function(r2, t3, a2) {
      var n2;
      for (var o in t3.Private && (n2 = t3.Private[1], t3.Private = e.CFF.readDict(r2, n2, n2 + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n2 + t3.Private.Subrs, t3.Private)), t3) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a2[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a2.Subrs.push(n2.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++) if (r2.charset[t3] == e2) return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a2) {
      e._bin;
      var n2 = [".notdef"], o = r2[t3];
      if (t3++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i = 0; i < s; i++) n2.push(r2[t3 + i]);
      return n2;
    }, e.CFF.readCharset = function(r2, t3, a2) {
      var n2 = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s) for (var i = 0; i < a2; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2, o.push(h);
      }
      else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n2.readUshort(r2, t3);
          t3 += 2;
          var d = 0;
          1 == s ? (d = r2[t3], t3++) : (d = n2.readUshort(r2, t3), t3 += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a2) {
      var n2 = e._bin, o = n2.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s) for (var i = 0; i < o; i++) a2.push(r2[t3 + i]);
      else if (2 == s) for (i = 0; i < o; i++) a2.push(n2.readUshort(r2, t3 + 2 * i));
      else if (3 == s) for (i = 0; i < o; i++) a2.push(16777215 & n2.readUint(r2, t3 + 3 * i - 1));
      else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a2) {
      var n2 = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i = 1, h = null, d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n2.readShort(r2, t3 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n2.readInt(r2, t3 + 1) / 65535, i = 5), a2.val = null != d ? d : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t3, a2) {
      for (var n2 = t3 + a2, o = e._bin, s = []; t3 < n2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u2 = o.readShort(r2, t3 + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u2 = o.readInt(r2, t3 + 1) / 65535, d = 5), s.push(null != u2 ? u2 : "o" + f), t3 += d;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a2) {
      for (var n2 = e._bin, o = {}, s = []; t3 < a2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        if (28 == i && (u2 = n2.readShort(r2, t3 + 1), d = 3), 29 == i && (u2 = n2.readInt(r2, t3 + 1), d = 5), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u2 = n2.readInt(r2, t3 + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1; ; ) {
            var v4 = r2[t3 + d];
            d++;
            var c = v4 >> 4, p = 15 & v4;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U2 = "", g4 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U2 += g4[l[S]];
          u2 = parseFloat(U2);
        }
        if (i <= 21) {
          if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        }
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u2), t3 += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a2) {
      r2 = new Uint8Array(r2.buffer, t3, a2), t3 = 0;
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = n2.readUint(r2, t3);
        t3 += 4;
        var l = "p" + d + "e" + f, v4 = i.indexOf(u2);
        if (-1 == v4) {
          var c;
          v4 = o.tables.length, i.push(u2);
          var p = n2.readUshort(r2, u2);
          0 == p ? c = e.cmap.parse0(r2, u2) : 4 == p ? c = e.cmap.parse4(r2, u2) : 6 == p ? c = e.cmap.parse6(r2, u2) : 12 == p ? c = e.cmap.parse12(r2, u2) : console.debug("unknown format: " + p, d, f, u2), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v4;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o - 6; s++) n2.map.push(r2[t3 + s]);
      return n2;
    }, e.cmap.parse4 = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {};
      o.format = a2.readUshort(r2, t3), t3 += 2;
      var s = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t3), t3 += 2, o.entrySelector = a2.readUshort(r2, t3), t3 += 2, o.rangeShift = a2.readUshort(r2, t3), t3 += 2, o.endCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a2.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n2 + s; ) o.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.firstCode = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o; s++) n2.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.cmap.parse12 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, t3 += 2, a2.readUint(r2, t3), t3 += 4, a2.readUint(r2, t3), t3 += 4;
      var o = a2.readUint(r2, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t3 + 12 * s, h = a2.readUint(r2, i + 0), d = a2.readUint(r2, i + 4), f = a2.readUint(r2, i + 8);
        n2.groups.push([h, d, f]);
      }
      return n2;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a2) {
      for (var n2 = [], o = 0; o < a2.maxp.numGlyphs; o++) n2.push(null);
      return n2;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a2 = e._bin, n2 = r2._data, o = e._tabOffset(n2, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1]) return null;
      var s = {};
      if (s.noc = a2.readShort(n2, o), o += 2, s.xMin = a2.readShort(n2, o), o += 2, s.yMin = a2.readShort(n2, o), o += 2, s.xMax = a2.readShort(n2, o), o += 2, s.yMax = a2.readShort(n2, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a2.readUshort(n2, o)), o += 2;
        var h = a2.readUshort(n2, o);
        if (o += 2, n2.length - o < h) return null;
        s.instructions = a2.readBytes(n2, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n2[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u2 = n2[o];
            o++;
            for (var l = 0; l < u2; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v4 = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v4 ? (s.xs.push(c ? n2[o] : -n2[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n2, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v4 = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v4 ? (s.ys.push(c ? n2[o] : -n2[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n2, o)), o += 2);
        }
        var p = 0, U2 = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U2 += s.ys[i], s.xs[i] = p, s.ys[i] = U2;
      } else {
        var g4;
        s.parts = [];
        do {
          g4 = a2.readUshort(n2, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n2, o), o += 2, 1 & g4) {
            var m = a2.readShort(n2, o);
            o += 2;
            var b = a2.readShort(n2, o);
            o += 2;
          } else {
            m = a2.readInt8(n2, o);
            o++;
            b = a2.readInt8(n2, o);
            o++;
          }
          2 & g4 ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g4 ? (S.m.a = S.m.d = a2.readF2dot14(n2, o), o += 2) : 64 & g4 ? (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2) : 128 & g4 && (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.b = a2.readF2dot14(n2, o), o += 2, S.m.c = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2);
        } while (32 & g4);
        if (256 & g4) {
          var y2 = a2.readUshort(n2, o);
          o += 2, s.instr = [];
          for (i = 0; i < y2; i++) s.instr.push(n2[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function(r2, t3, a2, n2) {
      var o = t3;
      t3 += 4;
      var s = e._bin.readUshort(r2, t3);
      return { glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r2, o + s) };
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i.fmt) {
        var d = o.readUshort(r2, a2);
        a2 += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r2, a2, d));
      } else if (2 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r2, a2);
        a2 += 2;
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var u2 = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v4 = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v4; c++) {
            var p = s + o.readUshort(r2, a2);
            a2 += 2;
            var U2 = o.readUshort(r2, p);
            p += 2;
            for (var g4 = [], S = 0; S < U2; S++) {
              var m = o.readUshort(r2, p);
              p += 2, 0 != d && (P2 = e.GPOS.readValueRecord(r2, p, d), p += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * l), g4.push({ gid2: m, val1: P2, val2: x });
            }
            i.pairsets.push(g4);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y2 = o.readUshort(r2, a2);
          a2 += 2;
          var F3 = o.readUshort(r2, a2);
          a2 += 2;
          var C3 = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y2), i.matrix = [];
          for (c = 0; c < F3; c++) {
            var _ = [];
            for (S = 0; S < C3; S++) {
              var P2 = null, x = null;
              0 != d && (P2 = e.GPOS.readValueRecord(r2, a2, d), a2 += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * l), _.push({ val1: P2, val2: x });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t3 && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.baseCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.markArray = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.baseArray = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else if (6 == t3 && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.mark2Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.mark1Array = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else {
        if (9 == t3 && 1 == i.fmt) {
          var I4 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = I4;
          else if (n2.ltype != I4) throw "invalid extension substitution";
          return e.GPOS.subt(r2, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      return o.push(1 & a2 ? n2.readShort(r2, t3) : 0), t3 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n2.readShort(r2, t3) : 0), t3 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n2.readShort(r2, t3) : 0), t3 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n2.readShort(r2, t3) : 0), t3 += 8 & a2 ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function(r2, t3, a2) {
      var n2 = e._bin, o = [], s = t3, i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a2; f++) d.push(e.GPOS.readAnchorRecord(r2, s + n2.readUshort(r2, t3))), t3 += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = t3, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r2, a2.readUshort(r2, t3 + 2) + o);
        h.markClass = a2.readUshort(r2, t3), n2.push(h), t3 += 4;
      }
      return n2;
    }, e.GPOS.readAnchorRecord = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      return n2.fmt = a2.readUshort(r2, t3), n2.x = a2.readShort(r2, t3 + 2), n2.y = a2.readShort(r2, t3 + 4), n2;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t3 && 2 != t3 && 4 != t3 && 5 != t3 && 6 != t3) return null;
      if (1 == t3 || 2 == t3 || 4 == t3 || 5 == t3 && i.fmt <= 2 || 6 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var d = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, d), a2 += 2 * i.newg.length;
        }
      } else if (2 == t3 && 1 == i.fmt) {
        d = o.readUshort(r2, a2);
        a2 += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u2 = o.readUshort(r2, a2) + s;
          a2 += 2;
          var l = o.readUshort(r2, u2);
          i.seqs.push(o.readUshorts(r2, u2 + 2, l));
        }
      } else if (4 == t3) {
        i.vals = [];
        d = o.readUshort(r2, a2);
        a2 += 2;
        for (f = 0; f < d; f++) {
          var v4 = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + v4));
        }
      } else if (5 == t3 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + c), i.scset = [];
          var p = o.readUshort(r2, a2);
          a2 += 2;
          for (f = 0; f < p; f++) {
            var U2 = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == U2 ? null : e.GSUB.readSubClassSet(r2, s + U2));
          }
        }
      } else if (6 == t3 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r2, a2);
            a2 += 2;
            for (var g4 = [], S = 0; S < d; S++) g4.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * S)));
            a2 += 2 * d, 0 == f && (i.backCvg = g4), 1 == f && (i.inptCvg = g4), 2 == f && (i.ahedCvg = g4);
          }
          d = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, d);
        }
      } else {
        if (7 == t3 && 1 == i.fmt) {
          var m = o.readUshort(r2, a2);
          a2 += 2;
          var b = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = m;
          else if (n2.ltype != m) throw "invalid extension substitution";
          return e.GSUB.subt(r2, n2.ltype, s + b);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = t3, o = [], s = a2(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = {}, o = a2(r2, t3), s = a2(r2, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i = 0; i < o - 1; i++) n2.input.push(a2(r2, t3)), t3 += 2;
      return n2.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n2;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a2) {
      for (var n2 = e._bin.readUshort, o = [], s = 0; s < a2; s++) o.push(n2(r2, t3), n2(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a2 = e._bin, n2 = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t3);
        t3 += 2, 1 == s && i--, n2[o[s]] = a2.readUshorts(r2, t3, i), t3 += 2 * n2[o[s]].length;
      }
      i = a2.readUshort(r2, t3);
      return t3 += 2, n2.subst = a2.readUshorts(r2, t3, 2 * i), t3 += 2 * n2.subst.length, n2;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a2 = e._bin, n2 = { chain: [] };
      n2.nglyph = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++) n2.chain.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.head = {}, e.head.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.fontRevision = n2.readFixed(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, o.flags = n2.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n2.readUshort(r2, t3), t3 += 2, o.created = n2.readUint64(r2, t3), t3 += 8, o.modified = n2.readUint64(r2, t3), t3 += 8, o.xMin = n2.readShort(r2, t3), t3 += 2, o.yMin = n2.readShort(r2, t3), t3 += 2, o.xMax = n2.readShort(r2, t3), t3 += 2, o.yMax = n2.readShort(r2, t3), t3 += 2, o.macStyle = n2.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n2.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n2.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n2.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n2.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.ascender = n2.readShort(r2, t3), t3 += 2, o.descender = n2.readShort(r2, t3), t3 += 2, o.lineGap = n2.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n2.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n2.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n2.readShort(r2, t3), t3 += 2, o.xMaxExtent = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n2.readShort(r2, t3), t3 += 2, o.caretOffset = n2.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n2.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n2.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a2, n2) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, d = 0; d < n2.maxp.numGlyphs; d++) d < n2.hhea.numberOfHMetrics && (i = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s) return e.kern.parseV1(r2, t3 - 2, a2, n2);
      var i = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < i; d++) {
        t3 += 2;
        a2 = o.readUshort(r2, t3);
        t3 += 2;
        var f = o.readUshort(r2, t3);
        t3 += 2;
        var u2 = f >>> 8;
        if (0 != (u2 &= 15)) throw "unknown kern table format: " + u2;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a2, n2) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var d = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t3 = e.kern.readFormat0(r2, t3, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t3, a2) {
      var n2 = e._bin, o = -1, s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readShort(r2, t3);
        t3 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var u2 = a2.rval[a2.rval.length - 1];
        u2.glyph2.push(d), u2.vals.push(f), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = [], i = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r2, t3 + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r2, t3 + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {}, s = n2.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n2.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n2.readUshort(r2, t3), t3 += 2, o.maxContours = n2.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n2.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n2.readUshort(r2, t3), t3 += 2, o.maxZones = n2.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n2.readUshort(r2, t3), t3 += 2, o.maxStorage = n2.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxStackElements = n2.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n2.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n2.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n2.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t3 += 2, f = 0; f < s; f++) {
        var u2 = n2.readUshort(r2, t3);
        t3 += 2;
        var l = n2.readUshort(r2, t3);
        t3 += 2;
        var v4 = n2.readUshort(r2, t3);
        t3 += 2;
        var c = n2.readUshort(r2, t3);
        t3 += 2;
        var p = n2.readUshort(r2, t3);
        t3 += 2;
        var U2 = n2.readUshort(r2, t3);
        t3 += 2;
        var g4, S = h[c], m = d + 12 * s + U2;
        if (0 == u2) g4 = n2.readUnicode(r2, m, p / 2);
        else if (3 == u2 && 0 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else if (0 == l) g4 = n2.readASCII(r2, m, p);
        else if (1 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else if (3 == l) g4 = n2.readUnicode(r2, m, p / 2);
        else {
          if (1 != u2) throw "unknown encoding " + l + ", platformID: " + u2;
          g4 = n2.readASCII(r2, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b = "p" + u2 + "," + v4.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g4, o[b]._lang = v4;
      }
      for (var y2 in o) if (null != o[y2].postScriptName && 1033 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 0 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 3084 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName) return o[y2];
      for (var y2 in o) {
        i = y2;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a2) {
      var n2 = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n2) e["OS/2"].version0(r2, t3, o);
      else if (1 == n2) e["OS/2"].version1(r2, t3, o);
      else if (2 == n2 || 3 == n2 || 4 == n2) e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n2) throw "unknown OS/2 table version: " + n2;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a2) {
      var n2 = e._bin;
      return a2.xAvgCharWidth = n2.readShort(r2, t3), t3 += 2, a2.usWeightClass = n2.readUshort(r2, t3), t3 += 2, a2.usWidthClass = n2.readUshort(r2, t3), t3 += 2, a2.fsType = n2.readUshort(r2, t3), t3 += 2, a2.ySubscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutSize = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutPosition = n2.readShort(r2, t3), t3 += 2, a2.sFamilyClass = n2.readShort(r2, t3), t3 += 2, a2.panose = n2.readBytes(r2, t3, 10), t3 += 10, a2.ulUnicodeRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange2 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange3 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange4 = n2.readUint(r2, t3), t3 += 4, a2.achVendID = [n2.readInt8(r2, t3), n2.readInt8(r2, t3 + 1), n2.readInt8(r2, t3 + 2), n2.readInt8(r2, t3 + 3)], t3 += 4, a2.fsSelection = n2.readUshort(r2, t3), t3 += 2, a2.usFirstCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.usLastCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.sTypoAscender = n2.readShort(r2, t3), t3 += 2, a2.sTypoDescender = n2.readShort(r2, t3), t3 += 2, a2.sTypoLineGap = n2.readShort(r2, t3), t3 += 2, a2.usWinAscent = n2.readUshort(r2, t3), t3 += 2, a2.usWinDescent = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a2), a2.ulCodePageRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulCodePageRange2 = n2.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a2), a2.sxHeight = n2.readShort(r2, t3), t3 += 2, a2.sCapHeight = n2.readShort(r2, t3), t3 += 2, a2.usDefault = n2.readUshort(r2, t3), t3 += 2, a2.usBreak = n2.readUshort(r2, t3), t3 += 2, a2.usMaxContext = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a2), a2.usLowerOpticalPointSize = n2.readUshort(r2, t3), t3 += 2, a2.usUpperOpticalPointSize = n2.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return o.version = n2.readFixed(r2, t3), t3 += 4, o.italicAngle = n2.readFixed(r2, t3), t3 += 4, o.underlinePosition = n2.readShort(r2, t3), t3 += 2, o.underlineThickness = n2.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a2 = -1;
      if (null != t3.p0e4 ? a2 = t3.p0e4 : null != t3.p3e1 ? a2 = t3.p3e1 : null != t3.p1e0 ? a2 = t3.p1e0 : null != t3.p0e3 && (a2 = t3.p0e3), -1 == a2) throw "no familiar platform and encoding!";
      var n2 = t3.tables[a2];
      if (0 == n2.format) return e2 >= n2.map.length ? 0 : n2.map[e2];
      if (4 == n2.format) {
        for (var o = -1, s = 0; s < n2.endCount.length; s++) if (e2 <= n2.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n2.startCount[o] > e2) return 0;
        return 65535 & (0 != n2.idRangeOffset[o] ? n2.glyphIdArray[e2 - n2.startCount[o] + (n2.idRangeOffset[o] >> 1) - (n2.idRangeOffset.length - o)] : e2 + n2.idDelta[o]);
      }
      if (12 == n2.format) {
        if (e2 > n2.groups[n2.groups.length - 1][1]) return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i = n2.groups[s];
          if (i[0] <= e2 && e2 <= i[1]) return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n2 = r2.SVG.entries[t3];
        return null == n2 ? a2 : ("string" == typeof n2 && (n2 = e.SVG.toPath(n2), r2.SVG.entries[t3] = n2), n2);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; ) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i, a2);
      } else r2.glyf && e.U._drawGlyf(t3, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t3, a2) {
      var n2 = t3.glyf[r2];
      null == n2 && (n2 = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n2 && (n2.noc > -1 ? e.U._simpleGlyph(n2, a2) : e.U._compoGlyph(n2, t3, a2));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n2 = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n2; s <= o; s++) {
          var i = s == n2 ? o : s - 1, h = s == o ? n2 : s + 1, d = 1 & r2.flags[s], f = 1 & r2.flags[i], u2 = 1 & r2.flags[h], l = r2.xs[s], v4 = r2.ys[s];
          if (s == n2) if (d) {
            if (!f) {
              e.U.P.moveTo(t3, l, v4);
              continue;
            }
            e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]);
          } else f ? e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t3, (r2.xs[i] + l) / 2, (r2.ys[i] + v4) / 2);
          d ? f && e.U.P.lineTo(t3, l, v4) : u2 ? e.U.P.qcurveTo(t3, l, v4, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, l, v4, (l + r2.xs[h]) / 2, (v4 + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a2) {
      for (var n2 = 0; n2 < r2.parts.length; n2++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n2];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h], f = o.crds[h + 1];
          a2.crds.push(d * i.a + f * i.b + i.tx), a2.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a2 = e._lctf.getInterval(t3, r2);
      return -1 == a2 ? 0 : t3[a2 + 2];
    }, e.U._applySubs = function(r2, t3, a2, n2) {
      for (var o = r2.length - t3 - 1, s = 0; s < a2.tabs.length; s++) if (null != a2.tabs[s]) {
        var i, h = a2.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
          if (1 == a2.ltype) r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i];
          else if (4 == a2.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
            var u2 = d[f], l = u2.chain.length;
            if (!(l > o)) {
              for (var v4 = true, c = 0, p = 0; p < l; p++) {
                for (; -1 == r2[t3 + c + (1 + p)]; ) c++;
                u2.chain[p] != r2[t3 + c + (1 + p)] && (v4 = false);
              }
              if (v4) {
                r2[t3] = u2.nglyph;
                for (p = 0; p < l + c; p++) r2[t3 + p + 1] = -1;
                break;
              }
            }
          }
          else if (5 == a2.ltype && 2 == h.fmt) for (var U2 = e._lctf.getInterval(h.cDef, r2[t3]), g4 = h.cDef[U2 + 2], S = h.scset[g4], m = 0; m < S.length; m++) {
            var b = S[m], y2 = b.input;
            if (!(y2.length > o)) {
              for (v4 = true, p = 0; p < y2.length; p++) {
                var F3 = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p]);
                if (-1 == U2 && h.cDef[F3 + 2] != y2[p]) {
                  v4 = false;
                  break;
                }
              }
              if (v4) {
                var C3 = b.substLookupRecords;
                for (f = 0; f < C3.length; f += 2) C3[f], C3[f + 1];
              }
            }
          }
          else if (6 == a2.ltype && 3 == h.fmt) {
            if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length)) continue;
            if (!e.U._glsCovered(r2, h.inptCvg, t3)) continue;
            if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length)) continue;
            var _ = h.lookupRec;
            for (m = 0; m < _.length; m += 2) {
              U2 = _[m];
              var P2 = n2[_[m + 1]];
              e.U._applySubs(r2, t3 + U2, P2, n2);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r2, t3, a2) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e._lctf.coverageIndex(t3[n2], r2[a2 + n2])) return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a2) {
      for (var n2 = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i = t3[s];
        if (-1 != i) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, d = e.U.glyphToPath(r2, i), f = 0; f < d.crds.length; f += 2) n2.crds.push(d.crds[f] + o), n2.crds.push(d.crds[f + 1]);
          a2 && n2.cmds.push(a2);
          for (f = 0; f < d.cmds.length; f++) n2.cmds.push(d.cmds[f]);
          a2 && n2.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n2;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a2, n2, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a2, n2, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a2, n2) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a2, n2);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a2, n2, o) {
      for (var s = t3.stack, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open, u2 = 0, l = t3.x, v4 = t3.y, c = 0, p = 0, U2 = 0, g4 = 0, S = 0, m = 0, b = 0, y2 = 0, F3 = 0, C3 = 0, _ = { val: 0, size: 0 }; u2 < r2.length; ) {
        e.CFF.getCharString(r2, u2, _);
        var P2 = _.val;
        if (u2 += _.size, "o1" == P2 || "o18" == P2) s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == P2 || "o23" == P2) {
          s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == P2) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), f && e.U.P.closePath(o), v4 += s.pop(), e.U.P.moveTo(o, l, v4), f = true;
        else if ("o5" == P2) for (; s.length > 0; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
        else if ("o6" == P2 || "o7" == P2) for (var x = s.length, I4 = "o6" == P2, w = 0; w < x; w++) {
          var k = s.shift();
          I4 ? l += k : v4 += k, I4 = !I4, e.U.P.lineTo(o, l, v4);
        }
        else if ("o8" == P2 || "o24" == P2) {
          x = s.length;
          for (var G2 = 0; G2 + 6 <= x; ) c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4), G2 += 6;
          "o24" == P2 && (l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4));
        } else {
          if ("o11" == P2) break;
          if ("o1234" == P2 || "o1235" == P2 || "o1236" == P2 || "o1237" == P2) "o1234" == P2 && (p = v4, U2 = (c = l + s.shift()) + s.shift(), C3 = g4 = p + s.shift(), m = g4, y2 = v4, l = (b = (S = (F3 = U2 + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1235" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), F3 = U2 + s.shift(), C3 = g4 + s.shift(), S = F3 + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y2 = m + s.shift(), l = b + s.shift(), v4 = y2 + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1236" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), C3 = g4 = p + s.shift(), m = g4, b = (S = (F3 = U2 + s.shift()) + s.shift()) + s.shift(), y2 = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4)), "o1237" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), F3 = U2 + s.shift(), C3 = g4 + s.shift(), S = F3 + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y2 = m + s.shift(), Math.abs(b - l) > Math.abs(y2 - v4) ? l = b + s.shift() : v4 = y2 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, F3, C3), e.U.P.curveTo(o, S, m, b, y2, l, v4));
          else if ("o14" == P2) {
            if (s.length > 0 && !h && (d = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var O3 = s.shift(), T4 = s.shift(), D2 = s.shift(), B3 = s.shift(), A3 = e.CFF.glyphBySE(a2, D2), R2 = e.CFF.glyphBySE(a2, B3);
              e.U._drawCFF(a2.CharStrings[A3], t3, a2, n2, o), t3.x = O3, t3.y = T4, e.U._drawCFF(a2.CharStrings[R2], t3, a2, n2, o);
            }
            f && (e.U.P.closePath(o), f = false);
          } else if ("o19" == P2 || "o20" == P2) {
            s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, u2 += i + 7 >> 3;
          } else if ("o21" == P2) s.length > 2 && !h && (d = s.shift() + n2.nominalWidthX, h = true), v4 += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o22" == P2) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o25" == P2) {
            for (; s.length > 6; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
            c = l + s.shift(), p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4 + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          } else if ("o26" == P2) for (s.length % 2 && (l += s.shift()); s.length > 0; ) c = l, p = v4 + s.shift(), l = U2 = c + s.shift(), v4 = (g4 = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          else if ("o27" == P2) for (s.length % 2 && (v4 += s.shift()); s.length > 0; ) p = v4, U2 = (c = l + s.shift()) + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), v4 = g4, e.U.P.curveTo(o, c, p, U2, g4, l, v4);
          else if ("o10" == P2 || "o29" == P2) {
            var L = "o10" == P2 ? n2 : a2;
            if (0 == s.length) console.debug("error: empty stack");
            else {
              var W2 = s.pop(), M3 = L.Subrs[W2 + L.Bias];
              t3.x = l, t3.y = v4, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f, e.U._drawCFF(M3, t3, a2, n2, o), l = t3.x, v4 = t3.y, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open;
            }
          } else if ("o30" == P2 || "o31" == P2) {
            var V2 = s.length, E3 = (G2 = 0, "o31" == P2);
            for (G2 += V2 - (x = -3 & V2); G2 < x; ) E3 ? (p = v4, U2 = (c = l + s.shift()) + s.shift(), v4 = (g4 = p + s.shift()) + s.shift(), x - G2 == 5 ? (l = U2 + s.shift(), G2++) : l = U2, E3 = false) : (c = l, p = v4 + s.shift(), U2 = c + s.shift(), g4 = p + s.shift(), l = U2 + s.shift(), x - G2 == 5 ? (v4 = g4 + s.shift(), G2++) : v4 = g4, E3 = true), e.U.P.curveTo(o, c, p, U2, g4, l, v4), G2 += 4;
          } else {
            if ("o" == (P2 + "").charAt(0)) throw console.debug("Unknown operation: " + P2, r2), P2;
            s.push(P2);
          }
        }
      }
      t3.x = l, t3.y = v4, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f;
    };
    var t2 = e, a = { Typr: t2 };
    return r.Typr = t2, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory2() {
  return function(r) {
    var e = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n2(31), i2 = 0; i2 < 31; ++i2) a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t2(a2[30]);
      for (i2 = 1; i2 < 30; ++i2) for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2) o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u2 = f(a, 2), v4 = u2[0], s = u2[1];
    v4[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n2(32768), g4 = 0; g4 < 32768; ++g4) {
      var h = (43690 & g4) >>> 1 | (21845 & g4) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g4] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a2 = r2.length, i2 = 0, o2 = new n2(e2); i2 < a2; ++i2) ++o2[r2[i2] - 1];
      var f2, u3 = new n2(e2);
      for (i2 = 0; i2 < e2; ++i2) u3[i2] = u3[i2 - 1] + o2[i2 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e2);
        var v5 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2) if (r2[i2]) for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g5 = u3[r2[i2] - 1]++ << l2, h2 = g5 | (1 << l2) - 1; g5 <= h2; ++g5) f2[c[g5] >>> v5] = s2;
      } else for (f2 = new n2(a2), i2 = 0; i2 < a2; ++i2) r2[i2] && (f2[i2] = c[u3[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g4 = 0; g4 < 144; ++g4) d[g4] = 8;
    for (g4 = 144; g4 < 256; ++g4) d[g4] = 9;
    for (g4 = 256; g4 < 280; ++g4) d[g4] = 7;
    for (g4 = 280; g4 < 288; ++g4) d[g4] = 8;
    var m = new e(32);
    for (g4 = 0; g4 < 32; ++g4) m[g4] = 5;
    var b = w(d, 9, 1), p = w(m, 5, 1), y2 = function(r2) {
      for (var e2 = r2[0], n3 = 1; n3 < r2.length; ++n3) r2[n3] > e2 && (e2 = r2[n3]);
      return e2;
    }, L = function(r2, e2, n3) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n3;
    }, U2 = function(r2, e2) {
      var n3 = e2 / 8 | 0;
      return (r2[n3] | r2[n3 + 1] << 8 | r2[n3 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T4 = function(r2, e2, n3) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T4), !n3) throw t3;
      return t3;
    }, O3 = function(r2, f2, u3) {
      var s2 = r2.length;
      if (!s2 || u3 && !u3.l && s2 < 5) return f2 || new e(0);
      var c2 = !f2 || u3, g5 = !u3 || u3.i;
      u3 || (u3 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n3 = f2.length;
        if (r3 > n3) {
          var t3 = new e(Math.max(2 * n3, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u3.f || 0, k2 = u3.p || 0, O4 = u3.b || 0, A4 = u3.l, x2 = u3.d, E3 = u3.m, D2 = u3.n, M3 = 8 * s2;
      do {
        if (!A4) {
          u3.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V2 = r2[(I4 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I4 - 3] << 8, _ = I4 + V2;
            if (_ > s2) {
              g5 && T4(0);
              break;
            }
            c2 && d2(O4 + V2), f2.set(r2.subarray(I4, _), O4), u3.b = O4 += V2, u3.p = k2 = 8 * _;
            continue;
          }
          if (1 == S) A4 = b, x2 = p, E3 = 9, D2 = 5;
          else if (2 == S) {
            var j2 = L(r2, k2, 31) + 257, z2 = L(r2, k2 + 10, 15) + 4, C3 = j2 + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F3 = new e(C3), P2 = new e(19), q2 = 0; q2 < z2; ++q2) P2[o[q2]] = L(r2, k2 + 3 * q2, 7);
            k2 += 3 * z2;
            var B3 = y2(P2), G2 = (1 << B3) - 1, H2 = w(P2, B3, 1);
            for (q2 = 0; q2 < C3; ) {
              var I4, J2 = H2[L(r2, k2, G2)];
              if (k2 += 15 & J2, (I4 = J2 >>> 4) < 16) F3[q2++] = I4;
              else {
                var K3 = 0, N2 = 0;
                for (16 == I4 ? (N2 = 3 + L(r2, k2, 3), k2 += 2, K3 = F3[q2 - 1]) : 17 == I4 ? (N2 = 3 + L(r2, k2, 7), k2 += 3) : 18 == I4 && (N2 = 11 + L(r2, k2, 127), k2 += 7); N2--; ) F3[q2++] = K3;
              }
            }
            var Q2 = F3.subarray(0, j2), R2 = F3.subarray(j2);
            E3 = y2(Q2), D2 = y2(R2), A4 = w(Q2, E3, 1), x2 = w(R2, D2, 1);
          } else T4(1);
          if (k2 > M3) {
            g5 && T4(0);
            break;
          }
        }
        c2 && d2(O4 + 131072);
        for (var W2 = (1 << E3) - 1, X3 = (1 << D2) - 1, Y3 = k2; ; Y3 = k2) {
          var Z3 = (K3 = A4[U2(r2, k2) & W2]) >>> 4;
          if ((k2 += 15 & K3) > M3) {
            g5 && T4(0);
            break;
          }
          if (K3 || T4(2), Z3 < 256) f2[O4++] = Z3;
          else {
            if (256 == Z3) {
              Y3 = k2, A4 = null;
              break;
            }
            var $ = Z3 - 254;
            if (Z3 > 264) {
              var rr = a[q2 = Z3 - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v4[q2], k2 += rr;
            }
            var er = x2[U2(r2, k2) & X3], nr = er >>> 4;
            er || T4(3), k2 += 15 & er;
            R2 = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R2 += U2(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M3) {
              g5 && T4(0);
              break;
            }
            c2 && d2(O4 + 131072);
            for (var tr = O4 + $; O4 < tr; O4 += 4) f2[O4] = f2[O4 - R2], f2[O4 + 1] = f2[O4 + 1 - R2], f2[O4 + 2] = f2[O4 + 2 - R2], f2[O4 + 3] = f2[O4 + 3 - R2];
            O4 = tr;
          }
        }
        u3.l = A4, u3.p = Y3, u3.b = O4, A4 && (m2 = 1, u3.m = E3, u3.d = x2, u3.n = D2);
      } while (!m2);
      return O4 == f2.length ? f2 : function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n2 ? n2 : r3 instanceof t2 ? t2 : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O4);
    }, A3 = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A3, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n3 = 0;
      function t3() {
        var r3 = e2.getUint16(n3);
        return n3 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n3);
        return n3 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b3, r3), b3 += 2;
      }
      function o2(r3) {
        m2.setUint32(b3, r3), b3 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t3(), reserved: t3(), totalSfntSize: a2(), majorVersion: t3(), minorVersion: t3(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u3 = 0; Math.pow(2, u3) <= f2.numTables; ) u3++;
      u3--;
      for (var v5 = 16 * Math.pow(2, u3), s2 = 16 * f2.numTables - v5, l2 = 12, c2 = [], g5 = 0; g5 < f2.numTables; g5++) c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b3 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v5), i2(u3), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n4, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n4 = new Uint8Array(t4, 2), O3(n4, a3);
        } else a3 = new Uint8Array(t4);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory2(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch3) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch3) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535) i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3);
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId];
      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j2 = 0; j2 < lookup.tabs.length; j2++) {
            const tab = lookup.tabs[j2];
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            } else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k = 0; k < right.length; k++) {
                      if (right[k].gid2 === glyphId) adj = right[k];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            } else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            } else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "number") {
        return args[i];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j2 = 1; j2 <= numArgs; j2++) {
                  path += (j2 > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x = crds[i2];
                  let y2 = crds[i2 + 1];
                  if (x < xMin) xMin = x;
                  if (y2 < yMin) yMin = y2;
                  if (x > xMax) xMax = x;
                  if (y2 > yMax) yMax = y2;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(
              null,
              glyphObj,
              penX + positions[i * 3] * fontScale,
              positions[i * 3 + 1] * fontScale,
              charIndex
            );
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule2 = defineWorkerModule2({
  name: "Typr Font Parser",
  dependencies: [typrFactory2, woff2otfFactory2, parserFactory2],
  init(typrFactory3, woff2otfFactory3, parserFactory3) {
    const Typr = typrFactory3();
    const woff2otf = woff2otfFactory3();
    return parserFactory3(Typr, woff2otf);
  }
});
function unicodeFontResolverClientFactory2() {
  return function(t2) {
    var n2 = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    n2.prototype.add = function(t3) {
      var n3 = t3 >> 5;
      this.buckets.set(n3, (this.buckets.get(n3) || 0) | 1 << (31 & t3));
    }, n2.prototype.has = function(t3) {
      var n3 = this.buckets.get(t3 >> 5);
      return void 0 !== n3 && 0 != (n3 & 1 << (31 & t3));
    }, n2.prototype.serialize = function() {
      var t3 = [];
      return this.buckets.forEach(function(n3, r2) {
        t3.push((+r2).toString(36) + ":" + n3.toString(36));
      }), t3.join(",");
    }, n2.prototype.deserialize = function(t3) {
      var n3 = this;
      this.buckets.clear(), t3.split(",").forEach(function(t4) {
        var r2 = t4.split(":");
        n3.buckets.set(parseInt(r2[0], 36), parseInt(r2[1], 36));
      });
    };
    var r = Math.pow(2, 8), e = r - 1, o = ~e;
    function a(t3) {
      var n3 = function(t4) {
        return t4 & o;
      }(t3).toString(16), e2 = function(t4) {
        return (t4 & o) + r - 1;
      }(t3).toString(16);
      return "codepoint-index/plane" + (t3 >> 16) + "/" + n3 + "-" + e2 + ".json";
    }
    function i(t3, n3) {
      var r2 = t3 & e, o2 = n3.codePointAt(r2 / 6 | 0);
      return 0 != ((o2 = (o2 || 48) - 48) & 1 << r2 % 6);
    }
    function u2(t3, n3) {
      var r2;
      (r2 = t3, r2.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(t4) {
        return t4.split("-").map(function(t5) {
          return parseInt(t5.trim(), 16);
        });
      })).forEach(function(t4) {
        var r3 = t4[0], e2 = t4[1];
        void 0 === e2 && (e2 = r3), n3(r3, e2);
      });
    }
    function c(t3, n3) {
      u2(t3, function(t4, r2) {
        for (var e2 = t4; e2 <= r2; e2++) n3(e2);
      });
    }
    var s = {}, f = {}, l = /* @__PURE__ */ new WeakMap(), v4 = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t3) {
      var r2 = l.get(t3);
      return r2 || (r2 = new n2(), c(t3.ranges, function(t4) {
        return r2.add(t4);
      }), l.set(t3, r2)), r2;
    }
    var h, p = /* @__PURE__ */ new Map();
    function g4(t3, n3, r2) {
      return t3[n3] ? n3 : t3[r2] ? r2 : function(t4) {
        for (var n4 in t4) return n4;
      }(t3);
    }
    function w(t3, n3) {
      var r2 = n3;
      if (!t3.includes(r2)) {
        r2 = 1 / 0;
        for (var e2 = 0; e2 < t3.length; e2++) Math.abs(t3[e2] - n3) < Math.abs(r2 - n3) && (r2 = t3[e2]);
      }
      return r2;
    }
    function k(t3) {
      return h || (h = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(t4) {
        h.add(t4);
      })), h.has(t3);
    }
    return t2.CodePointSet = n2, t2.clearCache = function() {
      s = {}, f = {};
    }, t2.getFontsForString = function(t3, n3) {
      void 0 === n3 && (n3 = {});
      var r2, e2 = n3.lang;
      void 0 === e2 && (e2 = new RegExp("\\p{Script=Hangul}", "u").test(r2 = t3) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(r2) ? "ja" : "en");
      var o2 = n3.category;
      void 0 === o2 && (o2 = "sans-serif");
      var u3 = n3.style;
      void 0 === u3 && (u3 = "normal");
      var c2 = n3.weight;
      void 0 === c2 && (c2 = 400);
      var l2 = (n3.dataUrl || v4).replace(/\/$/g, ""), h2 = /* @__PURE__ */ new Map(), y2 = new Uint8Array(t3.length), b = {}, m = {}, A3 = new Array(t3.length), S = /* @__PURE__ */ new Map(), j2 = false;
      function M3(t4) {
        var n4 = p.get(t4);
        return n4 || (n4 = fetch(l2 + "/" + t4).then(function(t5) {
          if (!t5.ok) throw new Error(t5.statusText);
          return t5.json().then(function(t6) {
            if (!Array.isArray(t6) || 1 !== t6[0]) throw new Error("Incorrect schema version; need 1, got " + t6[0]);
            return t6[1];
          });
        }).catch(function(n5) {
          if (l2 !== v4) return j2 || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l2 + '", trying default CDN. ' + n5.message), j2 = true), l2 = v4, p.delete(t4), M3(t4);
          throw n5;
        }), p.set(t4, n4)), n4;
      }
      for (var P2 = function(n4) {
        var r3 = t3.codePointAt(n4), e3 = a(r3);
        A3[n4] = e3, s[e3] || S.has(e3) || S.set(e3, M3(e3).then(function(t4) {
          s[e3] = t4;
        })), r3 > 65535 && (n4++, E3 = n4);
      }, E3 = 0; E3 < t3.length; E3++) P2(E3);
      return Promise.all(S.values()).then(function() {
        S.clear();
        for (var n4 = function(n5) {
          var o3 = t3.codePointAt(n5), a2 = null, u4 = s[A3[n5]], c3 = void 0;
          for (var l3 in u4) {
            var v5 = m[l3];
            if (void 0 === v5 && (v5 = m[l3] = new RegExp(l3).test(e2 || "en")), v5) {
              for (var d2 in c3 = l3, u4[l3]) if (i(o3, u4[l3][d2])) {
                a2 = d2;
                break;
              }
              break;
            }
          }
          if (!a2) {
            t: for (var h3 in u4) if (h3 !== c3) {
              for (var p2 in u4[h3]) if (i(o3, u4[h3][p2])) {
                a2 = p2;
                break t;
              }
            }
          }
          a2 || (console.debug("No font coverage for U+" + o3.toString(16)), a2 = "latin"), A3[n5] = a2, f[a2] || S.has(a2) || S.set(a2, M3("font-meta/" + a2 + ".json").then(function(t4) {
            f[a2] = t4;
          })), o3 > 65535 && (n5++, r3 = n5);
        }, r3 = 0; r3 < t3.length; r3++) n4(r3);
        return Promise.all(S.values());
      }).then(function() {
        for (var n4, r3 = null, e3 = 0; e3 < t3.length; e3++) {
          var a2 = t3.codePointAt(e3);
          if (r3 && (k(a2) || d(r3).has(a2))) y2[e3] = y2[e3 - 1];
          else {
            r3 = f[A3[e3]];
            var i2 = b[r3.id];
            if (!i2) {
              var s2 = r3.typeforms, v5 = g4(s2, o2, "sans-serif"), p2 = g4(s2[v5], u3, "normal"), m2 = w(null === (n4 = s2[v5]) || void 0 === n4 ? void 0 : n4[p2], c2);
              i2 = b[r3.id] = l2 + "/font-files/" + r3.id + "/" + v5 + "." + p2 + "." + m2 + ".woff";
            }
            var S2 = h2.get(i2);
            null == S2 && (S2 = h2.size, h2.set(i2, S2)), y2[e3] = S2;
          }
          a2 > 65535 && (e3++, y2[e3] = y2[e3 - 1]);
        }
        return { fontUrls: Array.from(h2.keys()), chars: y2 };
      });
    }, Object.defineProperty(t2, "__esModule", { value: true }), t2;
  }({});
}
function createFontResolver2(fontParser, unicodeFontResolverClient) {
  const parsedFonts = /* @__PURE__ */ Object.create(null);
  const loadingFonts = /* @__PURE__ */ Object.create(null);
  function doLoadFont(url, callback) {
    const onError2 = (err2) => {
      console.error(`Failure loading font ${url}`, err2);
    };
    try {
      const request = new XMLHttpRequest();
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.status >= 400) {
          onError2(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError2(e);
          }
        }
      };
      request.onerror = onError2;
      request.send();
    } catch (err2) {
      onError2(err2);
    }
  }
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, (fontObj) => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach((cb) => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }
  return function(text, callback, {
    lang,
    fonts: userFonts = [],
    style = "normal",
    weight = "normal",
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = /* @__PURE__ */ new Map();
    const fallbackRanges = [];
    if (style !== "italic") style = "normal";
    if (typeof weight !== "number") {
      weight = weight === "bold" ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice().filter((def) => !def.lang || def.lang.test(lang)).reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j2 = charResolutions[i], jLen = userFonts.length; j2 <= jLen; j2++) {
              if (j2 === jLen) {
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j2;
                const { src, unicodeRange } = userFonts[j2];
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== "number") {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 65535 && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        const fallbackString = fallbackRanges.map((range) => text.substring(range[0], range[1] + 1)).join("\n");
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || void 0,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({ fontUrls, chars }) => {
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach((range) => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++;
          });
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, (fontObj) => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      for (let k = 0; k < ranges.length; k++) {
        const [start, end = start] = ranges[k];
        if (start <= code && code <= end) {
          return true;
        }
      }
      return false;
    }
  };
}
var fontResolverWorkerModule2 = defineWorkerModule2({
  name: "FontResolver",
  dependencies: [
    createFontResolver2,
    workerModule2,
    unicodeFontResolverClientFactory2
  ],
  init(createFontResolver3, fontParser, unicodeFontResolverClientFactory3) {
    return createFontResolver3(fontParser, unicodeFontResolverClientFactory3());
  }
});
function createTypesetter2(resolveFonts, bidi) {
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {
    const onResolved = ({ chars, fonts: parsedFonts }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]] });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(
        text,
        onResolved,
        { lang, fonts, style, weight, unicodeFontsURL }
      );
    }
  }
  function typeset({
    text = "",
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = "normal",
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction: direction2,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now3();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === "string" ? [{ src: font }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, (runs) => {
      timings.fontLoad = now3() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const metricsByFont = /* @__PURE__ */ new Map();
      const typesetStart = now3();
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach((run) => {
        const { fontObj } = run;
        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
        let fontData2 = metricsByFont.get(fontObj);
        if (!fontData2) {
          const fontSizeMult2 = fontSize / unitsPerEm;
          const calcLineHeight = lineHeight === "normal" ? (ascender - descender + lineGap) * fontSizeMult2 : lineHeight * fontSize;
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult2) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult2);
          const caretTop = (ascender + descender) / 2 * fontSizeMult2 + caretHeight / 2;
          fontData2 = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult: fontSizeMult2,
            unitsPerEm,
            ascender: ascender * fontSizeMult2,
            descender: descender * fontSizeMult2,
            capHeight: capHeight * fontSizeMult2,
            xHeight: xHeight * fontSizeMult2,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult2,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData2);
        }
        const { fontSizeMult } = fontData2;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;
          if (!("isEmpty" in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              for (let i = curLineCount; i--; ) {
                if (i === 0 && overflowWrap === "break-word") {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j2 = nextLine.count; j2--; ) {
                    nextLine.glyphAt(j2).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth;
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData2;
          if (char === "\n") {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });
      let totalHeight = 0;
      lines.forEach((line) => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--; ) {
          const glyphInfo = line.glyphAt(i);
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          let { lineHeight: lineHeight2, capHeight, xHeight, baseline } = glyphInfo.fontData;
          if (lineHeight2 > line.lineHeight) line.lineHeight = lineHeight2;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -lines[0].baseline : anchorY === "top-cap" ? -lines[0].cap : anchorY === "top-ex" ? -lines[0].ex : anchorY === "middle" ? totalHeight / 2 : anchorY === "bottom" ? totalHeight : anchorY === "bottom-baseline" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction2);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j2 = startInLine; j2 < endInLine; j2++) {
                    const glyphInfo = line.glyphAt(j2);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g4) => glyphObj = g4;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex, fontData: fontData2 } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData2.caretBottom + anchorYOffset;
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData2.caretTop + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      const fontData = [];
      metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight }) => {
        fontData[index] = { src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight };
      });
      timings.typesetting = now3() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - totalHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset({ ...args, metricsOnly: true }, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now3() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop2, i, all) => {
    Object.defineProperty(obj, prop2, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure
  };
}
var now2 = () => (self.performance || Date).now();
var mainThreadGenerator2 = SDFGenerator();
var warned2;
function generateSDF2(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker2(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel);
  }
  return generateSDF_GL2(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel).then(
    null,
    (err2) => {
      if (!warned2) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err2);
        warned2 = true;
      }
      return generateSDF_JS_Worker2(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel);
    }
  );
}
var queue2 = [];
var chunkTimeBudget2 = 5;
var timer2 = 0;
function nextChunk2() {
  const start = now2();
  while (queue2.length && now2() - start < chunkTimeBudget2) {
    queue2.shift()();
  }
  timer2 = queue2.length ? setTimeout(nextChunk2, 0) : 0;
}
var generateSDF_GL2 = (...args) => {
  return new Promise((resolve, reject) => {
    queue2.push(() => {
      const start = now2();
      try {
        mainThreadGenerator2.webgl.generateIntoCanvas(...args);
        resolve({ timing: now2() - start });
      } catch (err2) {
        reject(err2);
      }
    });
    if (!timer2) {
      timer2 = setTimeout(nextChunk2, 0);
    }
  });
};
var threadCount2 = 4;
var idleTimeout2 = 2e3;
var threads2 = {};
var callNum2 = 0;
function generateSDF_JS_Worker2(width, height, path, viewBox, distance, exponent, canvas, x, y2, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum2++ % threadCount2;
  let thread = threads2[workerId];
  if (!thread) {
    thread = threads2[workerId] = {
      workerModule: defineWorkerModule2({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now2
        ],
        init(_createSDFGenerator, now3) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now3();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now3() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start = now2();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator2.webglUtils.renderImageData(canvas, imageData, x, y2, width, height, 1 << 3 - channel);
    timing += now2() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker2(workerId);
      }, idleTimeout2);
    }
    return { timing };
  });
}
function warmUpSDFCanvas2(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator2.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing2 = mainThreadGenerator2.webglUtils.resizeWebGLCanvasWithoutClearing;
var CONFIG2 = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor2 = new Color();
var hasRequested2 = false;
function now$12() {
  return (self.performance || Date).now();
}
var atlases2 = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo2(args, callback) {
  hasRequested2 = true;
  args = assign5({}, args);
  const totalStart = now$12();
  const { defaultFontURL } = CONFIG2;
  const fonts = [];
  if (defaultFontURL) {
    fonts.push({ label: "default", src: toAbsoluteURL2(defaultFontURL) });
  }
  if (args.font) {
    fonts.push({ label: "user", src: toAbsoluteURL2(args.font) });
  }
  args.font = fonts;
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG2.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG2.unicodeFontsURL;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key2 in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key2)) {
        let val = args.colorRanges[key2];
        if (typeof val !== "number") {
          val = tempColor2.set(val).getHex();
        }
        colors[key2] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG2;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases2[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases2[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling2(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  typesetInWorker2(args).then((result) => {
    const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$12();
    const fontGlyphMaps = fontData.map((font) => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = /* @__PURE__ */ new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const { src: fontSrc, unitsPerEm } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[fontSrc][glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG2.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$12() - quadsStart);
    const sdfStart = now$12();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing2(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF2(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround2(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$12() - sdfStart;
      timings.total = now$12() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas2(sdfCanvas);
    }
  });
}
function generateGlyphSDF2({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG2;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y2 = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF2(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y2, channel, useGPU);
}
function initContextLossHandling2(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF2(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround2(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function preloadFont({ font, characters, sdfGlyphSize }, callback) {
  let text = Array.isArray(characters) ? characters.join("\n") : "" + characters;
  getTextRenderInfo2({ font, sdfGlyphSize, text }, callback);
}
function assign5(toObj, fromObj) {
  for (let key2 in fromObj) {
    if (fromObj.hasOwnProperty(key2)) {
      toObj[key2] = fromObj[key2];
    }
  }
  return toObj;
}
var linkEl2;
function toAbsoluteURL2(path) {
  if (!linkEl2) {
    linkEl2 = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl2.href = path;
  return linkEl2.href;
}
function safariPre15Workaround2(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule2 = defineWorkerModule2({
  name: "Typesetter",
  dependencies: [
    createTypesetter2,
    fontResolverWorkerModule2,
    bidi_default
  ],
  init(createTypesetter3, fontResolver, bidiFactory2) {
    return createTypesetter3(fontResolver, bidiFactory2());
  }
});
var typesetInWorker2 = defineWorkerModule2({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule2
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
var templateGeometries2 = {};
function getTemplateGeometry2(detail) {
  let geom = templateGeometries2[detail];
  if (!geom) {
    geom = templateGeometries2[detail] = new PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);
  }
  return geom;
}
var glyphBoundsAttrName2 = "aTroikaGlyphBounds";
var glyphIndexAttrName2 = "aTroikaGlyphIndex";
var glyphColorAttrName2 = "aTroikaGlyphColor";
var GlyphsGeometry2 = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry2(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    this.updateAttributeData(glyphBoundsAttrName2, glyphBounds, 4);
    this.updateAttributeData(glyphIndexAttrName2, glyphAtlasIndices, 1);
    this.updateAttributeData(glyphColorAttrName2, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max: max2, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max2(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max2(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName2).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--; ) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(attrName, newArray, itemSize) {
    const attr = this.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        this.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete this._maxInstanceCount;
        this.dispose();
      }
    } else if (attr) {
      this.deleteAttribute(attrName);
    }
  }
};
var VERTEX_DEFS2 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM2 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS2 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM2 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial2(baseMaterial) {
  const textMaterial = createDerivedMaterial2(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS2,
    vertexTransform: VERTEX_TRANSFORM2,
    fragmentDefs: FRAGMENT_DEFS2,
    fragmentColorTransform: FRAGMENT_TRANSFORM2,
    customRewriter({ vertexShader: vertexShader9, fragmentShader: fragmentShader9 }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader9)) {
        fragmentShader9 = fragmentShader9.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader9)) {
          vertexShader9 = vertexShader9.replace(
            voidMainRegExp2,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader: vertexShader9, fragmentShader: fragmentShader9 };
    }
  });
  textMaterial.transparent = true;
  textMaterial.forceSinglePass = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial2 = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
var defaultStrokeColor2 = 8421504;
var tempMat42 = new Matrix4();
var tempVec3a2 = new Vector3();
var tempVec3b2 = new Vector3();
var tempArray2 = [];
var origin3 = new Vector3();
var defaultOrient2 = "+x+y";
function first2(o) {
  return Array.isArray(o) ? o[0] : o;
}
var getFlatRaycastMesh2 = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial2
  );
  getFlatRaycastMesh2 = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh2 = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial2
  );
  getCurvedRaycastMesh2 = () => mesh;
  return mesh;
};
var syncStartEvent2 = { type: "syncstart" };
var syncCompleteEvent2 = { type: "synccomplete" };
var SYNCABLE_PROPS2 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS2 = SYNCABLE_PROPS2.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text2 = class extends Mesh {
  constructor() {
    const geometry = new GlyphsGeometry2();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.unicodeFontsURL = null;
    this.fontSize = 0.1;
    this.fontWeight = "normal";
    this.fontStyle = "normal";
    this.lang = null;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor2;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient2;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent2);
        getTextRenderInfo2({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || "normal",
          fontStyle: this.fontStyle || "normal",
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent2);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(baseMaterial) {
    return createTextDerivedMaterial2(baseMaterial);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial2.clone());
    if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {
      derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first2(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first2(this.material).getDistanceMaterial();
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor2 : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaDistanceOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
    const color2 = isOutline ? this.outlineColor || 0 : this.color;
    if (color2 == null) {
      delete material.color;
    } else {
      const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
      if (color2 !== colorObj._input || typeof color2 === "object") {
        colorObj.set(colorObj._input = color2);
      }
    }
    let orient = this.orientation || defaultOrient2;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient2 && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a2.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b2.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat42.lookAt(origin3, tempVec3a2.cross(tempVec3b2), tempVec3b2);
        rotMat.setFromMatrix4(tempMat42);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position2, target = new Vector2()) {
    target.copy(position2);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position2.x, Math.abs(r) - Math.abs(position2.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position2, target = new Vector2()) {
    tempVec3a2.copy(position2);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a2), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh2() : getFlatRaycastMesh2();
      const geom = raycastMesh.geometry;
      const { position: position2, uv } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y2 = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z2 = 0;
        if (curveRadius) {
          z2 = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position2.setXYZ(i, x, y2, z2);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray2.length = 0;
      raycastMesh.raycast(raycaster, tempArray2);
      for (let i = 0; i < tempArray2.length; i++) {
        tempArray2[i].object = this;
        intersects.push(tempArray2[i]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS2.forEach((prop2) => {
      this[prop2] = source[prop2];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS2.forEach((prop2) => {
  const privateKey = "_private_" + prop2;
  Object.defineProperty(Text2.prototype, prop2, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});
var floatsPerMember = 17;
floatsPerMember = Math.ceil(floatsPerMember / 4) * 4;
var tempBox32 = new Box3();
var tempColor$12 = new Color();

// node_modules/@threlte/extras/dist/components/Text/Text.svelte
mark_module_start();
Text_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Text/Text.svelte";
function Text_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text_1);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "font",
      "characters",
      "sdfGlyphSize",
      "ref",
      "onsync",
      "children"
    ],
    "props"
  );
  const text = new Text2();
  const { invalidate } = useThrelte();
  const onUpdate = async () => {
    await tick();
    text.sync(() => {
      var _a2;
      invalidate();
      (_a2 = $$props.onsync) == null ? void 0 : _a2.call($$props);
    });
  };
  const propsToListenTo = [
    "text",
    "anchorX",
    "anchorY",
    "curveRadius",
    "direction",
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "glyphGeometryDetail",
    "sdfGlyphSize",
    "outlineWidth",
    "outlineColor",
    "outlineOpacity",
    "outlineBlur",
    "outlineOffsetX",
    "outlineOffsetY",
    "strokeWidth",
    "strokeColor",
    "strokeOpacity",
    "fillOpacity",
    "characters",
    "colorRanges"
  ];
  observe(() => propsToListenTo.map((key2) => props[key2]), () => {
    onUpdate();
  });
  const suspend = useSuspense();
  user_pre_effect(() => {
    suspend(new Promise((res) => preloadFont(
      {
        font: $$props.font,
        characters: $$props.characters,
        sdfGlyphSize: $$props.sdfGlyphSize
      },
      res
    )));
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: text }, () => props, {
      get font() {
        return $$props.font;
      },
      get characters() {
        return $$props.characters;
      },
      get sdfGlyphSize() {
        return $$props.sdfGlyphSize;
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Text_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: text }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text_1 = hmr(Text_1, () => Text_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text_1[HMR].source;
    set(Text_1[HMR].source, module.default[HMR].original);
  });
}
var Text_default = Text_1;
mark_module_end(Text_1);

// node_modules/@threlte/extras/dist/audio/useThrelteAudio.js
var audioListeners = /* @__PURE__ */ new Map();
var audioCtx = {
  audioListeners,
  addAudioListener: (listener, id = "default") => {
    if (audioListeners.has(id)) {
      console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
      return;
    }
    audioListeners.set(id, listener);
  },
  removeAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    audioListeners.delete(id);
  },
  getAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    return audioListeners.get(id);
  }
};
function useThrelteAudio() {
  return useThrelteUserContext("threlte-audio", audioCtx);
}

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
mark_module_start();
AudioListener2[FILENAME] = "node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte";
function AudioListener2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AudioListener2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "masterVolume",
      "ref",
      "children"
    ],
    "props"
  );
  const listener = new AudioListener();
  const audioContext = listener.context;
  const resumeContext = () => listener.context.resume();
  user_pre_effect(() => {
    if (strict_equals($$props.masterVolume, void 0, false)) {
      listener.setMasterVolume($$props.masterVolume);
    }
  });
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(listener, $$props.id);
  onDestroy(() => {
    removeAudioListener($$props.id);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: listener }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(AudioListener2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: listener }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get audioContext() {
      return audioContext;
    },
    get resumeContext() {
      return resumeContext;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  AudioListener2 = hmr(AudioListener2, () => AudioListener2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AudioListener2[HMR].source;
    set(AudioListener2[HMR].source, module.default[HMR].original);
  });
}
var AudioListener_default = AudioListener2;
mark_module_end(AudioListener2);

// node_modules/@threlte/extras/dist/audio/utils/useAudio.js
var useAudio = (audio, props = {}) => {
  const loaded = currentWritable(false);
  const autoplay = currentWritable(false);
  const shouldPlay = currentWritable(false);
  let audioDestroyed = false;
  const loader = useLoader(AudioLoader);
  const setSrc = async (source) => {
    var _a2, _b2, _c;
    loaded.set(false);
    try {
      if (typeof source === "string") {
        const audioBuffer = await loader.load(source, {
          onProgress(event) {
            var _a3;
            (_a3 = props.onprogress) == null ? void 0 : _a3.call(props, event);
          }
        });
        audio.setBuffer(audioBuffer);
      } else if (source instanceof AudioBuffer) {
        audio.setBuffer(source);
      } else if (source instanceof HTMLMediaElement) {
        audio.setMediaElementSource(source);
      } else if (source instanceof AudioBufferSourceNode) {
        audio.setNodeSource(source);
      } else if (source instanceof MediaStream) {
        audio.setMediaStreamSource(source);
      }
      loaded.set(true);
      audio.buffer ? (_a2 = props.onload) == null ? void 0 : _a2.call(props, audio.buffer) : (_b2 = props.onload) == null ? void 0 : _b2.call(props);
    } catch (error) {
      (_c = props.onerror) == null ? void 0 : _c.call(props, error);
    }
  };
  const setVolume = (volume) => {
    audio.setVolume(volume ?? 1);
  };
  const setPlaybackRate = (playbackRate) => {
    audio.setPlaybackRate(playbackRate ?? 1);
  };
  const play = async (delay) => {
    if (!loaded.current) {
      shouldPlay.set(true);
      return;
    }
    if (audio.context.state !== "running") {
      await audio.context.resume();
      if (audioDestroyed) {
        return;
      }
    }
    return audio.play(delay);
  };
  const pause = () => {
    return audio.pause();
  };
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setAutoPlay = (value) => {
    autoplay.set(value ?? false);
  };
  const setDetune = (value) => {
    if (audio.source && audio.detune) {
      audio.setDetune(value ?? 0);
    }
  };
  const setLoop = (value) => {
    audio.setLoop(value ?? false);
  };
  watch([loaded, autoplay, shouldPlay], ([loaded2, autoplay2, shouldPlay2]) => {
    if (!loaded2) {
      if (audio.isPlaying)
        stop();
      return;
    }
    if (autoplay2 || shouldPlay2) {
      play();
    }
  });
  onDestroy(() => {
    try {
      audioDestroyed = true;
      stop();
    } catch (error) {
      console.warn("Error while destroying audio", error);
    }
  });
  return {
    setVolume,
    setSrc,
    setPlaybackRate,
    setAutoPlay,
    setDetune,
    setLoop,
    play,
    pause,
    stop
  };
};

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
mark_module_start();
Audio2[FILENAME] = "node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte";
function Audio2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Audio2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new Audio(listener);
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSrc($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: audio }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Audio2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Audio2 = hmr(Audio2, () => Audio2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Audio2[HMR].source;
    set(Audio2[HMR].source, module.default[HMR].original);
  });
}
var Audio_default = Audio2;
mark_module_end(Audio2);

// node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte
mark_module_start();
PositionalAudio2[FILENAME] = "node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte";
function PositionalAudio2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PositionalAudio2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "directionalCone",
      "refDistance",
      "rolloffFactor",
      "distanceModel",
      "maxDistance",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new PositionalAudio(listener);
  user_effect(() => {
    if (strict_equals($$props.refDistance, void 0, false)) audio.setRefDistance($$props.refDistance);
    if (strict_equals($$props.rolloffFactor, void 0, false)) audio.setRolloffFactor($$props.rolloffFactor);
    if (strict_equals($$props.distanceModel, void 0, false)) audio.setDistanceModel($$props.distanceModel);
    if (strict_equals($$props.maxDistance, void 0, false)) audio.setMaxDistance($$props.maxDistance);
    if (strict_equals($$props.directionalCone, void 0, false)) {
      audio.setDirectionalCone($$props.directionalCone.coneInnerAngle, $$props.directionalCone.coneOuterAngle, $$props.directionalCone.coneOuterGain);
    }
  });
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc: setSource,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSource($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: audio }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(PositionalAudio2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  PositionalAudio2 = hmr(PositionalAudio2, () => PositionalAudio2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PositionalAudio2[HMR].source;
    set(PositionalAudio2[HMR].source, module.default[HMR].original);
  });
}
var PositionalAudio_default = PositionalAudio2;
mark_module_end(PositionalAudio2);

// node_modules/@threlte/extras/dist/audio/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const { getAudioListener } = useThrelteAudio();
  if (typeof callbackOrId === "function") {
    const listener2 = getAudioListener(id);
    if (!listener2)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener: listener2,
      context: listener2.context
    });
  }
  const listener = getAudioListener(callbackOrId);
  if (!listener)
    throw new Error("No AudioListener found.");
  return {
    listener,
    context: listener.context
  };
}

// node_modules/@threlte/extras/dist/interactivity/defaults.js
var getDefaultComputeFunction = (target) => {
  const { camera } = useThrelte();
  let width = target.current.clientWidth;
  let height = target.current.clientHeight;
  const resizeObserver = new ResizeObserver(([entry]) => {
    width = entry.contentRect.width;
    height = entry.contentRect.height;
  });
  watch(target, (target2) => {
    if (target2)
      resizeObserver.observe(target2);
    return () => {
      if (target2)
        resizeObserver.unobserve(target2);
    };
  });
  return (event, state2) => {
    state2.pointer.update((pointer) => {
      pointer.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
      return pointer;
    });
    state2.raycaster.setFromCamera(state2.pointer.current, camera.current);
  };
};

// node_modules/@threlte/extras/dist/interactivity/context.js
var contextKey = Symbol("interactivity-context");
var getInteractivityContext = () => {
  return getContext(contextKey);
};
var setInteractivityContext = (options) => {
  const target = currentWritable((options == null ? void 0 : options.target) ?? useDOM().dom);
  const context = {
    enabled: currentWritable((options == null ? void 0 : options.enabled) ?? true),
    pointer: currentWritable(new Vector2()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target,
    handlers: /* @__PURE__ */ new WeakMap(),
    compute: (options == null ? void 0 : options.compute) ?? getDefaultComputeFunction(target),
    filter: options == null ? void 0 : options.filter,
    addInteractiveObject: (object, events) => {
      if (context.interactiveObjects.indexOf(object) > -1) {
        return;
      }
      context.handlers.set(object, events);
      context.interactiveObjects.push(object);
    },
    removeInteractiveObject: (object) => {
      const index = context.interactiveObjects.indexOf(object);
      context.interactiveObjects.splice(index, 1);
      context.handlers.delete(object);
    }
  };
  setContext(contextKey, context);
  return context;
};
var useInteractivity = () => {
  const context = getInteractivityContext();
  if (!context) {
    throw new Error("No interactivity context found. Did you forget to implement interactivity()?");
  }
  return context;
};

// node_modules/@threlte/extras/dist/interactivity/plugin.svelte.js
var interactivityEventNames = [
  "onclick",
  "oncontextmenu",
  "ondblclick",
  "onwheel",
  "onpointerup",
  "onpointerdown",
  "onpointerover",
  "onpointerout",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointermissed"
];
var injectInteractivityPlugin = () => {
  injectPlugin("interactivity", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const hasEventHandlers = Object.entries(args.props).some(([key2, value]) => {
      return strict_equals(value, void 0, false) && interactivityEventNames.includes(key2);
    });
    if (!hasEventHandlers) return;
    const { addInteractiveObject, removeInteractiveObject } = useInteractivity();
    observe.pre(() => [args.ref], ([ref]) => {
      addInteractiveObject(ref, args.props);
      return () => {
        removeInteractiveObject(ref);
      };
    });
    return { pluginProps: interactivityEventNames };
  });
};

// node_modules/@threlte/extras/dist/interactivity/setupInteractivity.js
function getIntersectionId(event) {
  return `${(event.eventObject || event.object).uuid}/${event.index}${event.instanceId}`;
}
var DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true]
];
var setupInteractivity = (context) => {
  const { handlers } = useInteractivity();
  const calculateDistance = (event) => {
    const dx = event.offsetX - context.initialClick[0];
    const dy = event.offsetY - context.initialClick[1];
    return Math.round(Math.hypot(dx, dy));
  };
  const cancelPointer = (intersections) => {
    var _a2, _b2;
    for (const hoveredObj of context.hovered.values()) {
      if (intersections.length === 0 || !intersections.some((hit) => {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId;
      })) {
        const { eventObject } = hoveredObj;
        context.hovered.delete(getIntersectionId(hoveredObj));
        const events = handlers.get(eventObject);
        if (events) {
          const data = { ...hoveredObj, intersections };
          (_a2 = events.onpointerout) == null ? void 0 : _a2.call(events, data);
          (_b2 = events.onpointerleave) == null ? void 0 : _b2.call(events, data);
        }
      }
    }
  };
  const getHits = () => {
    if (!context.enabled.current)
      return [];
    const intersections = [];
    const hits = context.raycaster.intersectObjects(context.interactiveObjects, true);
    const filtered = context.filter === void 0 ? hits : context.filter(hits, context);
    for (const hit of filtered) {
      let eventObject = hit.object;
      while (eventObject) {
        if (handlers.has(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  const pointerMissed = (event, objects) => {
    var _a2, _b2;
    for (const object of objects) {
      (_b2 = (_a2 = handlers.get(object)) == null ? void 0 : _a2.onpointermissed) == null ? void 0 : _b2.call(_a2, event);
    }
  };
  const getEventHandler = (name) => {
    if (name === "pointerleave" || name === "pointercancel") {
      return () => {
        context.pointerOverTarget.set(false);
        cancelPointer([]);
      };
    }
    if (name === "pointerenter") {
      return () => {
        context.pointerOverTarget.set(true);
      };
    }
    return (event) => {
      var _a2, _b2, _c, _d;
      const isPointerMove = name === "pointermove";
      const isClickEvent = name === "click" || name === "contextmenu" || name === "dblclick";
      context.compute(event, context);
      const hits = getHits();
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "pointerdown") {
        context.initialClick = [event.offsetX, event.offsetY];
        context.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && hits.length === 0) {
        if (delta <= 2) {
          pointerMissed(event, context.interactiveObjects);
        }
      }
      if (isPointerMove)
        cancelPointer(hits);
      let stopped = false;
      dispatchEvents: for (const hit of hits) {
        const intersectionEvent = {
          stopped,
          ...hit,
          intersections: hits,
          stopPropagation() {
            stopped = true;
            intersectionEvent.stopped = true;
            if (context.hovered.size > 0 && Array.from(context.hovered.values()).some((i) => i.eventObject === hit.eventObject)) {
              const higher = hits.slice(0, hits.indexOf(hit));
              cancelPointer([...higher, hit]);
            }
          },
          camera: context.raycaster.camera,
          delta,
          nativeEvent: event,
          pointer: context.pointer.current,
          ray: context.raycaster.ray
        };
        const events = handlers.get(hit.eventObject);
        if (!events)
          return;
        if (isPointerMove) {
          if (events.onpointerover || events.onpointerenter || events.onpointerout || events.onpointerleave) {
            const id = getIntersectionId(intersectionEvent);
            const hoveredItem = context.hovered.get(id);
            if (!hoveredItem) {
              context.hovered.set(id, intersectionEvent);
              (_a2 = events.onpointerover) == null ? void 0 : _a2.call(events, intersectionEvent);
              (_b2 = events.onpointerenter) == null ? void 0 : _b2.call(events, intersectionEvent);
            } else if (hoveredItem.stopped) {
              intersectionEvent.stopPropagation();
            }
          }
          (_c = events.onpointermove) == null ? void 0 : _c.call(events, intersectionEvent);
        } else {
          if (events[`on${name}`]) {
            if (!isClickEvent || context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
              (_d = events[`on${name}`]) == null ? void 0 : _d.call(events, intersectionEvent);
            }
          } else {
            if (isClickEvent && context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
            }
          }
        }
        if (stopped)
          break dispatchEvents;
      }
    };
  };
  const disconnect = (target) => {
    DOM_EVENTS.forEach(([eventName]) => {
      target.removeEventListener(eventName, getEventHandler(eventName));
    });
  };
  const connect = (target) => {
    DOM_EVENTS.forEach(([eventName, passive]) => {
      target.addEventListener(eventName, getEventHandler(eventName), { passive });
    });
  };
  watch(context.target, (target) => {
    if (target)
      connect(target);
    return () => {
      if (target)
        disconnect(target);
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/index.js
var interactivity = (options) => {
  const context = setInteractivityContext(options);
  injectInteractivityPlugin();
  setupInteractivity(context);
  return context;
};

// node_modules/@threlte/extras/dist/layers/plugin.svelte.js
var injectLayersPlugin = () => {
  injectPlugin("layers", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const ctx = getContext("threlte-layers-context");
    const mergedLayers = derived(() => args.props.layers ?? (ctx == null ? void 0 : ctx.layers));
    const mergedCtx = derived(() => get(mergedLayers) ? { layers: get(mergedLayers) } : void 0);
    setContext("threlte-layers-context", get(mergedCtx));
    const applyLayers = (ref, layers2) => {
      if (strict_equals(layers2, "all")) {
        ref.layers.enableAll();
      } else if (strict_equals(layers2, "none")) {
        ref.layers.disableAll();
      } else if (Array.isArray(layers2)) {
        for (let index = 0; index < 32; index += 1) {
          const layerIndex = index;
          const enabled = layers2.includes(layerIndex);
          if (enabled) {
            ref.layers.enable(index);
          } else {
            ref.layers.disable(index);
          }
        }
      } else if (strict_equals(layers2, void 0, false)) {
        ref.layers.set(layers2);
      }
    };
    observe.pre(() => [args.ref, get(mergedLayers)], ([ref, layers2]) => {
      if (!isInstanceOf(ref, "Object3D")) return;
      applyLayers(ref, layers2);
    });
    return { pluginProps: ["layers"] };
  });
};

// node_modules/@threlte/extras/dist/layers/index.js
var layers = (options) => {
  setContext("threlte-layers-context", {
    layers: (options == null ? void 0 : options.defaultLayers) ?? 0
  });
  injectLayersPlugin();
};

// node_modules/@threejs-kit/instanced-sprite-mesh/dist/index.js
var ye2 = Object.defineProperty;
var we3 = (t2, i, e) => i in t2 ? ye2(t2, i, { enumerable: true, configurable: true, writable: true, value: e }) : t2[i] = e;
var y = (t2, i, e) => (we3(t2, typeof i != "symbol" ? i + "" : i, e), e);
var pe2 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function j(t2) {
  const i = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function e(n2, r) {
    let s = ShaderChunk[r];
    return s ? j(s) : n2;
  }
  return t2.replace(i, e);
}
var M2 = [];
for (let t2 = 0; t2 < 256; t2++)
  M2[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
function $e() {
  const t2 = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n2 = Math.random() * 4294967295 | 0;
  return (M2[t2 & 255] + M2[t2 >> 8 & 255] + M2[t2 >> 16 & 255] + M2[t2 >> 24 & 255] + "-" + M2[i & 255] + M2[i >> 8 & 255] + "-" + M2[i >> 16 & 15 | 64] + M2[i >> 24 & 255] + "-" + M2[e & 63 | 128] + M2[e >> 8 & 255] + "-" + M2[e >> 16 & 255] + M2[e >> 24 & 255] + M2[n2 & 255] + M2[n2 >> 8 & 255] + M2[n2 >> 16 & 255] + M2[n2 >> 24 & 255]).toUpperCase();
}
var U = Object.assign || function() {
  let t2 = arguments[0];
  for (let i = 1, e = arguments.length; i < e; i++) {
    let n2 = arguments[i];
    if (n2)
      for (let r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t2[r] = n2[r]);
  }
  return t2;
};
var ze2 = Date.now();
var ae2 = /* @__PURE__ */ new WeakMap();
var oe = /* @__PURE__ */ new Map();
var He = 1e10;
function N(t2, i) {
  const e = Ge(i);
  let n2 = ae2.get(t2);
  if (n2 || ae2.set(t2, n2 = /* @__PURE__ */ Object.create(null)), n2[e])
    return new n2[e]();
  const r = `_onBeforeCompile${e}`, s = function(o, h) {
    t2.onBeforeCompile.call(this, o, h);
    const g4 = this.customProgramCacheKey() + "|" + o.vertexShader + "|" + o.fragmentShader;
    let c = oe[g4];
    if (!c) {
      const f = Le2(this, o, i, e);
      c = oe[g4] = f;
    }
    o.vertexShader = c.vertexShader, o.fragmentShader = c.fragmentShader, U(o.uniforms, this.uniforms), i.timeUniform && (o.uniforms[i.timeUniform] = {
      get value() {
        return Date.now() - ze2;
      }
    }), this[r] && this[r](o);
  }, a = function() {
    return l(i.chained ? t2 : t2.clone());
  }, l = function(o) {
    const h = Object.create(o, u2);
    return Object.defineProperty(h, "baseMaterial", { value: t2 }), Object.defineProperty(h, "id", { value: He++ }), h.uuid = $e(), h.uniforms = U({}, o.uniforms, i.uniforms), h.defines = U({}, o.defines, i.defines), h.defines[`TROIKA_DERIVED_MATERIAL_${e}`] = "", h.extensions = U({}, o.extensions, i.extensions), h._listeners = void 0, h;
  }, u2 = {
    constructor: { value: a },
    isDerivedMaterial: { value: true },
    type: {
      get: () => t2.type,
      set: (o) => {
        t2.type = o;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(o) {
        const h = this.baseMaterial;
        return o === h || h.isDerivedMaterial && h.isDerivedFrom(o) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return t2.customProgramCacheKey() + "|" + e;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(o) {
        this[r] = o;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(o) {
        return t2.copy.call(this, o), !t2.isShaderMaterial && !t2.isDerivedMaterial && (U(this.extensions, o.extensions), U(this.defines, o.defines), U(this.uniforms, UniformsUtils.clone(o.uniforms))), this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const o = new t2.constructor();
        return l(o).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let o = this._depthMaterial;
        return o || (o = this._depthMaterial = N(
          t2.isDerivedMaterial ? t2.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
          i
        ), o.defines.IS_DEPTH_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let o = this._distanceMaterial;
        return o || (o = this._distanceMaterial = N(
          t2.isDerivedMaterial ? t2.getDistanceMaterial() : new MeshDistanceMaterial(),
          i
        ), o.defines.IS_DISTANCE_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial: o, _distanceMaterial: h } = this;
        o && o.dispose(), h && h.dispose(), t2.dispose.call(this);
      }
    }
  };
  return n2[e] = a, new a();
}
function Le2(t2, { vertexShader: i, fragmentShader: e }, n2, r) {
  let {
    vertexDefs: s,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: u2,
    fragmentDefs: o,
    fragmentMainIntro: h,
    fragmentMainOutro: g4,
    fragmentColorTransform: c,
    customRewriter: f,
    timeUniform: m
  } = n2;
  if (s = s || "", a = a || "", l = l || "", o = o || "", h = h || "", g4 = g4 || "", (u2 || f) && (i = j(i)), (c || f) && (e = e.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), e = j(e)), f) {
    let p = f({ vertexShader: i, fragmentShader: e });
    i = p.vertexShader, e = p.fragmentShader;
  }
  if (c) {
    let p = [];
    e = e.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (d) => (p.push(d), "")
    ), g4 = `${c}
${p.join(`
`)}
${g4}`;
  }
  if (m) {
    const p = `
uniform float ${m};
`;
    s = p + s, o = p + o;
  }
  return u2 && (i = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${i}
`, s = `${s}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u2}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, i = i.replace(/\b(position|normal|uv)\b/g, (p, d, w, _) => /\battribute\s+vec[23]\s+$/.test(_.substr(0, w)) ? d : `troika_${d}_${r}`), t2.map && t2.map.channel > 0 || (i = i.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), i = le(i, r, s, a, l), e = le(e, r, o, h, g4), {
    vertexShader: i,
    fragmentShader: e
  };
}
function le(t2, i, e, n2, r) {
  return (n2 || r || e) && (t2 = t2.replace(
    pe2,
    `
${e}
void troikaOrigMain${i}() {`
  ), t2 += `
void main() {
  ${n2}
  troikaOrigMain${i}();
  ${r}
}`), t2;
}
function ke(t2, i) {
  return t2 === "uniforms" ? void 0 : typeof i == "function" ? i.toString() : i;
}
var Ne = 0;
var ue2 = /* @__PURE__ */ new Map();
function Ge(t2) {
  const i = JSON.stringify(t2, ke);
  let e = ue2.get(i);
  return e == null && ue2.set(i, e = ++Ne), e;
}
var Ze = {
  MeshDepthMaterial: "depth",
  MeshDistanceMaterial: "distanceRGBA",
  MeshNormalMaterial: "normal",
  MeshBasicMaterial: "basic",
  MeshLambertMaterial: "lambert",
  MeshPhongMaterial: "phong",
  MeshToonMaterial: "toon",
  MeshStandardMaterial: "physical",
  MeshPhysicalMaterial: "physical",
  MeshMatcapMaterial: "matcap",
  LineBasicMaterial: "basic",
  LineDashedMaterial: "dashed",
  PointsMaterial: "points",
  ShadowMaterial: "shadow",
  SpriteMaterial: "sprite"
};
function Be2(t2) {
  let i = Ze[t2.type];
  return i ? ShaderLib[i] : t2;
}
function ce(t2) {
  let i = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g, e = /* @__PURE__ */ Object.create(null), n2;
  for (; (n2 = i.exec(t2)) !== null; )
    e[n2[2]] = n2[1];
  return e;
}
function Ke(t2) {
  let i = [], e = "";
  const n2 = N(t2, {
    chained: true,
    customRewriter({ vertexShader: s, fragmentShader: a }) {
      let l = [], u2 = [], o = [], h = ce(s), g4 = ce(a);
      return i.forEach((c) => {
        let f = h[c], m = g4[c];
        const p = f || m;
        if (p) {
          const d = new RegExp(`\\buniform\\s+${p}\\s+${c}\\s*;`, "g"), w = new RegExp(`\\b${c}\\b`, "g"), _ = `troika_attr_${c}`, x = `troika_vary_${c}`;
          if (l.push(`attribute ${p} ${_};`), f && (s = s.replace(d, ""), s = s.replace(w, _)), m) {
            a = a.replace(d, ""), a = a.replace(w, x);
            let v4 = `varying ${m} ${x};`;
            l.push(v4), o.push(v4), u2.push(`${x} = ${_};`);
          }
        }
      }), s = `${l.join(`
`)}
${s.replace(pe2, `
$&
${u2.join(`
`)}`)}`, o.length && (a = `${o.join(`
`)}
${a}`), { vertexShader: s, fragmentShader: a };
    }
  });
  n2.setUniformNames = function(s) {
    i = s || [];
    const a = i.sort().join("|");
    a !== e && (e = a, this.needsUpdate = true);
  };
  const r = n2.customProgramCacheKey();
  return n2.customProgramCacheKey = function() {
    return r + "|" + e;
  }, n2.isInstancedUniformsMaterial = true, n2;
}
var je = class extends InstancedMesh {
  constructor(i, e, n2) {
    super(i, e, n2), this._maxCount = n2, this._instancedUniformNames = [];
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied geometry with one that will
   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather
   * than write to avoid unnecessary wrapping on transient values.
   */
  get geometry() {
    let i = this._derivedGeometry;
    const e = this._baseGeometry;
    return (!i || i.baseGeometry !== e) && (i = this._derivedGeometry = Object.create(e), i.baseGeometry = e, i.attributes = Object.create(e.attributes), e.addEventListener("dispose", function n2() {
      e.removeEventListener("dispose", n2), i.dispose();
    })), i;
  }
  set geometry(i) {
    this._baseGeometry = i;
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the
   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
   */
  get material() {
    let i = this._derivedMaterial;
    const e = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new MeshBasicMaterial());
    return (!i || i.baseMaterial !== e) && (i = this._derivedMaterial = Ke(e), e.addEventListener("dispose", function n2() {
      e.removeEventListener("dispose", n2), i.dispose();
    })), i.setUniformNames(this._instancedUniformNames), i;
  }
  set material(i) {
    if (Array.isArray(i))
      throw new Error("InstancedUniformsMesh does not support multiple materials");
    for (; i && i.isInstancedUniformsMaterial; )
      i = i.baseMaterial;
    this._baseMaterial = i;
  }
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  /**
   * Set the value of a shader uniform for a single instance.
   * @param {string} name - the name of the shader uniform
   * @param {number} index - the index of the instance to set the value for
   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance
   */
  setUniformAt(i, e, n2) {
    const r = this.geometry.attributes, s = `troika_attr_${i}`;
    let a = r[s];
    if (!a) {
      const l = We(this._baseMaterial, i), u2 = Ye(l);
      if (a = r[s] = new InstancedBufferAttribute(new Float32Array(u2 * this._maxCount), u2), l !== null)
        for (let o = 0; o < this._maxCount; o++)
          fe2(a, o, l);
      this._instancedUniformNames = [...this._instancedUniformNames, i];
    }
    fe2(a, e, n2), a.needsUpdate = true;
  }
  /**
   * Unset all instance-specific values for a given uniform, reverting back to the original
   * uniform value for all.
   * @param {string} name
   */
  unsetUniform(i) {
    this.geometry.deleteAttribute(`troika_attr_${i}`), this._instancedUniformNames = this._instancedUniformNames.filter((e) => e !== i);
  }
};
function fe2(t2, i, e) {
  let n2 = t2.itemSize;
  n2 === 1 ? t2.setX(i, e) : n2 === 2 ? t2.setXY(i, e.x, e.y) : n2 === 3 ? e.isColor ? t2.setXYZ(i, e.r, e.g, e.b) : t2.setXYZ(i, e.x, e.y, e.z) : n2 === 4 ? t2.setXYZW(i, e.x, e.y, e.z, e.w) : e.toArray ? e.toArray(t2.array, i * n2) : t2.set(e, i * n2);
}
function We(t2, i) {
  let e = t2.uniforms;
  return e && e[i] || (e = Be2(t2).uniforms, e && e[i]) ? e[i].value : null;
}
function Ye(t2) {
  return t2 == null ? 0 : typeof t2 == "number" ? 1 : t2.isVector2 ? 2 : t2.isVector3 || t2.isColor ? 3 : t2.isVector4 || t2.isQuaternion ? 4 : t2.elements ? t2.elements.length : Array.isArray(t2) ? t2.length : 0;
}
var Xe = (t2, i) => {
  const e = t2.split(`
`), n2 = /vMapUv|vAlphaMapUv|vNormalMapUv/g;
  return e.map((s) => !s.includes("varying") && !s.includes("uniform") ? s.replace(n2, i) : s).join(`
`);
};
var Je = (t2, i) => {
  const e = {
    USE_UV: ""
  };
  return i && (e.TRI_GEOMETRY = ""), N(t2, {
    defines: e,
    uniforms: {
      /** GPGPU animation driven data */
      animationData: { value: null },
      animationDataSize: { value: 0 },
      /* Repeat animation in a loop */
      billboarding: { value: 0 },
      /** flip uvs on x */
      flipX: { value: 0 },
      /** flip uvs on y */
      flipY: { value: 0 },
      /**
       * DataArrayTexture - data stored in columns. Rows are:
       * 0 - Frames declaration - RGBA[x,y,w,h]
       * 1 - Animation lengths RGBA[length,0,0,0]
       * 2 - Animation0 - RGBA [id,duration, 0,0]
       * 3 - Animation1 - RGBA [id,duration, 0,0]
       * ....etc
       */
      spritesheetData: { value: null },
      /**util for reading data texture in spritesheetData */
      dataSize: { value: new Vector2(0, 0) },
      /**
       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))
       */
      tint: { value: new Vector4(0, 0, 0, 0) }
    },
    /**
     *
     * VERTEX
     * - billboarding
     *
     * */
    vertexDefs: (
      /*glsl*/
      `
    uniform float billboarding;
    flat varying int vId;
    `
    ),
    vertexMainOutro: (
      /*glsl*/
      `
    vId = gl_InstanceID;
    if(billboarding == 1.){
      vec3 instancePosition = vec3(instanceMatrix[3]);
      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));

      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

      vec3 vertexPosition_worldspace = instancePosition
        + cameraRight_worldspace * position.x * instanceScale.x
        + cameraUp_worldspace * position.y * instanceScale.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);
    }
    `
    ),
    /**
     *
     * FRAGMENT REWRITER
     *
     * */
    customRewriter: ({ vertexShader: r, fragmentShader: s }) => {
      const a = (
        /*glsl*/
        `
			uniform sampler2D animationData;
      uniform int animationDataSize;
			uniform sampler2D spritesheetData;
      uniform float startTime;
			uniform float time;
			uniform float flipX;
			uniform float flipY;
			uniform vec2 dataSize;
      uniform vec4 tint;

      flat varying int vId;
			`
      ), l = (
        /*glsl*/
        `
			vec4 readData(float col, float row) {
				float wStep = 1.f / dataSize.x;
				float wHalfStep = wStep * 0.5f;
				float hStep = 1.f / dataSize.y;
				float hHalfStep = 1.f / dataSize.y * 0.5f;
				return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
			}

      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {
        // Shift UVs so that the zoom center is the origin
        vec2 shiftedUV = uv - zoomCenter;

        // Scale (zoom) the UV coordinates
        shiftedUV *= zoomFactor;

        // Shift back
        shiftedUV += zoomCenter;

        return shiftedUV;
    }
			`
      ), u2 = (
        /*glsl*/
        `
      float y = float(vId / animationDataSize) / float(animationDataSize);
      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);

      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;

			// x,y,w,h
			vec4 frameMeta = readData(spritesheetFrameId, 0.f);

			vec2 fSize = frameMeta.zw;
			vec2 fOffset = vec2(frameMeta.xy);

      vec2 transformedPlaneUv = vUv + vec2(0.,0.);

      // todo  == 1. caused a flickering bug. look into Precision/interpolation?
      if(flipX > 0.){
        transformedPlaneUv.x = 1. - transformedPlaneUv.x;
      }
      if(flipY > 0.){
        transformedPlaneUv.y = 1. - transformedPlaneUv.y;
      }

			vec2 spriteUv = fSize * transformedPlaneUv + fOffset ;

      #ifdef TRI_GEOMETRY
        // Shift UVs if mesh uses triangle geometry
        // TODO optimize ugly math
        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){
          discard;
        }

        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;
        float zoomFactor = 2.;
        vec2 shiftedUV = spriteUv - zoomCenter;
        shiftedUV *= zoomFactor;
        shiftedUV += zoomCenter;
        spriteUv = shiftedUV;
      #endif



			`
      );
      return s = s.replace(
        "void main() {",
        `void main() {${u2}`
      ), s = `
			${a}
			${l}
			${s}
			`, s = s.replace(
        "vec4 sampledDiffuseColor = texture2D( map, vMapUv );",
        /*glsl*/
        `
        vec4 sampledDiffuseColor = texture2D( map, vMapUv );
        if(tint.w == 1.){
          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);
          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));
          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));
          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);
          res = res * tint.z;

          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);
        }

        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);
      `
      ), s = Xe(s, "spriteUv"), { vertexShader: r, fragmentShader: s };
    }
  });
};
var Yt = (t2) => {
  const i = [], e = [], n2 = {}, r = [], s = t2.meta.size.w, a = t2.meta.size.h, l = [
    t2.meta.size.w,
    t2.meta.size.h
  ];
  for (const u2 in t2.frames) {
    const o = t2.frames[u2];
    i.push([o.frame.x / s, o.frame.y / a, o.frame.w / s, o.frame.h / a]), e.push(o.duration);
  }
  for (const u2 of t2.meta.frameTags) {
    n2[u2.name] = [];
    for (let o = u2.from; o <= u2.to; o++)
      n2[u2.name].push([o, e[o]]);
    r.push(n2[u2.name].length);
  }
  return { frames: i, animations: n2, sheetSize: l, animationLengths: r };
};
var Qe = (t2) => {
  const { frames: i, animationLengths: e, animations: n2 } = t2, r = Math.max(
    i.length,
    e.length,
    ...Object.values(n2).map((f) => f.length)
  ), s = 2 + Object.values(n2).length, a = i.flat().concat(new Array((r - i.length) * 4).fill(0)), l = e.map((f) => [f, 0, 0, 0]).flat().concat(new Array((r - e.length) * 4).fill(0)), u2 = [], o = /* @__PURE__ */ new Map();
  for (let f = 0; f < Object.keys(n2).length; f++) {
    const m = Object.keys(n2)[f];
    o.set(m, f);
    const p = n2[m].map((d) => [...d, 0, 0]).flat().concat(new Array((r - n2[m].length) * 4).fill(0));
    u2.push(...p);
  }
  const h = [
    ...a,
    ...l,
    ...u2
  ], g4 = new Float32Array(h);
  g4.set(h);
  const c = new DataTexture(
    g4,
    r,
    s,
    RGBAFormat,
    FloatType
  );
  return c.type = FloatType, c.minFilter = NearestFilter, c.magFilter = NearestFilter, c.wrapS = ClampToEdgeWrapping, c.wrapT = RepeatWrapping, c.needsUpdate = true, { dataTexture: c, dataWidth: r, dataHeight: s, animMap: o };
};
var qe = () => {
  const t2 = new BufferGeometry(), i = new Float32Array([
    // top
    0,
    1,
    0,
    // bot-left
    -1,
    -1,
    0,
    // bot-right
    1,
    -1,
    0
  ]);
  t2.setAttribute("position", new BufferAttribute(i, 3));
  const e = new Float32Array([
    // top
    0.5,
    1,
    // bot-left
    0,
    0,
    // bot-right
    1,
    0
  ]);
  return t2.setAttribute("uv", new BufferAttribute(e, 2)), t2.computeVertexNormals(), t2;
};
var et2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var tt2 = class extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var it2 = new tt2();
var nt = class {
  constructor(i) {
    this._mesh = new Mesh(it2, i);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(i) {
    i.render(this._mesh, et2);
  }
  get material() {
    return this._mesh.material;
  }
  set material(i) {
    this._mesh.material = i;
  }
};
var rt2 = class {
  constructor(i, e, n2) {
    this.variables = [], this.currentTextureIndex = 0;
    let r = FloatType;
    const s = {
      passThruTexture: { value: null }
    }, a = o(g4(), s), l = new nt(a);
    this.setDataType = function(c) {
      return r = c, this;
    }, this.addVariable = function(c, f, m) {
      const p = this.createShaderMaterial(f), d = {
        name: c,
        initialValueTexture: m,
        material: p,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: NearestFilter,
        magFilter: NearestFilter
      };
      return this.variables.push(d), d;
    }, this.setVariableDependencies = function(c, f) {
      c.dependencies = f;
    }, this.init = function() {
      if (n2.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let c = 0; c < this.variables.length; c++) {
        const f = this.variables[c];
        f.renderTargets[0] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), f.renderTargets[1] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), this.renderTexture(f.initialValueTexture, f.renderTargets[0]), this.renderTexture(f.initialValueTexture, f.renderTargets[1]);
        const m = f.material, p = m.uniforms;
        if (f.dependencies !== null)
          for (let d = 0; d < f.dependencies.length; d++) {
            const w = f.dependencies[d];
            if (w.name !== f.name) {
              let _ = false;
              for (let x = 0; x < this.variables.length; x++)
                if (w.name === this.variables[x].name) {
                  _ = true;
                  break;
                }
              if (!_)
                return "Variable dependency not found. Variable=" + f.name + ", dependency=" + w.name;
            }
            p[w.name] = { value: null }, m.fragmentShader = `
uniform sampler2D ` + w.name + `;
` + m.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const c = this.currentTextureIndex, f = this.currentTextureIndex === 0 ? 1 : 0;
      for (let m = 0, p = this.variables.length; m < p; m++) {
        const d = this.variables[m];
        if (d.dependencies !== null) {
          const w = d.material.uniforms;
          for (let _ = 0, x = d.dependencies.length; _ < x; _++) {
            const v4 = d.dependencies[_];
            w[v4.name].value = v4.renderTargets[c].texture;
          }
        }
        this.doRenderTarget(d.material, d.renderTargets[f]);
      }
      this.currentTextureIndex = f;
    }, this.getCurrentRenderTarget = function(c) {
      return c.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(c) {
      return c.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.dispose();
      const c = this.variables;
      for (let f = 0; f < c.length; f++) {
        const m = c[f];
        m.initialValueTexture && m.initialValueTexture.dispose();
        const p = m.renderTargets;
        for (let d = 0; d < p.length; d++)
          p[d].dispose();
      }
    };
    function u2(c) {
      c.defines.resolution = "vec2( " + i.toFixed(1) + ", " + e.toFixed(1) + " )";
    }
    this.addResolutionDefine = u2;
    function o(c, f) {
      f = f || {};
      const m = new ShaderMaterial({
        name: "GPUComputationShader",
        uniforms: f,
        vertexShader: h(),
        fragmentShader: c
      });
      return u2(m), m;
    }
    this.createShaderMaterial = o, this.createRenderTarget = function(c, f, m, p, d, w) {
      return c = c || i, f = f || e, m = m || ClampToEdgeWrapping, p = p || ClampToEdgeWrapping, d = d || NearestFilter, w = w || NearestFilter, new WebGLRenderTarget(c, f, {
        wrapS: m,
        wrapT: p,
        minFilter: d,
        magFilter: w,
        format: RGBAFormat,
        type: r,
        depthBuffer: false
      });
    }, this.createTexture = function() {
      const c = new Float32Array(i * e * 4), f = new DataTexture(c, i, e, RGBAFormat, FloatType);
      return f.needsUpdate = true, f;
    }, this.renderTexture = function(c, f) {
      s.passThruTexture.value = c, this.doRenderTarget(a, f), s.passThruTexture.value = null;
    }, this.doRenderTarget = function(c, f) {
      const m = n2.getRenderTarget(), p = n2.xr.enabled, d = n2.shadowMap.autoUpdate;
      n2.xr.enabled = false, n2.shadowMap.autoUpdate = false, l.material = c, n2.setRenderTarget(f), l.render(n2), l.material = a, n2.xr.enabled = p, n2.shadowMap.autoUpdate = d, n2.setRenderTarget(m);
    };
    function h() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function g4() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
};
var st = (
  /*glsl*/
  `
  #include <common>
  uniform sampler2D instructionsTexture;

  uniform sampler2D spritesheetData;
  uniform vec2 dataSize;
  uniform float fps;
  uniform float deltaTime;

  // read spritesheet metadata
  vec4 readData(float col, float row, sampler2D tex) {
    float wStep = 1.f / dataSize.x;
    float wHalfStep = wStep * 0.5f;
    float hStep = 1.f / dataSize.y;
    float hHalfStep = 1.f / dataSize.y * 0.5f;
    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
  }



  void main()	{

    // OUTPUT FROM THIS SHADER
    // progressValue.r - picked animation frame
    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)
    // progressValue.b - not used yet
    // progressValue.a - previous animationID

    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;


    vec4 progressValue = texture2D( progress, uv );

    vec4 instructions = texture2D( instructionsTexture, uv);

    // FREEZE FRAME - return to save calculations?
    if(instructions.a >=10.){
      progressValue.r = instructions.a - 10.;
      progressValue.a = instructions.x;
      progressValue.g = progressValue.g;
      gl_FragColor = progressValue;
      return;
    }


    progressValue.b = 0.;

    // todo shouldn't be rounding here, pick
    float animationId = round(instructions.x);

    float offset = instructions.g;

    float animLength = readData(animationId, 1.f, spritesheetData).r;
    float totalTime = animLength / fps;

    // new delta is % of animation
    float newProgress = deltaTime / totalTime;
    // add new delta to saved progress
    float frameTimedId = mod(progressValue.g + newProgress, 1.);
    // frameTimedId = 0.;
    // float frameTimedId = progressValue.g;
    // save for use in next frame



    float playMode = mod(instructions.b, 10.);

    // forward
    if(playMode == 0.){
      frameTimedId = progressValue.g + newProgress;
    }
    // reverse
    if(playMode == 1.){
      frameTimedId = progressValue.g - newProgress;
    }
    // 2 - pause - do nothing
    if(playMode == 2.){
      frameTimedId = progressValue.g;
    }

    // //todo pingpong
    // if(playMode == 3.){
    // }

    // loop (play once over 10.)
    if(instructions.b < 10.){
      frameTimedId = mod(frameTimedId, 1.);
    }

    // todo This could be optional and user would reset manually,
    // todo allowing for consistent movement across multiple animations
    // todo for example - running steps being syncec
    // start anim from beginning if animationID changes
    if(progressValue.a != instructions.x){
      frameTimedId = 0.;
    }

    float frameId = floor(animLength * frameTimedId);
    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;



    // Picked sprite frame that goes to material
    progressValue.r = spritesheetFrameId;

    progressValue.a = instructions.x;
    progressValue.g = frameTimedId;

    gl_FragColor = progressValue;
  }
`
);
var at2 = (t2 = 512) => {
  const i = new Float32Array(t2 ** 2 * 4);
  for (let n2 = 0; n2 < t2 ** 2 * 4; n2++)
    i[n2] = 0;
  const e = new DataTexture(
    i,
    t2,
    t2,
    RGBAFormat,
    FloatType
  );
  return e.minFilter = NearestFilter, e.magFilter = NearestFilter, e.wrapS = ClampToEdgeWrapping, e.wrapT = RepeatWrapping, e.needsUpdate = true, e;
};
var ot = (t2) => {
  if (t2 <= 0)
    return 1;
  let i = 1;
  for (; i < t2; )
    i <<= 1;
  return i;
};
var lt = (t2, i) => {
  const e = ot(Math.sqrt(i)), n2 = new rt2(
    e,
    e,
    t2
  ), r = n2.createTexture(), s = n2.addVariable(
    "progress",
    st,
    r
  ), a = at2(e);
  s.material.uniforms.instructionsTexture = {
    value: a
  }, s.material.uniforms.spritesheetData = { value: null }, s.material.uniforms.fps = { value: 0 }, s.material.uniforms.deltaTime = { value: 0 }, s.material.uniforms.dataSize = { value: new Vector2() }, n2.setVariableDependencies(s, [s]);
  const l = n2.init();
  l !== null && console.error(l);
  let u2 = false;
  return {
    gpuCompute: n2,
    animationRunner: s,
    progressDataTexture: a,
    utils: {
      updateAnimationAt: (m, p) => {
        const d = m * 4;
        a.image.data[d] = p, u2 = true;
      },
      updateOffsetAt: (m, p) => {
        const d = m * 4;
        a.image.data[d + 1] = p, u2 = true;
      },
      updatePlaymodeAt: (m, p) => {
        const d = m * 4;
        a.image.data[d + 2] = p, u2 = true;
      },
      updateFrameAt: (m, p) => {
        const d = m * 4;
        a.image.data[d + 3] = p + 10, u2 = true;
      }
    },
    update: () => {
      u2 && (a.needsUpdate = true, u2 = false), n2.compute();
    }
  };
};
var ut2 = class {
  constructor() {
    y(this, "_previousTime");
    y(this, "_currentTime");
    y(this, "_startTime");
    y(this, "_delta");
    y(this, "_elapsed");
    y(this, "_timescale");
    y(this, "_useFixedDelta");
    y(this, "_fixedDelta");
    y(this, "_usePageVisibilityAPI");
    y(this, "_pageVisibilityHandler");
    this._previousTime = 0, this._currentTime = 0, this._startTime = B2(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = false, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === true && (this._pageVisibilityHandler = ct3.bind(this), document.addEventListener(
      "visibilitychange",
      this._pageVisibilityHandler,
      false
    ));
  }
  disableFixedDelta() {
    return this._useFixedDelta = false, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === true && document.removeEventListener(
      "visibilitychange",
      this._pageVisibilityHandler
    ), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = true, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = B2() - this._startTime, this;
  }
  setFixedDelta(i) {
    return this._fixedDelta = i * 1e3, this;
  }
  setTimescale(i) {
    return this._timescale = i, this;
  }
  update() {
    return this._useFixedDelta === true ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = B2() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
};
function B2() {
  return (typeof performance > "u" ? Date : performance).now();
}
function ct3() {
  document.hidden === false && this.reset();
}
var K2 = {
  FORWARD: 0,
  REVERSE: 1,
  PAUSE: 2,
  PINGPONG: 3
};
var Xt = class extends je {
  constructor(e, n2, r, s = {
    geometry: "quad"
  }) {
    let a;
    s.geometry || (s.geometry = "quad"), s.geometry === "tri" && (a = qe()), s.geometry === "quad" && (a = new PlaneGeometry(1, 1)), s.geometry && typeof s.geometry != "string" && (a = s.geometry);
    const l = Je(
      e,
      (s == null ? void 0 : s.geometry) === "tri"
    );
    super(a, l, n2);
    y(this, "_spriteMaterial");
    y(this, "_spritesheet");
    y(this, "_animationMap");
    y(this, "_fps", 15);
    y(this, "_timer");
    y(this, "compute");
    REVISION >= 159 ? (this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, n2 * 16)) : this.instanceMatrix.updateRange.count = n2 * 16, this.instanceColor && (REVISION >= 159 ? (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, n2 * 3)) : this.instanceColor.updateRange.count = n2 * 3), this.compute = lt(r, n2), this._spriteMaterial = l, s.spritesheet && this.updateSpritesheet(s.spritesheet), this._timer = new ut2(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(
      this.compute.animationRunner
    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;
  }
  updateSpritesheet(e) {
    const { dataTexture: n2, dataWidth: r, dataHeight: s, animMap: a } = Qe(e);
    this._spriteMaterial.uniforms.spritesheetData.value = n2, this._spriteMaterial.uniforms.dataSize.value.x = r, this._spriteMaterial.uniforms.dataSize.value.y = s, this.compute.animationRunner.material.uniforms.dataSize.value = new Vector2(r, s), this.compute.animationRunner.material.uniforms.spritesheetData.value = n2, this._animationMap = a;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(e) {
    this.updateSpritesheet(e), this._spritesheet = e;
  }
  get animationMap() {
    return this._animationMap;
  }
  get animation() {
    return {
      setAt: (e, n2) => {
        this.compute.utils.updateAnimationAt(
          e,
          this._animationMap.get(n2) || 0
        );
      }
    };
  }
  get frame() {
    return {
      setAt: (e, n2, r) => {
        var a;
        let s = n2;
        r && (s = (a = this.spritesheet) == null ? void 0 : a.animations[r][n2][0]), this.compute.utils.updateFrameAt(e, s);
      },
      unsetAt: (e) => {
        this.compute.utils.updateFrameAt(e, -10);
      },
      unsetAll: () => {
        for (let e = 0; e < this.count; e++)
          this.compute.utils.updateFrameAt(e, -10);
      }
    };
  }
  get playmode() {
    return {
      setAt: (e, n2) => {
        this.compute.utils.updatePlaymodeAt(e, K2[n2]);
      },
      setAll: (e) => {
        for (let n2 = 0; n2 < this.count; n2++) {
          const r = this.compute.progressDataTexture.image.data[n2 * 4 + 2] >= 10 ? 10 : 0;
          this.compute.utils.updatePlaymodeAt(n2, r + K2[e]);
        }
      }
    };
  }
  get billboarding() {
    return {
      setAt: (e, n2) => {
        this.setUniformAt("billboarding", e, n2 ? 1 : 0);
      },
      setAll: (e) => {
        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("billboarding");
      }
    };
  }
  get offset() {
    return {
      setAt: (e, n2) => {
        this.compute.utils.updateOffsetAt(e, n2);
      },
      randomizeAll: (e = 1) => {
        for (let n2 = 0; n2 < this.count; n2++)
          this.compute.utils.updateOffsetAt(n2, Math.random() * e);
      }
    };
  }
  get loop() {
    return {
      setAt: (e, n2) => {
        const r = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;
        this.compute.utils.updatePlaymodeAt(
          e,
          r + (n2 ? 0 : 10)
        );
      },
      setAll: (e) => {
        for (let n2 = 0; n2 < this.count; n2++) {
          const r = this.compute.progressDataTexture.image.data[n2 * 4 + 2] % 10;
          this.compute.utils.updatePlaymodeAt(n2, r + (e ? 0 : 10));
        }
      }
    };
  }
  get flipX() {
    return {
      setAt: (e, n2) => {
        this.setUniformAt("flipX", e, n2 ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipX");
      }
    };
  }
  get flipY() {
    return {
      setAt: (e, n2) => {
        this.setUniformAt("flipY", e, n2 ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipY");
      }
    };
  }
  play(e, n2 = true, r = "FORWARD") {
    return {
      at: (s) => {
        this.compute.utils.updateAnimationAt(
          s,
          this._animationMap.get(e) || 0
        ), this.compute.utils.updatePlaymodeAt(
          s,
          K2[r] + (n2 ? 0 : 10)
        );
      }
    };
  }
  /** HSV shift tinting */
  get hueShift() {
    const e = new Vector4();
    return {
      // TODO - per instance tinting doesnt work - artifacts
      // setAt: (
      //   instanceId: number,
      //   tint?: { h: number; s: number; v: number }
      // ) => {
      //   if (tint) {
      //     tVector.set(tint.h, tint.s, tint.v, 1);
      //   } else {
      //     tVector.setW(0);
      //   }
      //   this.setUniformAt("tint", instanceId, tVector);
      // },
      setGlobal: (n2) => {
        n2 ? e.set(n2.h, n2.s, n2.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;
      }
      // unsetAll: () => {
      //   this.unsetUniform("tint");
      // },
    };
  }
  get fps() {
    return this._fps;
  }
  set fps(e) {
    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;
  }
  update() {
    this._timer.update();
    const e = this._timer.getDelta();
    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();
  }
};
function ft(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
var te3 = { exports: {} };
te3.exports = G;
te3.exports.default = G;
function G(t2, i, e) {
  e = e || 2;
  var n2 = i && i.length, r = n2 ? i[0] * e : t2.length, s = de(t2, 0, r, e, true), a = [];
  if (!s || s.next === s.prev)
    return a;
  var l, u2, o, h, g4, c, f;
  if (n2 && (s = gt2(t2, i, s, e)), t2.length > 80 * e) {
    l = o = t2[0], u2 = h = t2[1];
    for (var m = e; m < r; m += e)
      g4 = t2[m], c = t2[m + 1], g4 < l && (l = g4), c < u2 && (u2 = c), g4 > o && (o = g4), c > h && (h = c);
    f = Math.max(o - l, h - u2), f = f !== 0 ? 32767 / f : 0;
  }
  return I3(s, a, e, l, u2, f, 0), a;
}
function de(t2, i, e, n2, r) {
  var s, a;
  if (r === X2(t2, i, e, n2) > 0)
    for (s = i; s < e; s += n2)
      a = me2(s, t2[s], t2[s + 1], a);
  else
    for (s = e - n2; s >= i; s -= n2)
      a = me2(s, t2[s], t2[s + 1], a);
  return a && Z2(a, a.next) && (E2(a), a = a.next), a;
}
function F2(t2, i) {
  if (!t2)
    return t2;
  i || (i = t2);
  var e = t2, n2;
  do
    if (n2 = false, !e.steiner && (Z2(e, e.next) || T3(e.prev, e, e.next) === 0)) {
      if (E2(e), e = i = e.prev, e === e.next)
        break;
      n2 = true;
    } else
      e = e.next;
  while (n2 || e !== i);
  return i;
}
function I3(t2, i, e, n2, r, s, a) {
  if (t2) {
    !a && s && _t(t2, n2, r, s);
    for (var l = t2, u2, o; t2.prev !== t2.next; ) {
      if (u2 = t2.prev, o = t2.next, s ? ht(t2, n2, r, s) : mt2(t2)) {
        i.push(u2.i / e | 0), i.push(t2.i / e | 0), i.push(o.i / e | 0), E2(t2), t2 = o.next, l = o.next;
        continue;
      }
      if (t2 = o, t2 === l) {
        a ? a === 1 ? (t2 = pt(F2(t2), i, e), I3(t2, i, e, n2, r, s, 2)) : a === 2 && dt2(t2, i, e, n2, r, s) : I3(F2(t2), i, e, n2, r, s, 1);
        break;
      }
    }
  }
}
function mt2(t2) {
  var i = t2.prev, e = t2, n2 = t2.next;
  if (T3(i, e, n2) >= 0)
    return false;
  for (var r = i.x, s = e.x, a = n2.x, l = i.y, u2 = e.y, o = n2.y, h = r < s ? r < a ? r : a : s < a ? s : a, g4 = l < u2 ? l < o ? l : o : u2 < o ? u2 : o, c = r > s ? r > a ? r : a : s > a ? s : a, f = l > u2 ? l > o ? l : o : u2 > o ? u2 : o, m = n2.next; m !== i; ) {
    if (m.x >= h && m.x <= c && m.y >= g4 && m.y <= f && V(r, l, s, u2, a, o, m.x, m.y) && T3(m.prev, m, m.next) >= 0)
      return false;
    m = m.next;
  }
  return true;
}
function ht(t2, i, e, n2) {
  var r = t2.prev, s = t2, a = t2.next;
  if (T3(r, s, a) >= 0)
    return false;
  for (var l = r.x, u2 = s.x, o = a.x, h = r.y, g4 = s.y, c = a.y, f = l < u2 ? l < o ? l : o : u2 < o ? u2 : o, m = h < g4 ? h < c ? h : c : g4 < c ? g4 : c, p = l > u2 ? l > o ? l : o : u2 > o ? u2 : o, d = h > g4 ? h > c ? h : c : g4 > c ? g4 : c, w = W(f, m, i, e, n2), _ = W(p, d, i, e, n2), x = t2.prevZ, v4 = t2.nextZ; x && x.z >= w && v4 && v4.z <= _; ) {
    if (x.x >= f && x.x <= p && x.y >= m && x.y <= d && x !== r && x !== a && V(l, h, u2, g4, o, c, x.x, x.y) && T3(x.prev, x, x.next) >= 0 || (x = x.prevZ, v4.x >= f && v4.x <= p && v4.y >= m && v4.y <= d && v4 !== r && v4 !== a && V(l, h, u2, g4, o, c, v4.x, v4.y) && T3(v4.prev, v4, v4.next) >= 0))
      return false;
    v4 = v4.nextZ;
  }
  for (; x && x.z >= w; ) {
    if (x.x >= f && x.x <= p && x.y >= m && x.y <= d && x !== r && x !== a && V(l, h, u2, g4, o, c, x.x, x.y) && T3(x.prev, x, x.next) >= 0)
      return false;
    x = x.prevZ;
  }
  for (; v4 && v4.z <= _; ) {
    if (v4.x >= f && v4.x <= p && v4.y >= m && v4.y <= d && v4 !== r && v4 !== a && V(l, h, u2, g4, o, c, v4.x, v4.y) && T3(v4.prev, v4, v4.next) >= 0)
      return false;
    v4 = v4.nextZ;
  }
  return true;
}
function pt(t2, i, e) {
  var n2 = t2;
  do {
    var r = n2.prev, s = n2.next.next;
    !Z2(r, s) && ge3(r, n2, n2.next, s) && O2(r, s) && O2(s, r) && (i.push(r.i / e | 0), i.push(n2.i / e | 0), i.push(s.i / e | 0), E2(n2), E2(n2.next), n2 = t2 = s), n2 = n2.next;
  } while (n2 !== t2);
  return F2(n2);
}
function dt2(t2, i, e, n2, r, s) {
  var a = t2;
  do {
    for (var l = a.next.next; l !== a.prev; ) {
      if (a.i !== l.i && Dt2(a, l)) {
        var u2 = xe2(a, l);
        a = F2(a, a.next), u2 = F2(u2, u2.next), I3(a, i, e, n2, r, s, 0), I3(u2, i, e, n2, r, s, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t2);
}
function gt2(t2, i, e, n2) {
  var r = [], s, a, l, u2, o;
  for (s = 0, a = i.length; s < a; s++)
    l = i[s] * n2, u2 = s < a - 1 ? i[s + 1] * n2 : t2.length, o = de(t2, l, u2, n2, false), o === o.next && (o.steiner = true), r.push(Mt2(o));
  for (r.sort(xt3), s = 0; s < r.length; s++)
    e = vt(r[s], e);
  return e;
}
function xt3(t2, i) {
  return t2.x - i.x;
}
function vt(t2, i) {
  var e = yt3(t2, i);
  if (!e)
    return i;
  var n2 = xe2(e, t2);
  return F2(n2, n2.next), F2(e, e.next);
}
function yt3(t2, i) {
  var e = i, n2 = t2.x, r = t2.y, s = -1 / 0, a;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var l = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (l <= n2 && l > s && (s = l, a = e.x < e.next.x ? e : e.next, l === n2))
        return a;
    }
    e = e.next;
  } while (e !== i);
  if (!a)
    return null;
  var u2 = a, o = a.x, h = a.y, g4 = 1 / 0, c;
  e = a;
  do
    n2 >= e.x && e.x >= o && n2 !== e.x && V(r < h ? n2 : s, r, o, h, r < h ? s : n2, r, e.x, e.y) && (c = Math.abs(r - e.y) / (n2 - e.x), O2(e, t2) && (c < g4 || c === g4 && (e.x > a.x || e.x === a.x && wt2(a, e))) && (a = e, g4 = c)), e = e.next;
  while (e !== u2);
  return a;
}
function wt2(t2, i) {
  return T3(t2.prev, t2, i.prev) < 0 && T3(i.next, t2, t2.next) < 0;
}
function _t(t2, i, e, n2) {
  var r = t2;
  do
    r.z === 0 && (r.z = W(r.x, r.y, i, e, n2)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== t2);
  r.prevZ.nextZ = null, r.prevZ = null, Tt2(r);
}
function Tt2(t2) {
  var i, e, n2, r, s, a, l, u2, o = 1;
  do {
    for (e = t2, t2 = null, s = null, a = 0; e; ) {
      for (a++, n2 = e, l = 0, i = 0; i < o && (l++, n2 = n2.nextZ, !!n2); i++)
        ;
      for (u2 = o; l > 0 || u2 > 0 && n2; )
        l !== 0 && (u2 === 0 || !n2 || e.z <= n2.z) ? (r = e, e = e.nextZ, l--) : (r = n2, n2 = n2.nextZ, u2--), s ? s.nextZ = r : t2 = r, r.prevZ = s, s = r;
      e = n2;
    }
    s.nextZ = null, o *= 2;
  } while (a > 1);
  return t2;
}
function W(t2, i, e, n2, r) {
  return t2 = (t2 - e) * r | 0, i = (i - n2) * r | 0, t2 = (t2 | t2 << 8) & 16711935, t2 = (t2 | t2 << 4) & 252645135, t2 = (t2 | t2 << 2) & 858993459, t2 = (t2 | t2 << 1) & 1431655765, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t2 | i << 1;
}
function Mt2(t2) {
  var i = t2, e = t2;
  do
    (i.x < e.x || i.x === e.x && i.y < e.y) && (e = i), i = i.next;
  while (i !== t2);
  return e;
}
function V(t2, i, e, n2, r, s, a, l) {
  return (r - a) * (i - l) >= (t2 - a) * (s - l) && (t2 - a) * (n2 - l) >= (e - a) * (i - l) && (e - a) * (s - l) >= (r - a) * (n2 - l);
}
function Dt2(t2, i) {
  return t2.next.i !== i.i && t2.prev.i !== i.i && !At2(t2, i) && // dones't intersect other edges
  (O2(t2, i) && O2(i, t2) && bt(t2, i) && // locally visible
  (T3(t2.prev, t2, i.prev) || T3(t2, i.prev, i)) || // does not create opposite-facing sectors
  Z2(t2, i) && T3(t2.prev, t2, t2.next) > 0 && T3(i.prev, i, i.next) > 0);
}
function T3(t2, i, e) {
  return (i.y - t2.y) * (e.x - i.x) - (i.x - t2.x) * (e.y - i.y);
}
function Z2(t2, i) {
  return t2.x === i.x && t2.y === i.y;
}
function ge3(t2, i, e, n2) {
  var r = H(T3(t2, i, e)), s = H(T3(t2, i, n2)), a = H(T3(e, n2, t2)), l = H(T3(e, n2, i));
  return !!(r !== s && a !== l || r === 0 && z(t2, e, i) || s === 0 && z(t2, n2, i) || a === 0 && z(e, t2, n2) || l === 0 && z(e, i, n2));
}
function z(t2, i, e) {
  return i.x <= Math.max(t2.x, e.x) && i.x >= Math.min(t2.x, e.x) && i.y <= Math.max(t2.y, e.y) && i.y >= Math.min(t2.y, e.y);
}
function H(t2) {
  return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
}
function At2(t2, i) {
  var e = t2;
  do {
    if (e.i !== t2.i && e.next.i !== t2.i && e.i !== i.i && e.next.i !== i.i && ge3(e, e.next, t2, i))
      return true;
    e = e.next;
  } while (e !== t2);
  return false;
}
function O2(t2, i) {
  return T3(t2.prev, t2, t2.next) < 0 ? T3(t2, i, t2.next) >= 0 && T3(t2, t2.prev, i) >= 0 : T3(t2, i, t2.prev) < 0 || T3(t2, t2.next, i) < 0;
}
function bt(t2, i) {
  var e = t2, n2 = false, r = (t2.x + i.x) / 2, s = (t2.y + i.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n2 = !n2), e = e.next;
  while (e !== t2);
  return n2;
}
function xe2(t2, i) {
  var e = new Y2(t2.i, t2.x, t2.y), n2 = new Y2(i.i, i.x, i.y), r = t2.next, s = i.prev;
  return t2.next = i, i.prev = t2, e.next = r, r.prev = e, n2.next = e, e.prev = n2, s.next = n2, n2.prev = s, n2;
}
function me2(t2, i, e, n2) {
  var r = new Y2(t2, i, e);
  return n2 ? (r.next = n2.next, r.prev = n2, n2.next.prev = r, n2.next = r) : (r.prev = r, r.next = r), r;
}
function E2(t2) {
  t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
}
function Y2(t2, i, e) {
  this.i = t2, this.x = i, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
G.deviation = function(t2, i, e, n2) {
  var r = i && i.length, s = r ? i[0] * e : t2.length, a = Math.abs(X2(t2, 0, s, e));
  if (r)
    for (var l = 0, u2 = i.length; l < u2; l++) {
      var o = i[l] * e, h = l < u2 - 1 ? i[l + 1] * e : t2.length;
      a -= Math.abs(X2(t2, o, h, e));
    }
  var g4 = 0;
  for (l = 0; l < n2.length; l += 3) {
    var c = n2[l] * e, f = n2[l + 1] * e, m = n2[l + 2] * e;
    g4 += Math.abs(
      (t2[c] - t2[m]) * (t2[f + 1] - t2[c + 1]) - (t2[c] - t2[f]) * (t2[m + 1] - t2[c + 1])
    );
  }
  return a === 0 && g4 === 0 ? 0 : Math.abs((g4 - a) / a);
};
function X2(t2, i, e, n2) {
  for (var r = 0, s = i, a = e - n2; s < e; s += n2)
    r += (t2[a] - t2[s]) * (t2[s + 1] + t2[a + 1]), a = s;
  return r;
}
G.flatten = function(t2) {
  for (var i = t2[0][0].length, e = { vertices: [], holes: [], dimensions: i }, n2 = 0, r = 0; r < t2.length; r++) {
    for (var s = 0; s < t2[r].length; s++)
      for (var a = 0; a < i; a++)
        e.vertices.push(t2[r][s][a]);
    r > 0 && (n2 += t2[r - 1].length, e.holes.push(n2));
  }
  return e;
};
var Ut2 = te3.exports;
var Ft3 = ft(Ut2);
new Vector2();
new Vector2();
function St(t2, i) {
  var e = t2 % i, n2 = Math.floor(t2 / i);
  return [e, n2];
}
function Pt2(t2, i, e) {
  for (var n2 = 0, r = 0; n2 < t2.length; n2 += i, r++)
    if (i === 3) {
      var s = e([t2[n2], t2[n2 + 1], t2[n2 + 2]], r);
      t2.set(s, n2);
    } else
      t2.set(e([t2[n2], t2[n2 + 1]], r), n2);
  return t2;
}
function Rt(t2, i, e, n2) {
  var r = e.x - n2.x, s = t2.x - i.x, a = e.y - n2.y, l = t2.y - i.y, u2 = s * a - l * r;
  if (u2 == 0)
    throw new Error("Number of intersection points is zero or infinity.");
  var o = t2.x * i.y - t2.y * i.x, h = e.x * n2.y - e.y * n2.x, g4 = (o * r - s * h) / u2, c = (o * a - l * h) / u2, f = { x: g4, y: c };
  return f;
}
function Vt2(t2) {
  for (var i = 0, e = 0, n2 = t2.length; e < n2; e++) {
    var r = t2[e].x, s = t2[e == t2.length - 1 ? 0 : e + 1].y, a = t2[e == t2.length - 1 ? 0 : e + 1].x, l = t2[e].y;
    i += r * s * 0.5, i -= a * l * 0.5;
  }
  return Math.abs(i);
}
function Ct3([t2, i, e]) {
  return Math.abs(
    (t2.x * (i.y - e.y) + i.x * (e.y - t2.y) + e.x * (t2.y - i.y)) / 2
  );
}
function It(t2, i = 8) {
  const e = t2.slice();
  let n2 = 0;
  for (; e.length > i && n2 < 1e3; ) {
    n2++;
    let r = 1 / 0, s = null;
    for (let a = 0; a <= e.length - 1; a++) {
      const l = e.length, u2 = [a, (a + 1) % l, (a + 2) % l, (a + 3) % l], o = e[u2[0]], h = e[u2[1]], g4 = e[u2[2]], c = e[u2[3]];
      try {
        const f = Rt(o, h, g4, c), m = Ct3([f, h, g4]);
        m < r && (r = m, s = {
          point: f,
          area: m,
          indicesToRemove: [u2[1], u2[2]]
        });
      } catch (f) {
        console.log(f);
      }
    }
    if (s) {
      const a = s.indicesToRemove[0], l = s.indicesToRemove[1];
      l > a ? (e.splice(l, 1), e.splice(a, 1)) : (e.splice(a, 1), e.splice(l, 1)), e.splice(Math.min(a, l), 0, s.point);
    }
  }
  return e;
}
var J;
((t2) => {
  function i(r) {
    let s = r.slice();
    return s.sort(t2.POINT_COMPARATOR), t2.makeHullPresorted(s);
  }
  t2.makeHull = i;
  function e(r) {
    if (r.length <= 1)
      return r.slice();
    let s = [];
    for (let l = 0; l < r.length; l++) {
      const u2 = r[l];
      for (; s.length >= 2; ) {
        const o = s[s.length - 1], h = s[s.length - 2];
        if ((o.x - h.x) * (u2.y - h.y) >= (o.y - h.y) * (u2.x - h.x))
          s.pop();
        else
          break;
      }
      s.push(u2);
    }
    s.pop();
    let a = [];
    for (let l = r.length - 1; l >= 0; l--) {
      const u2 = r[l];
      for (; a.length >= 2; ) {
        const o = a[a.length - 1], h = a[a.length - 2];
        if ((o.x - h.x) * (u2.y - h.y) >= (o.y - h.y) * (u2.x - h.x))
          a.pop();
        else
          break;
      }
      a.push(u2);
    }
    return a.pop(), s.length == 1 && a.length == 1 && s[0].x == a[0].x && s[0].y == a[0].y ? s : s.concat(a);
  }
  t2.makeHullPresorted = e;
  function n2(r, s) {
    return r.x < s.x ? -1 : r.x > s.x ? 1 : r.y < s.y ? -1 : r.y > s.y ? 1 : 0;
  }
  t2.POINT_COMPARATOR = n2;
})(J || (J = {}));
function Ot2(t2, i) {
  const e = new Float32Array(t2);
  for (let n2 = 0; n2 < t2; n2++)
    e[n2 * 3] = i[0], e[n2 * 3 + 1] = i[1], e[n2 * 3 + 2] = i[2];
  return e;
}
function Et2(t2, i, e = () => Math.random()) {
  const n2 = i + 1, r = new Float32Array(t2.length / i * n2);
  for (let s = 0; s < t2.length; s += i) {
    let a = s / i * n2;
    r[a] = t2[s], r[a + 1] = t2[s + 1], i === 2 && (r[a + 2] = e(a)), i === 3 && (r[a + 2] = t2[s + 2], r[a + 3] = e(a));
  }
  return r;
}
function $t(t2) {
  const i = new Float32Array(t2.length * 2);
  for (let e = 0; e < t2.length; e++)
    i[e * 2] = t2[e].x, i[e * 2 + 1] = t2[e].y;
  return i;
}
function zt2(t2, i, e) {
  const n2 = [], r = t2 % (i * 4) / 4, s = Math.floor(t2 / (i * 4)), a = s - 1, l = s + 1, u2 = r - 1, o = r + 1;
  return a >= 0 ? n2.push(a * i + r) : n2.push(null), l < e ? n2.push(l * i + r) : n2.push(null), u2 >= 0 ? n2.push(s * i + u2) : n2.push(null), o < i ? n2.push(s * i + o) : n2.push(null), n2;
}
var Ht = (t2) => (...i) => i[3] / 255 > 0;
var Lt2 = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [0, 0],
  scale: 1,
  filter: Ht
};
var kt = class {
  constructor(i, e, n2) {
    y(this, "points", []);
    y(this, "data", {
      areaReduction: 0
    });
    y(this, "debug", true);
    y(this, "index");
    y(this, "positions");
    y(this, "uv");
    y(this, "defaultSettings", Lt2);
    y(this, "settings");
    this.vertices = n2, this.settings = { ...this.defaultSettings, ...e };
    const { slices: r } = this.settings, s = Nt2("bvc-image", i.width, i.height);
    this.points = this.getPoints(i, s);
    let a = J.makeHull(this.points);
    const l = It(a, n2), u2 = l.map((c) => {
      let f = Gt(c, [i.width, i.height], r);
      return f.y = -1 * f.y, f;
    }), { scale: o } = this.settings;
    this.data.areaReduction = 1 - Vt2(l) / (i.width / r[0] * (i.height / r[1])) * o;
    const h = $t(u2), g4 = Ft3(h, null, 2);
    this.positions = Et2(h, 2, () => 0), this.index = Uint32Array.from(g4), this.uv = Pt2(h.slice(0), 2, (c) => {
      let f = c[0] + 0.5;
      f = f / this.settings.slices[0] + 1 / this.settings.slices[0] * this.settings.indices[0];
      let m = c[1] + 0.5;
      return m = m / this.settings.slices[1] + 1 - 1 / this.settings.slices[1] * (this.settings.indices[1] + 1), [f, m];
    });
  }
  getImageData(i, e) {
    const n2 = e.getContext("2d");
    n2.drawImage(i, 0, 0);
    const [r, s] = this.settings.indices, [a, l] = this.settings.slices, u2 = e.width / a, o = e.height / l;
    return n2.getImageData(u2 * r, o * s, u2, o);
  }
  /**
   * Iterates over the image and returns an array of points that are over the alpha threshold.
   * It reduces the number of returned points by excluding points that are surrounded by solid pixels.
   *
   * @param img An image element with the image already loaded
   * @param canvas A canvas element to draw the image on in order to get the color values
   * @returns
   */
  getPoints(i, e) {
    const n2 = this.getImageData(i, e), r = n2.data, s = [], a = this.settings.filter(this.settings.threshold), l = (u2) => u2 !== null && a(
      r[u2 * 4],
      r[u2 * 4 + 1],
      r[u2 * 4 + 2],
      r[u2 * 4 + 3]
    );
    for (let u2 = 0; u2 < r.length; u2 += 4)
      if (a(
        r[u2 + 0],
        r[u2 + 1],
        r[u2 + 2],
        r[u2 + 3]
      )) {
        if (zt2(u2, e.width, e.height).every(l))
          continue;
        const [g4, c] = St(u2 / 4, n2.width);
        s.push({ x: g4, y: c });
      }
    return s;
  }
};
var Nt2 = (t2 = "debug-canvas", i, e) => {
  const n2 = document.querySelector(`#${t2}`) || document.createElement("canvas");
  return n2.id = t2, n2.width = i, n2.height = e, n2.id = t2, n2;
};
var Gt = (t2, i, e) => ({
  x: (t2.x - i[0] / (2 * e[0])) / (i[0] / e[0]),
  y: (t2.y - i[1] / (2 * e[1])) / (i[1] / e[1])
});
var Zt = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [1, 1]
};
var Bt2 = class extends BufferGeometry {
  constructor(e, n2 = 8, r = 0.01, s = [1, 1], a = [0, 0]) {
    super();
    y(this, "image");
    y(this, "vertices", 8);
    y(this, "settings", Zt);
    this.vertices = n2, this.settings = {
      ...this.settings,
      threshold: r,
      slices: s,
      indices: a
    }, this.image = "image" in e ? e.image : e, this.build();
  }
  build() {
    const e = new kt(
      this.image,
      this.settings,
      this.vertices
    ), n2 = e.positions.length, r = new BufferAttribute(e.index, 1), s = new BufferAttribute(e.positions, 3), a = new BufferAttribute(Ot2(n2, [0, 0, 1]), 3), l = new BufferAttribute(e.uv, 2);
    this.userData.reduction = e.data.areaReduction, this.setIndex(r), this.setAttribute("position", s), this.setAttribute("normal", a), this.setAttribute("uv", l);
  }
};
var Jt2 = () => new Kt();
var Kt = class {
  constructor() {
    y(this, "animations");
    this.animations = [];
  }
  add(i, e, n2) {
    const r = {
      name: "",
      imageUrl: i
    };
    return Array.isArray(n2) ? r.multiAnimations = n2 : r.name = n2, e.type == "rowColumn" && (r.auto = {
      type: "rowColumn",
      width: e.width,
      height: e.height
    }), e.type == "frameSize" && (r.auto = {
      type: "frameSize",
      width: e.width,
      height: e.height
    }), this.animations.push(r), this;
  }
  async build(i = {}) {
    const e = new ImageLoader(), n2 = {
      frames: [],
      animations: {},
      sheetSize: [0, 0],
      animationLengths: []
    };
    let r = new Texture();
    const s = [];
    let a = 0, l = 0;
    for (const p of this.animations) {
      const d = await e.loadAsync(p.imageUrl), w = d.width, _ = d.height;
      a = Math.max(a, w), l += _, s.push({
        img: d,
        w,
        h: _
      });
    }
    const u2 = document.createElement("canvas");
    u2.width = a, u2.height = l;
    const o = u2.getContext("2d");
    let h = 0;
    for (const { img: p, h: d } of s)
      o == null || o.drawImage(p, 0, h, p.width, p.height), h += d;
    r = new CanvasTexture(u2), r.needsUpdate = true;
    let g4 = 0, c = 0, f = 0, m = 64;
    for (const p of this.animations) {
      const d = s[g4];
      let w = 0;
      if (p.auto) {
        let _ = 0, x = 0;
        p.auto.type == "frameSize" && (x = d.w / p.auto.width, _ = d.h / p.auto.height), p.auto.type == "rowColumn" && (x = p.auto.width, _ = p.auto.height);
        const v4 = d.w / x, S = d.h / _;
        w = _ * x, p.multiAnimations || (n2.animations[p.name] = []);
        const P2 = /* @__PURE__ */ new Map();
        for (let D2 = 0; D2 < _; D2++) {
          f += S;
          for (let A3 = 0; A3 < x; A3++) {
            if (n2.frames.push([
              d.w / x * A3 / a,
              1 - f / l,
              v4 / a,
              S / l
            ]), p.multiAnimations) {
              const ve2 = D2 * x + A3;
              P2.set(ve2, c);
            } else
              n2.animations[p.name].push([c, 1]);
            c++;
          }
        }
        if (p.multiAnimations)
          for (const D2 of p.multiAnimations) {
            n2.animations[D2.name] = [], n2.animationLengths.push(
              D2.frameRange[1] - D2.frameRange[0] + 1
            );
            for (let A3 = D2.frameRange[0]; A3 <= D2.frameRange[1]; A3++)
              n2.animations[D2.name].push([P2.get(A3), 1]);
          }
        else
          n2.animationLengths.push(w);
      }
      g4++;
    }
    if (r.matrixAutoUpdate = false, r.generateMipmaps = false, r.premultiplyAlpha = false, r.wrapS = r.wrapT = RepeatWrapping, r.magFilter = r.minFilter = NearestFilter, r.colorSpace = SRGBColorSpace, n2.sheetSize = [a, l], i.makeSlimGeometry) {
      const p = document.createElement("canvas");
      p.width = m, p.height = m;
      const d = p.getContext("2d"), w = a / m, _ = l / m;
      for (let S = 0; S < w; S++)
        for (let P2 = 0; P2 < _; P2++) {
          const D2 = S * m, A3 = P2 * m;
          d == null || d.drawImage(u2, D2, A3, m, m, 0, 0, m, m);
        }
      const x = new CanvasTexture(p);
      x.magFilter = r.minFilter = NearestFilter, x.colorSpace = SRGBColorSpace;
      const v4 = new Bt2(
        x,
        // an already loaded HTMLImageElement or a ThreeJS texture
        i.slimOptions ? i.slimOptions.vertices : 8,
        i.slimOptions ? i.slimOptions.alphaThreshold : 0
        // alphaThreshold, 0 means only fully transparent pixels will be discarded
      );
      return { spritesheet: n2, texture: r, geometry: v4 };
    }
    return { spritesheet: n2, texture: r };
  }
};

// node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte
mark_module_start();
SpriteInstance[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte";
function SpriteInstance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SpriteInstance);
  let id = prop($$props, "id", 3, 0), position2 = prop($$props, "position", 19, () => [0, 0, 0]), scale = prop($$props, "scale", 19, () => [1, 1]);
  const { updatePosition, sprite } = getContext("instanced-sprite-ctx");
  user_pre_effect(() => {
    if (strict_equals(position2(), void 0, false)) updatePosition(id(), position2(), scale());
  });
  user_pre_effect(() => {
    if (strict_equals($$props.animationName, void 0, false)) sprite.animation.setAt(id(), $$props.animationName);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.playmode, void 0, false)) sprite.playmode.setAt(id(), $$props.playmode);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0, false)) sprite.billboarding.setAt(id(), $$props.billboarding);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.offset, void 0, false)) sprite.offset.setAt(id(), $$props.offset);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.loop, void 0, false)) sprite.loop.setAt(id(), $$props.loop);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipX, void 0, false)) sprite.flipX.setAt(id(), $$props.flipX);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipY, void 0, false)) sprite.flipY.setAt(id(), $$props.flipY);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.frameId, void 0, false)) sprite.frame.setAt(id(), $$props.frameId, $$props.animationName);
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SpriteInstance = hmr(SpriteInstance, () => SpriteInstance[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SpriteInstance[HMR].source;
    set(SpriteInstance[HMR].source, module.default[HMR].original);
  });
}
var SpriteInstance_default = SpriteInstance;
mark_module_end(SpriteInstance);

// node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte
mark_module_start();
InstancedSprite[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte";
function InstancedSprite($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedSprite);
  let autoUpdate = prop($$props, "autoUpdate", 3, true), baseMaterial = prop($$props, "baseMaterial", 3, MeshBasicMaterial), fps = prop($$props, "fps", 3, 15), playmode = prop($$props, "playmode", 3, "FORWARD"), count = prop($$props, "count", 3, 1e3), alphaTest = prop($$props, "alphaTest", 3, 0.1), transparent = prop($$props, "transparent", 3, true), randomPlaybackOffset = prop($$props, "randomPlaybackOffset", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoUpdate",
      "baseMaterial",
      "fps",
      "billboarding",
      "playmode",
      "count",
      "alphaTest",
      "transparent",
      "hueShift",
      "randomPlaybackOffset",
      "spritesheet",
      "ref",
      "children"
    ],
    "props"
  );
  const spriteBaseMaterial = new (baseMaterial())({
    transparent: transparent(),
    alphaTest: alphaTest(),
    // needs to be double side for shading
    side: DoubleSide
  });
  const { renderer } = useThrelte();
  const mesh = new Xt(spriteBaseMaterial, count(), renderer);
  ref(mesh);
  const animationMap = writable(/* @__PURE__ */ new Map());
  user_pre_effect(() => {
    if ($$props.spritesheet) {
      mesh.spritesheet = $$props.spritesheet.spritesheet;
      animationMap.set(mesh.animationMap);
      mesh.material.map = $$props.spritesheet.texture;
      mesh.material.needsUpdate = true;
    }
  });
  user_pre_effect(() => {
    mesh.material.alphaTest = alphaTest();
  });
  user_pre_effect(() => {
    mesh.material.transparent = transparent();
  });
  user_pre_effect(() => {
    mesh.fps = fps();
  });
  user_pre_effect(() => mesh.hueShift.setGlobal($$props.hueShift));
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0)) {
      mesh.billboarding.unsetAll();
      return;
    } else {
      mesh.billboarding.setAll($$props.billboarding);
    }
  });
  user_pre_effect(() => {
    if (strict_equals(playmode(), void 0)) {
      mesh.playmode.setAll("PAUSE");
      return;
    } else {
      mesh.playmode.setAll(playmode());
    }
  });
  let previousRndOffset = state(false);
  user_pre_effect(() => {
    if (strict_equals(get(previousRndOffset), false) && randomPlaybackOffset()) {
      mesh.offset.randomizeAll(strict_equals(randomPlaybackOffset(), true) ? 100 : randomPlaybackOffset());
    }
    if (strict_equals(get(previousRndOffset), true) && !randomPlaybackOffset()) {
      for (let i = 0; i < count(); i++) {
        mesh.offset.setAt(i, 0);
      }
    }
    set(previousRndOffset, proxy(randomPlaybackOffset() ? true : false, null, previousRndOffset));
  });
  let instanceMatrixNeedsUpdate = false;
  const tempMatrix3 = new Matrix4();
  const updatePosition = (id, position2, scale = [1, 1]) => {
    tempMatrix3.makeScale(scale[0], scale[1], 1);
    tempMatrix3.setPosition(...position2);
    mesh.setMatrixAt(id, tempMatrix3);
    instanceMatrixNeedsUpdate = true;
  };
  setContext("instanced-sprite-ctx", {
    sprite: mesh,
    count: count(),
    animationMap,
    updatePosition
  });
  useTask(() => {
    if (autoUpdate()) {
      mesh.update();
    }
    if (instanceMatrixNeedsUpdate) {
      mesh.instanceMatrix.needsUpdate = true;
      instanceMatrixNeedsUpdate = false;
    }
  });
  mesh.update();
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props({ is: mesh, frustumCulled: false }, () => props, {
    children: wrap_snippet(InstancedSprite, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop, () => ({ Instance: SpriteInstance_default }));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedSprite = hmr(InstancedSprite, () => InstancedSprite[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedSprite[HMR].source;
    set(InstancedSprite[HMR].source, module.default[HMR].original);
  });
}
var InstancedSprite_default = InstancedSprite;
mark_module_end(InstancedSprite);

// node_modules/@threlte/extras/dist/components/InstancedSprite/instancedSpriteUtils.js
var useInstancedSprite = () => {
  return getContext("instanced-sprite-ctx");
};
var from = (meta) => {
  const builder = Jt2();
  const animationsList = [];
  for (const { url, type, width, height, animations } of meta) {
    for (const animation of animations) {
      animationsList.push(animation.name);
    }
    builder.add(url, {
      type,
      width,
      height
    }, animations);
  }
  const spritesheet = builder.build();
  const typedHook = useInstancedSprite;
  return { spritesheet, useInstancedSprite: typedHook };
};
var fromAseprite = (asepriteDataUrl, spriteImageUrl) => {
  const texture = new TextureLoader().load(spriteImageUrl, (t2) => {
    t2.matrixAutoUpdate = false;
    t2.generateMipmaps = false;
    t2.premultiplyAlpha = false;
    t2.wrapS = texture.wrapT = RepeatWrapping;
    t2.magFilter = texture.minFilter = NearestFilter;
    t2.colorSpace = SRGBColorSpace;
    t2.needsUpdate = true;
  });
  const parse = async () => {
    const res = await fetch(asepriteDataUrl);
    const json = await res.json();
    return { spritesheet: Yt(json), texture };
  };
  return parse();
};
var buildSpritesheet = { from, fromAseprite };
export {
  Align_default as Align,
  AnimatedSpriteMaterial_default as AnimatedSpriteMaterial,
  AsciiRenderer_default as AsciiRenderer,
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  BakeShadows_default as BakeShadows,
  Billboard_default as Billboard,
  CSM_default as CSM,
  ContactShadows_default as ContactShadows,
  CubeCamera_default as CubeCamera,
  CubeEnvironment_default as CubeEnvironment,
  Detailed_default as Detailed,
  Edges_default as Edges,
  Environment_default as Environment,
  FakeGlowMaterial_default as FakeGlowMaterial,
  Float_default as Float,
  GLTF_default as GLTF,
  Gizmo_default as Gizmo,
  Grid_default as Grid,
  HTML_default as HTML,
  HUD_default as HUD,
  ImageMaterial_default as ImageMaterial,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  InstancedMeshes_default as InstancedMeshes,
  InstancedSprite_default as InstancedSprite,
  LinearGradientTexture_default as LinearGradientTexture,
  Mask_default as Mask,
  MeshDiscardMaterial_default as MeshDiscardMaterial,
  MeshLineGeometry_default as MeshLineGeometry,
  MeshLineMaterial_default as MeshLineMaterial,
  MeshRefractionMaterial_default as MeshRefractionMaterial,
  OrbitControls_default as OrbitControls,
  Outlines_default as Outlines,
  PerfMonitor_default as PerfMonitor,
  Portal_default as Portal,
  PortalTarget_default as PortalTarget,
  PositionalAudio_default as PositionalAudio,
  RadialGradientTexture_default as RadialGradientTexture,
  Resize_default as Resize,
  RoundedBoxGeometry_default as RoundedBoxGeometry,
  Sky_default as Sky,
  SoftShadows_default as SoftShadows,
  Stars_default as Stars,
  Suspense_default as Suspense,
  Text_default as Text,
  Text3DGeometry_default as Text3DGeometry,
  TrackballControls_default as TrackballControls,
  TransformControls_default as TransformControls,
  View_default as View,
  VirtualEnvironment_default as VirtualEnvironment,
  buildSpritesheet,
  createTransition,
  global,
  interactivity,
  layers,
  meshBounds,
  onReveal,
  onSuspend,
  transitions,
  useAudioListener,
  useCursor,
  useDraco,
  useFBO,
  useGamepad,
  useGltf,
  useGltfAnimations,
  useInstancedSprite,
  useInteractivity,
  useKtx2,
  useMask,
  useMeshopt,
  useProgress,
  useSuspense,
  useTexture,
  useThrelteAudio,
  useViewport
};
/*! Bundled license information:

tweakpane/dist/tweakpane.js:
  (*! Tweakpane 3.1.10 (c) 2016 cocopon, licensed under the MIT license. *)

three/examples/jsm/libs/fflate.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.8.2
  *)

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
  (*!
  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
  for use in Troika text rendering. 
  Original MIT license applies
  *)

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
  (*!
  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
  for use in Troika text rendering. 
  Original MIT license applies
  *)
*/
//# sourceMappingURL=@threlte_extras.js.map
